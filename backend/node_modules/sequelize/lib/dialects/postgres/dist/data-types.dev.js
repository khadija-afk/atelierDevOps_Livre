"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _ = require("lodash");

var wkx = require("wkx");

module.exports = function (BaseTypes) {
  var warn = BaseTypes.ABSTRACT.warn.bind(void 0, "http://www.postgresql.org/docs/9.4/static/datatype.html");

  function removeUnsupportedIntegerOptions(dataType) {
    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {
      warn("PostgresSQL does not support '".concat(dataType.key, "' with LENGTH, UNSIGNED or ZEROFILL. Plain '").concat(dataType.key, "' will be used instead."));
      dataType._length = void 0;
      dataType.options.length = void 0;
      dataType._unsigned = void 0;
      dataType._zerofill = void 0;
    }
  }

  BaseTypes.UUID.types.postgres = ["uuid"];
  BaseTypes.CIDR.types.postgres = ["cidr"];
  BaseTypes.INET.types.postgres = ["inet"];
  BaseTypes.MACADDR.types.postgres = ["macaddr"];
  BaseTypes.TSVECTOR.types.postgres = ["tsvector"];
  BaseTypes.JSON.types.postgres = ["json"];
  BaseTypes.JSONB.types.postgres = ["jsonb"];
  BaseTypes.TIME.types.postgres = ["time"];

  var DATEONLY =
  /*#__PURE__*/
  function (_BaseTypes$DATEONLY) {
    _inherits(DATEONLY, _BaseTypes$DATEONLY);

    function DATEONLY() {
      _classCallCheck(this, DATEONLY);

      return _possibleConstructorReturn(this, _getPrototypeOf(DATEONLY).apply(this, arguments));
    }

    _createClass(DATEONLY, [{
      key: "_stringify",
      value: function _stringify(value, options) {
        if (value === Infinity) {
          return "Infinity";
        }

        if (value === -Infinity) {
          return "-Infinity";
        }

        return _get(_getPrototypeOf(DATEONLY.prototype), "_stringify", this).call(this, value, options);
      }
    }, {
      key: "_sanitize",
      value: function _sanitize(value, options) {
        if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {
          if (typeof value === "string") {
            var lower = value.toLowerCase();

            if (lower === "infinity") {
              return Infinity;
            }

            if (lower === "-infinity") {
              return -Infinity;
            }
          }

          return _get(_getPrototypeOf(DATEONLY.prototype), "_sanitize", this).call(this, value);
        }

        return value;
      }
    }], [{
      key: "parse",
      value: function parse(value) {
        if (value === "infinity") {
          return Infinity;
        }

        if (value === "-infinity") {
          return -Infinity;
        }

        return value;
      }
    }]);

    return DATEONLY;
  }(BaseTypes.DATEONLY);

  BaseTypes.DATEONLY.types.postgres = ["date"];

  var DECIMAL =
  /*#__PURE__*/
  function (_BaseTypes$DECIMAL) {
    _inherits(DECIMAL, _BaseTypes$DECIMAL);

    function DECIMAL() {
      _classCallCheck(this, DECIMAL);

      return _possibleConstructorReturn(this, _getPrototypeOf(DECIMAL).apply(this, arguments));
    }

    _createClass(DECIMAL, null, [{
      key: "parse",
      value: function parse(value) {
        return value;
      }
    }]);

    return DECIMAL;
  }(BaseTypes.DECIMAL);

  BaseTypes.DECIMAL.types.postgres = ["numeric"];

  var STRING =
  /*#__PURE__*/
  function (_BaseTypes$STRING) {
    _inherits(STRING, _BaseTypes$STRING);

    function STRING() {
      _classCallCheck(this, STRING);

      return _possibleConstructorReturn(this, _getPrototypeOf(STRING).apply(this, arguments));
    }

    _createClass(STRING, [{
      key: "toSql",
      value: function toSql() {
        if (this._binary) {
          return "BYTEA";
        }

        return _get(_getPrototypeOf(STRING.prototype), "toSql", this).call(this);
      }
    }]);

    return STRING;
  }(BaseTypes.STRING);

  BaseTypes.STRING.types.postgres = ["varchar"];

  var TEXT =
  /*#__PURE__*/
  function (_BaseTypes$TEXT) {
    _inherits(TEXT, _BaseTypes$TEXT);

    function TEXT() {
      _classCallCheck(this, TEXT);

      return _possibleConstructorReturn(this, _getPrototypeOf(TEXT).apply(this, arguments));
    }

    _createClass(TEXT, [{
      key: "toSql",
      value: function toSql() {
        if (this._length) {
          warn("PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.");
          this._length = void 0;
        }

        return "TEXT";
      }
    }]);

    return TEXT;
  }(BaseTypes.TEXT);

  BaseTypes.TEXT.types.postgres = ["text"];

  var CITEXT =
  /*#__PURE__*/
  function (_BaseTypes$CITEXT) {
    _inherits(CITEXT, _BaseTypes$CITEXT);

    function CITEXT() {
      _classCallCheck(this, CITEXT);

      return _possibleConstructorReturn(this, _getPrototypeOf(CITEXT).apply(this, arguments));
    }

    _createClass(CITEXT, null, [{
      key: "parse",
      value: function parse(value) {
        return value;
      }
    }]);

    return CITEXT;
  }(BaseTypes.CITEXT);

  BaseTypes.CITEXT.types.postgres = ["citext"];

  var CHAR =
  /*#__PURE__*/
  function (_BaseTypes$CHAR) {
    _inherits(CHAR, _BaseTypes$CHAR);

    function CHAR() {
      _classCallCheck(this, CHAR);

      return _possibleConstructorReturn(this, _getPrototypeOf(CHAR).apply(this, arguments));
    }

    _createClass(CHAR, [{
      key: "toSql",
      value: function toSql() {
        if (this._binary) {
          return "BYTEA";
        }

        return _get(_getPrototypeOf(CHAR.prototype), "toSql", this).call(this);
      }
    }]);

    return CHAR;
  }(BaseTypes.CHAR);

  BaseTypes.CHAR.types.postgres = ["char", "bpchar"];

  var BOOLEAN =
  /*#__PURE__*/
  function (_BaseTypes$BOOLEAN) {
    _inherits(BOOLEAN, _BaseTypes$BOOLEAN);

    function BOOLEAN() {
      _classCallCheck(this, BOOLEAN);

      return _possibleConstructorReturn(this, _getPrototypeOf(BOOLEAN).apply(this, arguments));
    }

    _createClass(BOOLEAN, [{
      key: "toSql",
      value: function toSql() {
        return "BOOLEAN";
      }
    }, {
      key: "_sanitize",
      value: function _sanitize(value) {
        if (value !== null && value !== void 0) {
          if (Buffer.isBuffer(value) && value.length === 1) {
            value = value[0];
          }

          if (typeof value === "string") {
            return ["true", "t"].includes(value) ? true : ["false", "f"].includes(value) ? false : value;
          }

          if (typeof value === "number") {
            return value === 1 ? true : value === 0 ? false : value;
          }
        }

        return value;
      }
    }]);

    return BOOLEAN;
  }(BaseTypes.BOOLEAN);

  BOOLEAN.parse = BOOLEAN.prototype._sanitize;
  BaseTypes.BOOLEAN.types.postgres = ["bool"];

  var DATE =
  /*#__PURE__*/
  function (_BaseTypes$DATE) {
    _inherits(DATE, _BaseTypes$DATE);

    function DATE() {
      _classCallCheck(this, DATE);

      return _possibleConstructorReturn(this, _getPrototypeOf(DATE).apply(this, arguments));
    }

    _createClass(DATE, [{
      key: "toSql",
      value: function toSql() {
        return "TIMESTAMP WITH TIME ZONE";
      }
    }, {
      key: "validate",
      value: function validate(value) {
        if (value !== Infinity && value !== -Infinity) {
          return _get(_getPrototypeOf(DATE.prototype), "validate", this).call(this, value);
        }

        return true;
      }
    }, {
      key: "_stringify",
      value: function _stringify(value, options) {
        if (value === Infinity) {
          return "Infinity";
        }

        if (value === -Infinity) {
          return "-Infinity";
        }

        return _get(_getPrototypeOf(DATE.prototype), "_stringify", this).call(this, value, options);
      }
    }, {
      key: "_sanitize",
      value: function _sanitize(value, options) {
        if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {
          if (typeof value === "string") {
            var lower = value.toLowerCase();

            if (lower === "infinity") {
              return Infinity;
            }

            if (lower === "-infinity") {
              return -Infinity;
            }
          }

          return new Date(value);
        }

        return value;
      }
    }]);

    return DATE;
  }(BaseTypes.DATE);

  BaseTypes.DATE.types.postgres = ["timestamptz"];

  var TINYINT =
  /*#__PURE__*/
  function (_BaseTypes$TINYINT) {
    _inherits(TINYINT, _BaseTypes$TINYINT);

    function TINYINT(length) {
      var _this;

      _classCallCheck(this, TINYINT);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(TINYINT).call(this, length));
      removeUnsupportedIntegerOptions(_assertThisInitialized(_this));
      return _this;
    }

    return TINYINT;
  }(BaseTypes.TINYINT);

  BaseTypes.TINYINT.types.postgres = ["int2"];

  var SMALLINT =
  /*#__PURE__*/
  function (_BaseTypes$SMALLINT) {
    _inherits(SMALLINT, _BaseTypes$SMALLINT);

    function SMALLINT(length) {
      var _this2;

      _classCallCheck(this, SMALLINT);

      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(SMALLINT).call(this, length));
      removeUnsupportedIntegerOptions(_assertThisInitialized(_this2));
      return _this2;
    }

    return SMALLINT;
  }(BaseTypes.SMALLINT);

  BaseTypes.SMALLINT.types.postgres = ["int2"];

  var INTEGER =
  /*#__PURE__*/
  function (_BaseTypes$INTEGER) {
    _inherits(INTEGER, _BaseTypes$INTEGER);

    function INTEGER(length) {
      var _this3;

      _classCallCheck(this, INTEGER);

      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(INTEGER).call(this, length));
      removeUnsupportedIntegerOptions(_assertThisInitialized(_this3));
      return _this3;
    }

    return INTEGER;
  }(BaseTypes.INTEGER);

  INTEGER.parse = function parse(value) {
    return parseInt(value, 10);
  };

  BaseTypes.INTEGER.types.postgres = ["int4"];

  var BIGINT =
  /*#__PURE__*/
  function (_BaseTypes$BIGINT) {
    _inherits(BIGINT, _BaseTypes$BIGINT);

    function BIGINT(length) {
      var _this4;

      _classCallCheck(this, BIGINT);

      _this4 = _possibleConstructorReturn(this, _getPrototypeOf(BIGINT).call(this, length));
      removeUnsupportedIntegerOptions(_assertThisInitialized(_this4));
      return _this4;
    }

    return BIGINT;
  }(BaseTypes.BIGINT);

  BaseTypes.BIGINT.types.postgres = ["int8"];

  var REAL =
  /*#__PURE__*/
  function (_BaseTypes$REAL) {
    _inherits(REAL, _BaseTypes$REAL);

    function REAL(length) {
      var _this5;

      _classCallCheck(this, REAL);

      _this5 = _possibleConstructorReturn(this, _getPrototypeOf(REAL).call(this, length));
      removeUnsupportedIntegerOptions(_assertThisInitialized(_this5));
      return _this5;
    }

    return REAL;
  }(BaseTypes.REAL);

  BaseTypes.REAL.types.postgres = ["float4"];

  var DOUBLE =
  /*#__PURE__*/
  function (_BaseTypes$DOUBLE) {
    _inherits(DOUBLE, _BaseTypes$DOUBLE);

    function DOUBLE(length) {
      var _this6;

      _classCallCheck(this, DOUBLE);

      _this6 = _possibleConstructorReturn(this, _getPrototypeOf(DOUBLE).call(this, length));
      removeUnsupportedIntegerOptions(_assertThisInitialized(_this6));
      return _this6;
    }

    return DOUBLE;
  }(BaseTypes.DOUBLE);

  BaseTypes.DOUBLE.types.postgres = ["float8"];

  var FLOAT =
  /*#__PURE__*/
  function (_BaseTypes$FLOAT) {
    _inherits(FLOAT, _BaseTypes$FLOAT);

    function FLOAT(length, decimals) {
      var _this7;

      _classCallCheck(this, FLOAT);

      _this7 = _possibleConstructorReturn(this, _getPrototypeOf(FLOAT).call(this, length, decimals));

      if (_this7._decimals) {
        warn("PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.");
        _this7._length = void 0;
        _this7.options.length = void 0;
        _this7._decimals = void 0;
      }

      if (_this7._unsigned) {
        warn("PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.");
        _this7._unsigned = void 0;
      }

      if (_this7._zerofill) {
        warn("PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.");
        _this7._zerofill = void 0;
      }

      return _this7;
    }

    return FLOAT;
  }(BaseTypes.FLOAT);

  delete FLOAT.parse;

  var BLOB =
  /*#__PURE__*/
  function (_BaseTypes$BLOB) {
    _inherits(BLOB, _BaseTypes$BLOB);

    function BLOB() {
      _classCallCheck(this, BLOB);

      return _possibleConstructorReturn(this, _getPrototypeOf(BLOB).apply(this, arguments));
    }

    _createClass(BLOB, [{
      key: "toSql",
      value: function toSql() {
        if (this._length) {
          warn("PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.");
          this._length = void 0;
        }

        return "BYTEA";
      }
    }, {
      key: "_hexify",
      value: function _hexify(hex) {
        return "E'\\\\x".concat(hex, "'");
      }
    }]);

    return BLOB;
  }(BaseTypes.BLOB);

  BaseTypes.BLOB.types.postgres = ["bytea"];

  var GEOMETRY =
  /*#__PURE__*/
  function (_BaseTypes$GEOMETRY) {
    _inherits(GEOMETRY, _BaseTypes$GEOMETRY);

    function GEOMETRY() {
      _classCallCheck(this, GEOMETRY);

      return _possibleConstructorReturn(this, _getPrototypeOf(GEOMETRY).apply(this, arguments));
    }

    _createClass(GEOMETRY, [{
      key: "toSql",
      value: function toSql() {
        var result = this.key;

        if (this.type) {
          result += "(".concat(this.type);

          if (this.srid) {
            result += ",".concat(this.srid);
          }

          result += ")";
        }

        return result;
      }
    }, {
      key: "_stringify",
      value: function _stringify(value, options) {
        return "ST_GeomFromGeoJSON(".concat(options.escape(JSON.stringify(value)), ")");
      }
    }, {
      key: "_bindParam",
      value: function _bindParam(value, options) {
        return "ST_GeomFromGeoJSON(".concat(options.bindParam(value), ")");
      }
    }], [{
      key: "parse",
      value: function parse(value) {
        var b = Buffer.from(value, "hex");
        return wkx.Geometry.parse(b).toGeoJSON({
          shortCrs: true
        });
      }
    }]);

    return GEOMETRY;
  }(BaseTypes.GEOMETRY);

  BaseTypes.GEOMETRY.types.postgres = ["geometry"];

  var GEOGRAPHY =
  /*#__PURE__*/
  function (_BaseTypes$GEOGRAPHY) {
    _inherits(GEOGRAPHY, _BaseTypes$GEOGRAPHY);

    function GEOGRAPHY() {
      _classCallCheck(this, GEOGRAPHY);

      return _possibleConstructorReturn(this, _getPrototypeOf(GEOGRAPHY).apply(this, arguments));
    }

    _createClass(GEOGRAPHY, [{
      key: "toSql",
      value: function toSql() {
        var result = "GEOGRAPHY";

        if (this.type) {
          result += "(".concat(this.type);

          if (this.srid) {
            result += ",".concat(this.srid);
          }

          result += ")";
        }

        return result;
      }
    }, {
      key: "_stringify",
      value: function _stringify(value, options) {
        return "ST_GeomFromGeoJSON(".concat(options.escape(JSON.stringify(value)), ")");
      }
    }, {
      key: "bindParam",
      value: function bindParam(value, options) {
        return "ST_GeomFromGeoJSON(".concat(options.bindParam(value), ")");
      }
    }], [{
      key: "parse",
      value: function parse(value) {
        var b = Buffer.from(value, "hex");
        return wkx.Geometry.parse(b).toGeoJSON({
          shortCrs: true
        });
      }
    }]);

    return GEOGRAPHY;
  }(BaseTypes.GEOGRAPHY);

  BaseTypes.GEOGRAPHY.types.postgres = ["geography"];
  var hstore;

  var HSTORE =
  /*#__PURE__*/
  function (_BaseTypes$HSTORE) {
    _inherits(HSTORE, _BaseTypes$HSTORE);

    function HSTORE() {
      var _this8;

      _classCallCheck(this, HSTORE);

      _this8 = _possibleConstructorReturn(this, _getPrototypeOf(HSTORE).call(this));

      if (!hstore) {
        hstore = require("./hstore");
      }

      return _this8;
    }

    _createClass(HSTORE, [{
      key: "_value",
      value: function _value(value) {
        if (!hstore) {
          hstore = require("./hstore");
        }

        return hstore.stringify(value);
      }
    }, {
      key: "_stringify",
      value: function _stringify(value) {
        return "'".concat(this._value(value), "'");
      }
    }, {
      key: "_bindParam",
      value: function _bindParam(value, options) {
        return options.bindParam(this._value(value));
      }
    }], [{
      key: "parse",
      value: function parse(value) {
        if (!hstore) {
          hstore = require("./hstore");
        }

        return hstore.parse(value);
      }
    }]);

    return HSTORE;
  }(BaseTypes.HSTORE);

  HSTORE.prototype.escape = false;
  BaseTypes.HSTORE.types.postgres = ["hstore"];

  var RANGE =
  /*#__PURE__*/
  function (_BaseTypes$RANGE) {
    _inherits(RANGE, _BaseTypes$RANGE);

    function RANGE() {
      _classCallCheck(this, RANGE);

      return _possibleConstructorReturn(this, _getPrototypeOf(RANGE).apply(this, arguments));
    }

    _createClass(RANGE, [{
      key: "_value",
      value: function _value(values, options) {
        var _this9 = this;

        if (!Array.isArray(values)) {
          return this.options.subtype.stringify(values, options);
        }

        var valueInclusivity = [true, false];
        var valuesStringified = values.map(function (value, index) {
          if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, "value")) {
            if (Object.prototype.hasOwnProperty.call(value, "inclusive")) {
              valueInclusivity[index] = value.inclusive;
            }

            value = value.value;
          }

          if (value === null || value === -Infinity || value === Infinity) {
            return value;
          }

          if (_this9.options.subtype.stringify) {
            return _this9.options.subtype.stringify(value, options);
          }

          return options.escape(value);
        });
        valuesStringified.inclusive = valueInclusivity;
        return range.stringify(valuesStringified);
      }
    }, {
      key: "_stringify",
      value: function _stringify(values, options) {
        var value = this._value(values, options);

        if (!Array.isArray(values)) {
          return "'".concat(value, "'::").concat(this.toCastType());
        }

        return "'".concat(value, "'");
      }
    }, {
      key: "_bindParam",
      value: function _bindParam(values, options) {
        var value = this._value(values, options);

        if (!Array.isArray(values)) {
          return "".concat(options.bindParam(value), "::").concat(this.toCastType());
        }

        return options.bindParam(value);
      }
    }, {
      key: "toSql",
      value: function toSql() {
        return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];
      }
    }, {
      key: "toCastType",
      value: function toCastType() {
        return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];
      }
    }], [{
      key: "parse",
      value: function parse(value) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          parser: function parser(val) {
            return val;
          }
        };
        return range.parse(value, options.parser);
      }
    }]);

    return RANGE;
  }(BaseTypes.RANGE);

  var range = require("./range");

  RANGE.prototype.escape = false;
  BaseTypes.RANGE.types.postgres = {
    subtypes: {
      integer: "int4range",
      decimal: "numrange",
      date: "tstzrange",
      dateonly: "daterange",
      bigint: "int8range"
    },
    castTypes: {
      integer: "int4",
      decimal: "numeric",
      date: "timestamptz",
      dateonly: "date",
      bigint: "int8"
    }
  };
  BaseTypes.ARRAY.prototype.escape = false;

  BaseTypes.ARRAY.prototype._value = function _value(values, options) {
    var _this10 = this;

    return values.map(function (value) {
      if (options && options.bindParam && _this10.type && _this10.type._value) {
        return _this10.type._value(value, options);
      }

      if (_this10.type && _this10.type.stringify) {
        value = _this10.type.stringify(value, options);

        if (_this10.type.escape === false) {
          return value;
        }
      }

      return options.escape(value);
    }, this);
  };

  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {
    var str = "ARRAY[".concat(this._value(values, options).join(","), "]");

    if (this.type) {
      var Utils = require("../../utils");

      var castKey = this.toSql();

      if (this.type instanceof BaseTypes.ENUM) {
        var table = options.field.Model.getTableName();
        var useSchema = table.schema !== void 0;
        var schemaWithDelimiter = useSchema ? "".concat(Utils.addTicks(table.schema, '"')).concat(table.delimiter) : "";
        castKey = "".concat(Utils.addTicks(Utils.generateEnumName(useSchema ? table.tableName : table, options.field.field), '"'), "[]");
        str += "::".concat(schemaWithDelimiter).concat(castKey);
      } else {
        str += "::".concat(castKey);
      }
    }

    return str;
  };

  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {
    return options.bindParam(this._value(values, options));
  };

  var ENUM =
  /*#__PURE__*/
  function (_BaseTypes$ENUM) {
    _inherits(ENUM, _BaseTypes$ENUM);

    function ENUM() {
      _classCallCheck(this, ENUM);

      return _possibleConstructorReturn(this, _getPrototypeOf(ENUM).apply(this, arguments));
    }

    _createClass(ENUM, null, [{
      key: "parse",
      value: function parse(value) {
        return value;
      }
    }]);

    return ENUM;
  }(BaseTypes.ENUM);

  BaseTypes.ENUM.types.postgres = [null];
  return {
    DECIMAL: DECIMAL,
    BLOB: BLOB,
    STRING: STRING,
    CHAR: CHAR,
    TEXT: TEXT,
    CITEXT: CITEXT,
    TINYINT: TINYINT,
    SMALLINT: SMALLINT,
    INTEGER: INTEGER,
    BIGINT: BIGINT,
    BOOLEAN: BOOLEAN,
    DATE: DATE,
    DATEONLY: DATEONLY,
    REAL: REAL,
    "DOUBLE PRECISION": DOUBLE,
    FLOAT: FLOAT,
    GEOMETRY: GEOMETRY,
    GEOGRAPHY: GEOGRAPHY,
    HSTORE: HSTORE,
    RANGE: RANGE,
    ENUM: ENUM
  };
};