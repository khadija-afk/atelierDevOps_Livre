"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pool = void 0;

var Deferred_1 = require("./Deferred");

var AggregateError_1 = require("./AggregateError");

var Pool =
/*#__PURE__*/
function () {
  function Pool(factory) {
    _classCallCheck(this, Pool);

    this.log = false;

    if (!factory.create) {
      throw new Error('create function is required');
    }

    if (!factory.destroy) {
      throw new Error('destroy function is required');
    }

    if (!factory.validate) {
      throw new Error('validate function is required');
    }

    if (typeof factory.min !== 'number' || factory.min < 0 || factory.min !== Math.round(factory.min)) {
      throw new Error('min must be an integer >= 0');
    }

    if (typeof factory.max !== 'number' || factory.max <= 0 || factory.max !== Math.round(factory.max)) {
      throw new Error('max must be an integer > 0');
    }

    if (factory.min > factory.max) {
      throw new Error('max is smaller than min');
    }

    if (factory.maxUses !== undefined && (typeof factory.maxUses !== 'number' || factory.maxUses < 0)) {
      throw new Error('maxUses must be an integer >= 0');
    }

    this.idleTimeoutMillis = factory.idleTimeoutMillis || 30000;
    this.acquireTimeoutMillis = factory.acquireTimeoutMillis || 30000;
    this.reapIntervalMillis = factory.reapIntervalMillis || 1000;
    this.maxUsesPerResource = factory.maxUses || Infinity;
    this.log = factory.log || false;
    this._factory = factory;
    this._count = 0;
    this._draining = false;
    this._pendingAcquires = [];
    this._inUseObjects = [];
    this._availableObjects = [];
    this._removeIdleScheduled = false;
  }

  _createClass(Pool, [{
    key: "_log",
    value: function _log(message, level) {
      if (typeof this.log === 'function') {
        this.log(message, level);
      } else if (this.log) {
        console.log("".concat(level.toUpperCase(), " pool ").concat(this.name || '', " - ").concat(message));
      }
    }
  }, {
    key: "_removeIdle",
    value: function _removeIdle() {
      var toRemove = [];
      var now = Date.now();
      var i;
      var available = this._availableObjects.length;
      var maxRemovable = this.size - this.minSize;
      var timeout;
      this._removeIdleScheduled = false;

      for (i = 0; i < available && maxRemovable > toRemove.length; i++) {
        timeout = this._availableObjects[i].timeout;

        if (now >= timeout) {
          this._log('removeIdle() destroying obj - now:' + now + ' timeout:' + timeout, 'verbose');

          toRemove.push(this._availableObjects[i].resource);
        }
      }

      toRemove.forEach(this.destroy, this);
      available = this._availableObjects.length;

      if (available > 0) {
        this._log('this._availableObjects.length=' + available, 'verbose');

        this._scheduleRemoveIdle();
      } else {
        this._log('removeIdle() all objects removed', 'verbose');
      }
    }
  }, {
    key: "_scheduleRemoveIdle",
    value: function _scheduleRemoveIdle() {
      var _this = this;

      if (!this._removeIdleScheduled) {
        this._removeIdleScheduled = true;
        this._removeIdleTimer = setTimeout(function () {
          _this._removeIdle();
        }, this.reapIntervalMillis);
      }
    }
  }, {
    key: "_dispense",
    value: function _dispense() {
      var wrappedResource = null;
      var waitingCount = this._pendingAcquires.length;

      this._log("dispense() clients=".concat(waitingCount, " available=").concat(this._availableObjects.length), 'info');

      if (waitingCount < 1) {
        return;
      }

      while (this._availableObjects.length > 0) {
        this._log('dispense() - reusing obj', 'verbose');

        wrappedResource = this._availableObjects[this._availableObjects.length - 1];

        if (!this._factory.validate(wrappedResource.resource)) {
          this.destroy(wrappedResource.resource);
          continue;
        }

        this._availableObjects.pop();

        this._addResourceToInUseObjects(wrappedResource.resource, wrappedResource.useCount);

        var deferred = this._pendingAcquires.shift();

        return deferred.resolve(wrappedResource.resource);
      }

      if (this.size < this.maxSize) {
        this._createResource();
      }
    }
  }, {
    key: "_createResource",
    value: function _createResource() {
      var _this2 = this;

      this._count += 1;

      this._log("createResource() - creating obj - count=".concat(this.size, " min=").concat(this.minSize, " max=").concat(this.maxSize), 'verbose');

      this._factory.create().then(function (resource) {
        var deferred = _this2._pendingAcquires.shift();

        if (deferred) {
          _this2._addResourceToInUseObjects(resource, 0);

          deferred.resolve(resource);
        } else {
          _this2._addResourceToAvailableObjects(resource, 0);
        }
      })["catch"](function (error) {
        var deferred = _this2._pendingAcquires.shift();

        _this2._count -= 1;
        if (_this2._count < 0) _this2._count = 0;

        if (deferred) {
          deferred.reject(error);
        }

        process.nextTick(function () {
          _this2._dispense();
        });
      });
    }
  }, {
    key: "_addResourceToAvailableObjects",
    value: function _addResourceToAvailableObjects(resource, useCount) {
      var wrappedResource = {
        resource: resource,
        useCount: useCount,
        timeout: Date.now() + this.idleTimeoutMillis
      };

      this._availableObjects.push(wrappedResource);

      this._dispense();

      this._scheduleRemoveIdle();
    }
  }, {
    key: "_addResourceToInUseObjects",
    value: function _addResourceToInUseObjects(resource, useCount) {
      var wrappedResource = {
        resource: resource,
        useCount: useCount
      };

      this._inUseObjects.push(wrappedResource);
    }
  }, {
    key: "_ensureMinimum",
    value: function _ensureMinimum() {
      var i, diff;

      if (!this._draining && this.size < this.minSize) {
        diff = this.minSize - this.size;

        for (i = 0; i < diff; i++) {
          this._createResource();
        }
      }
    }
  }, {
    key: "acquire",
    value: function acquire() {
      var _this3 = this;

      if (this._draining) {
        return Promise.reject(new Error('pool is draining and cannot accept work'));
      }

      var deferred = new Deferred_1.Deferred();
      deferred.registerTimeout(this.acquireTimeoutMillis, function () {
        _this3._pendingAcquires = _this3._pendingAcquires.filter(function (pending) {
          return pending !== deferred;
        });
      });

      this._pendingAcquires.push(deferred);

      this._dispense();

      return deferred.promise();
    }
  }, {
    key: "release",
    value: function release(resource) {
      if (this._availableObjects.some(function (resourceWithTimeout) {
        return resourceWithTimeout.resource === resource;
      })) {
        this._log('release called twice for the same resource: ' + new Error().stack, 'error');

        return;
      }

      var index = this._inUseObjects.findIndex(function (wrappedResource) {
        return wrappedResource.resource === resource;
      });

      if (index < 0) {
        this._log('attempt to release an invalid resource: ' + new Error().stack, 'error');

        return;
      }

      var wrappedResource = this._inUseObjects[index];
      wrappedResource.useCount += 1;

      if (wrappedResource.useCount >= this.maxUsesPerResource) {
        this._log('release() destroying obj - useCount:' + wrappedResource.useCount + ' maxUsesPerResource:' + this.maxUsesPerResource, 'verbose');

        this.destroy(wrappedResource.resource);

        this._dispense();
      } else {
        this._inUseObjects.splice(index, 1);

        this._addResourceToAvailableObjects(wrappedResource.resource, wrappedResource.useCount);
      }
    }
  }, {
    key: "destroy",
    value: function destroy(resource) {
      var _this4 = this;

      var available, using;
      return regeneratorRuntime.async(function destroy$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              available = this._availableObjects.length;
              using = this._inUseObjects.length;
              this._availableObjects = this._availableObjects.filter(function (object) {
                return object.resource !== resource;
              });
              this._inUseObjects = this._inUseObjects.filter(function (object) {
                return object.resource !== resource;
              });

              if (!(available === this._availableObjects.length && using === this._inUseObjects.length)) {
                _context.next = 7;
                break;
              }

              this._ensureMinimum();

              return _context.abrupt("return");

            case 7:
              this._count -= 1;
              if (this._count < 0) this._count = 0;
              _context.prev = 9;
              _context.next = 12;
              return regeneratorRuntime.awrap(this._factory.destroy(resource));

            case 12:
              _context.prev = 12;

              this._ensureMinimum();

              if (!this._draining) {
                process.nextTick(function () {
                  _this4._dispense();
                });
              }

              return _context.finish(12);

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[9,, 12, 16]]);
    }
  }, {
    key: "drain",
    value: function drain() {
      var _this5 = this;

      this._log('draining', 'info');

      this._draining = true;

      var check = function check(callback) {
        if (_this5._pendingAcquires.length > 0) {
          _this5._dispense();

          setTimeout(function () {
            check(callback);
          }, 100);
          return;
        }

        if (_this5._availableObjects.length !== _this5._count) {
          setTimeout(function () {
            check(callback);
          }, 100);
          return;
        }

        callback();
      };

      return new Promise(function (resolve) {
        return check(resolve);
      });
    }
  }, {
    key: "destroyAllNow",
    value: function destroyAllNow() {
      var resources, errors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, resource;

      return regeneratorRuntime.async(function destroyAllNow$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              this._log('force destroying all objects', 'info');

              this._removeIdleScheduled = false;
              clearTimeout(this._removeIdleTimer);
              resources = this._availableObjects.map(function (resource) {
                return resource.resource;
              });
              errors = [];
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context2.prev = 8;
              _iterator = resources[Symbol.iterator]();

            case 10:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context2.next = 24;
                break;
              }

              resource = _step.value;
              _context2.prev = 12;
              _context2.next = 15;
              return regeneratorRuntime.awrap(this.destroy(resource));

            case 15:
              _context2.next = 21;
              break;

            case 17:
              _context2.prev = 17;
              _context2.t0 = _context2["catch"](12);

              this._log('Error destroying resource: ' + _context2.t0.stack, 'error');

              errors.push(_context2.t0);

            case 21:
              _iteratorNormalCompletion = true;
              _context2.next = 10;
              break;

            case 24:
              _context2.next = 30;
              break;

            case 26:
              _context2.prev = 26;
              _context2.t1 = _context2["catch"](8);
              _didIteratorError = true;
              _iteratorError = _context2.t1;

            case 30:
              _context2.prev = 30;
              _context2.prev = 31;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 33:
              _context2.prev = 33;

              if (!_didIteratorError) {
                _context2.next = 36;
                break;
              }

              throw _iteratorError;

            case 36:
              return _context2.finish(33);

            case 37:
              return _context2.finish(30);

            case 38:
              if (!(errors.length > 0)) {
                _context2.next = 40;
                break;
              }

              throw new AggregateError_1.AggregateError(errors);

            case 40:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[8, 26, 30, 38], [12, 17], [31,, 33, 37]]);
    }
  }, {
    key: "size",
    get: function get() {
      return this._count;
    }
  }, {
    key: "name",
    get: function get() {
      return this._factory.name;
    }
  }, {
    key: "available",
    get: function get() {
      return this._availableObjects.length;
    }
  }, {
    key: "using",
    get: function get() {
      return this._inUseObjects.length;
    }
  }, {
    key: "waiting",
    get: function get() {
      return this._pendingAcquires.length;
    }
  }, {
    key: "maxSize",
    get: function get() {
      return this._factory.max;
    }
  }, {
    key: "minSize",
    get: function get() {
      return this._factory.min;
    }
  }]);

  return Pool;
}();

exports.Pool = Pool;