// This file was modified by Oracle on June 1, 2021.
// A comment describing some changes in the strict default SQL mode regarding
// non-standard dates was introduced.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ErrorCodeToName = require('../constants/errors.js');

var NativeBuffer = require('buffer').Buffer;

var Long = require('long');

var StringParser = require('../parsers/string.js');

var INVALID_DATE = new Date(NaN); // this is nearly duplicate of previous function so generated code is not slower
// due to "if (dateStrings)" branching

var pad = '000000000000';

function leftPad(num, value) {
  var s = value.toString(); // if we don't need to pad

  if (s.length >= num) {
    return s;
  }

  return (pad + s).slice(-num);
} // The whole reason parse* function below exist
// is because String creation is relatively expensive (at least with V8), and if we have
// a buffer with "12345" content ideally we would like to bypass intermediate
// "12345" string creation and directly build 12345 number out of
// <Buffer 31 32 33 34 35> data.
// In my benchmarks the difference is ~25M 8-digit numbers per second vs
// 4.5 M using Number(packet.readLengthCodedString())
// not used when size is close to max precision as series of *10 accumulate error
// and approximate result mihgt be diffreent from (approximate as well) Number(bigNumStringValue))
// In the futire node version if speed difference is smaller parse* functions might be removed
// don't consider them as Packet public API


var minus = '-'.charCodeAt(0);
var plus = '+'.charCodeAt(0); // TODO: handle E notation

var dot = '.'.charCodeAt(0);
var exponent = 'e'.charCodeAt(0);
var exponentCapital = 'E'.charCodeAt(0);

var Packet =
/*#__PURE__*/
function () {
  function Packet(id, buffer, start, end) {
    _classCallCheck(this, Packet);

    // hot path, enable checks when testing only
    // if (!Buffer.isBuffer(buffer) || typeof start == 'undefined' || typeof end == 'undefined')
    //  throw new Error('invalid packet');
    this.sequenceId = id;
    this.numPackets = 1;
    this.buffer = buffer;
    this.start = start;
    this.offset = start + 4;
    this.end = end;
  } // ==============================
  // readers
  // ==============================


  _createClass(Packet, [{
    key: "reset",
    value: function reset() {
      this.offset = this.start + 4;
    }
  }, {
    key: "length",
    value: function length() {
      return this.end - this.start;
    }
  }, {
    key: "slice",
    value: function slice() {
      return this.buffer.slice(this.start, this.end);
    }
  }, {
    key: "dump",
    value: function dump() {
      // eslint-disable-next-line no-console
      console.log([this.buffer.asciiSlice(this.start, this.end)], this.buffer.slice(this.start, this.end), this.length(), this.sequenceId);
    }
  }, {
    key: "haveMoreData",
    value: function haveMoreData() {
      return this.end > this.offset;
    }
  }, {
    key: "skip",
    value: function skip(num) {
      this.offset += num;
    }
  }, {
    key: "readInt8",
    value: function readInt8() {
      return this.buffer[this.offset++];
    }
  }, {
    key: "readInt16",
    value: function readInt16() {
      this.offset += 2;
      return this.buffer.readUInt16LE(this.offset - 2);
    }
  }, {
    key: "readInt24",
    value: function readInt24() {
      return this.readInt16() + (this.readInt8() << 16);
    }
  }, {
    key: "readInt32",
    value: function readInt32() {
      this.offset += 4;
      return this.buffer.readUInt32LE(this.offset - 4);
    }
  }, {
    key: "readSInt8",
    value: function readSInt8() {
      return this.buffer.readInt8(this.offset++);
    }
  }, {
    key: "readSInt16",
    value: function readSInt16() {
      this.offset += 2;
      return this.buffer.readInt16LE(this.offset - 2);
    }
  }, {
    key: "readSInt32",
    value: function readSInt32() {
      this.offset += 4;
      return this.buffer.readInt32LE(this.offset - 4);
    }
  }, {
    key: "readInt64JSNumber",
    value: function readInt64JSNumber() {
      var word0 = this.readInt32();
      var word1 = this.readInt32();
      var l = new Long(word0, word1, true);
      return l.toNumber();
    }
  }, {
    key: "readSInt64JSNumber",
    value: function readSInt64JSNumber() {
      var word0 = this.readInt32();
      var word1 = this.readInt32();

      if (!(word1 & 0x80000000)) {
        return word0 + 0x100000000 * word1;
      }

      var l = new Long(word0, word1, false);
      return l.toNumber();
    }
  }, {
    key: "readInt64String",
    value: function readInt64String() {
      var word0 = this.readInt32();
      var word1 = this.readInt32();
      var res = new Long(word0, word1, true);
      return res.toString();
    }
  }, {
    key: "readSInt64String",
    value: function readSInt64String() {
      var word0 = this.readInt32();
      var word1 = this.readInt32();
      var res = new Long(word0, word1, false);
      return res.toString();
    }
  }, {
    key: "readInt64",
    value: function readInt64() {
      var word0 = this.readInt32();
      var word1 = this.readInt32();
      var res = new Long(word0, word1, true);
      var resNumber = res.toNumber();
      var resString = res.toString();
      res = resNumber.toString() === resString ? resNumber : resString;
      return res;
    }
  }, {
    key: "readSInt64",
    value: function readSInt64() {
      var word0 = this.readInt32();
      var word1 = this.readInt32();
      var res = new Long(word0, word1, false);
      var resNumber = res.toNumber();
      var resString = res.toString();
      res = resNumber.toString() === resString ? resNumber : resString;
      return res;
    }
  }, {
    key: "isEOF",
    value: function isEOF() {
      return this.buffer[this.offset] === 0xfe && this.length() < 13;
    }
  }, {
    key: "eofStatusFlags",
    value: function eofStatusFlags() {
      return this.buffer.readInt16LE(this.offset + 3);
    }
  }, {
    key: "eofWarningCount",
    value: function eofWarningCount() {
      return this.buffer.readInt16LE(this.offset + 1);
    }
  }, {
    key: "readLengthCodedNumber",
    value: function readLengthCodedNumber(bigNumberStrings, signed) {
      var byte1 = this.buffer[this.offset++];

      if (byte1 < 251) {
        return byte1;
      }

      return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);
    }
  }, {
    key: "readLengthCodedNumberSigned",
    value: function readLengthCodedNumberSigned(bigNumberStrings) {
      return this.readLengthCodedNumber(bigNumberStrings, true);
    }
  }, {
    key: "readLengthCodedNumberExt",
    value: function readLengthCodedNumberExt(tag, bigNumberStrings, signed) {
      var word0, word1;
      var res;

      if (tag === 0xfb) {
        return null;
      }

      if (tag === 0xfc) {
        return this.readInt8() + (this.readInt8() << 8);
      }

      if (tag === 0xfd) {
        return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);
      }

      if (tag === 0xfe) {
        // TODO: check version
        // Up to MySQL 3.22, 0xfe was followed by a 4-byte integer.
        word0 = this.readInt32();
        word1 = this.readInt32();

        if (word1 === 0) {
          return word0; // don't convert to float if possible
        }

        if (word1 < 2097152) {
          // max exact float point int, 2^52 / 2^32
          return word1 * 0x100000000 + word0;
        }

        res = new Long(word0, word1, !signed); // Long need unsigned

        var resNumber = res.toNumber();
        var resString = res.toString();
        res = resNumber.toString() === resString ? resNumber : resString;
        return bigNumberStrings ? resString : res;
      } // eslint-disable-next-line no-console


      console.trace();
      throw new Error("Should not reach here: ".concat(tag));
    }
  }, {
    key: "readFloat",
    value: function readFloat() {
      var res = this.buffer.readFloatLE(this.offset);
      this.offset += 4;
      return res;
    }
  }, {
    key: "readDouble",
    value: function readDouble() {
      var res = this.buffer.readDoubleLE(this.offset);
      this.offset += 8;
      return res;
    }
  }, {
    key: "readBuffer",
    value: function readBuffer(len) {
      if (typeof len === 'undefined') {
        len = this.end - this.offset;
      }

      this.offset += len;
      return this.buffer.slice(this.offset - len, this.offset);
    } // DATE, DATETIME and TIMESTAMP

  }, {
    key: "readDateTime",
    value: function readDateTime(timezone) {
      if (!timezone || timezone === 'Z' || timezone === 'local') {
        var length = this.readInt8();

        if (length === 0xfb) {
          return null;
        }

        var y = 0;
        var m = 0;
        var d = 0;
        var H = 0;
        var M = 0;
        var S = 0;
        var ms = 0;

        if (length > 3) {
          y = this.readInt16();
          m = this.readInt8();
          d = this.readInt8();
        }

        if (length > 6) {
          H = this.readInt8();
          M = this.readInt8();
          S = this.readInt8();
        }

        if (length > 10) {
          ms = this.readInt32() / 1000;
        } // NO_ZERO_DATE mode and NO_ZERO_IN_DATE mode are part of the strict
        // default SQL mode used by MySQL 8.0. This means that non-standard
        // dates like '0000-00-00' become NULL. For older versions and other
        // possible MySQL flavours we still need to account for the
        // non-standard behaviour.


        if (y + m + d + H + M + S + ms === 0) {
          return INVALID_DATE;
        }

        if (timezone === 'Z') {
          return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));
        }

        return new Date(y, m - 1, d, H, M, S, ms);
      }

      var str = this.readDateTimeString(6, 'T');

      if (str.length === 10) {
        str += 'T00:00:00';
      }

      return new Date(str + timezone);
    }
  }, {
    key: "readDateTimeString",
    value: function readDateTimeString(decimals, timeSep) {
      var length = this.readInt8();
      var y = 0;
      var m = 0;
      var d = 0;
      var H = 0;
      var M = 0;
      var S = 0;
      var ms = 0;
      var str;

      if (length > 3) {
        y = this.readInt16();
        m = this.readInt8();
        d = this.readInt8();
        str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join('-');
      }

      if (length > 6) {
        H = this.readInt8();
        M = this.readInt8();
        S = this.readInt8();
        str += "".concat(timeSep || ' ').concat([leftPad(2, H), leftPad(2, M), leftPad(2, S)].join(':'));
      }

      if (length > 10) {
        ms = this.readInt32();
        str += '.';

        if (decimals) {
          ms = leftPad(6, ms);

          if (ms.length > decimals) {
            ms = ms.substring(0, decimals); // rounding is done at the MySQL side, only 0 are here
          }
        }

        str += ms;
      }

      return str;
    } // TIME - value as a string, Can be negative

  }, {
    key: "readTimeString",
    value: function readTimeString(convertTtoMs) {
      var length = this.readInt8();

      if (length === 0) {
        return '00:00:00';
      }

      var sign = this.readInt8() ? -1 : 1; // 'isNegative' flag byte

      var d = 0;
      var H = 0;
      var M = 0;
      var S = 0;
      var ms = 0;

      if (length > 6) {
        d = this.readInt32();
        H = this.readInt8();
        M = this.readInt8();
        S = this.readInt8();
      }

      if (length > 10) {
        ms = this.readInt32();
      }

      if (convertTtoMs) {
        H += d * 24;
        M += H * 60;
        S += M * 60;
        ms += S * 1000;
        ms *= sign;
        return ms;
      } // Format follows mySQL TIME format ([-][h]hh:mm:ss[.u[u[u[u[u[u]]]]]])
      // For positive times below 24 hours, this makes it equal to ISO 8601 times


      return (sign === -1 ? '-' : '') + [leftPad(2, d * 24 + H), leftPad(2, M), leftPad(2, S)].join(':') + (ms ? ".".concat(ms).replace(/0+$/, '') : '');
    }
  }, {
    key: "readLengthCodedString",
    value: function readLengthCodedString(encoding) {
      var len = this.readLengthCodedNumber(); // TODO: check manually first byte here to avoid polymorphic return type?

      if (len === null) {
        return null;
      }

      this.offset += len; // TODO: Use characterSetCode to get proper encoding
      // https://github.com/sidorares/node-mysql2/pull/374

      return StringParser.decode(this.buffer, encoding, this.offset - len, this.offset);
    }
  }, {
    key: "readLengthCodedBuffer",
    value: function readLengthCodedBuffer() {
      var len = this.readLengthCodedNumber();

      if (len === null) {
        return null;
      }

      return this.readBuffer(len);
    }
  }, {
    key: "readNullTerminatedString",
    value: function readNullTerminatedString(encoding) {
      var start = this.offset;
      var end = this.offset;

      while (this.buffer[end]) {
        end = end + 1; // TODO: handle OOB check
      }

      this.offset = end + 1;
      return StringParser.decode(this.buffer, encoding, start, end);
    } // TODO reuse?

  }, {
    key: "readString",
    value: function readString(len, encoding) {
      if (typeof len === 'string' && typeof encoding === 'undefined') {
        encoding = len;
        len = undefined;
      }

      if (typeof len === 'undefined') {
        len = this.end - this.offset;
      }

      this.offset += len;
      return StringParser.decode(this.buffer, encoding, this.offset - len, this.offset);
    }
  }, {
    key: "parseInt",
    value: function (_parseInt) {
      function parseInt(_x, _x2) {
        return _parseInt.apply(this, arguments);
      }

      parseInt.toString = function () {
        return _parseInt.toString();
      };

      return parseInt;
    }(function (len, supportBigNumbers) {
      if (len === null) {
        return null;
      }

      if (len >= 14 && !supportBigNumbers) {
        var s = this.buffer.toString('ascii', this.offset, this.offset + len);
        this.offset += len;
        return Number(s);
      }

      var result = 0;
      var start = this.offset;
      var end = this.offset + len;
      var sign = 1;

      if (len === 0) {
        return 0; // TODO: assert? exception?
      }

      if (this.buffer[this.offset] === minus) {
        this.offset++;
        sign = -1;
      } // max precise int is 9007199254740992


      var str;
      var numDigits = end - this.offset;

      if (supportBigNumbers) {
        if (numDigits >= 15) {
          str = this.readString(end - this.offset, 'binary');
          result = parseInt(str, 10);

          if (result.toString() === str) {
            return sign * result;
          }

          return sign === -1 ? "-".concat(str) : str;
        }

        if (numDigits > 16) {
          str = this.readString(end - this.offset);
          return sign === -1 ? "-".concat(str) : str;
        }
      }

      if (this.buffer[this.offset] === plus) {
        this.offset++; // just ignore
      }

      while (this.offset < end) {
        result *= 10;
        result += this.buffer[this.offset] - 48;
        this.offset++;
      }

      var num = result * sign;

      if (!supportBigNumbers) {
        return num;
      }

      str = this.buffer.toString('ascii', start, end);

      if (num.toString() === str) {
        return num;
      }

      return str;
    }) // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER
    // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be
    // different from what you would get from Number(inputNumberAsString)
    // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString

  }, {
    key: "parseIntNoBigCheck",
    value: function parseIntNoBigCheck(len) {
      if (len === null) {
        return null;
      }

      var result = 0;
      var end = this.offset + len;
      var sign = 1;

      if (len === 0) {
        return 0; // TODO: assert? exception?
      }

      if (this.buffer[this.offset] === minus) {
        this.offset++;
        sign = -1;
      }

      if (this.buffer[this.offset] === plus) {
        this.offset++; // just ignore
      }

      while (this.offset < end) {
        result *= 10;
        result += this.buffer[this.offset] - 48;
        this.offset++;
      }

      return result * sign;
    } // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js

  }, {
    key: "parseGeometryValue",
    value: function parseGeometryValue() {
      var buffer = this.readLengthCodedBuffer();
      var offset = 4;

      if (buffer === null || !buffer.length) {
        return null;
      }

      function parseGeometry() {
        var x, y, i, j, numPoints, line;
        var result = null;
        var byteOrder = buffer.readUInt8(offset);
        offset += 1;
        var wkbType = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
        offset += 4;

        switch (wkbType) {
          case 1:
            // WKBPoint
            x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
            offset += 8;
            y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
            offset += 8;
            result = {
              x: x,
              y: y
            };
            break;

          case 2:
            // WKBLineString
            numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
            offset += 4;
            result = [];

            for (i = numPoints; i > 0; i--) {
              x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
              offset += 8;
              y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
              offset += 8;
              result.push({
                x: x,
                y: y
              });
            }

            break;

          case 3:
            // WKBPolygon
            // eslint-disable-next-line no-case-declarations
            var numRings = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
            offset += 4;
            result = [];

            for (i = numRings; i > 0; i--) {
              numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
              offset += 4;
              line = [];

              for (j = numPoints; j > 0; j--) {
                x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
                offset += 8;
                y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);
                offset += 8;
                line.push({
                  x: x,
                  y: y
                });
              }

              result.push(line);
            }

            break;

          case 4: // WKBMultiPoint

          case 5: // WKBMultiLineString

          case 6: // WKBMultiPolygon

          case 7:
            // WKBGeometryCollection
            // eslint-disable-next-line no-case-declarations
            var num = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);
            offset += 4;
            result = [];

            for (i = num; i > 0; i--) {
              result.push(parseGeometry());
            }

            break;
        }

        return result;
      }

      return parseGeometry();
    }
  }, {
    key: "parseDate",
    value: function parseDate(timezone) {
      var strLen = this.readLengthCodedNumber();

      if (strLen === null) {
        return null;
      }

      if (strLen !== 10) {
        // we expect only YYYY-MM-DD here.
        // if for some reason it's not the case return invalid date
        return new Date(NaN);
      }

      var y = this.parseInt(4);
      this.offset++; // -

      var m = this.parseInt(2);
      this.offset++; // -

      var d = this.parseInt(2);

      if (!timezone || timezone === 'local') {
        return new Date(y, m - 1, d);
      }

      if (timezone === 'Z') {
        return new Date(Date.UTC(y, m - 1, d));
      }

      return new Date("".concat(leftPad(4, y), "-").concat(leftPad(2, m), "-").concat(leftPad(2, d), "T00:00:00").concat(timezone));
    }
  }, {
    key: "parseDateTime",
    value: function parseDateTime(timezone) {
      var str = this.readLengthCodedString('binary');

      if (str === null) {
        return null;
      }

      if (!timezone || timezone === 'local') {
        return new Date(str);
      }

      return new Date("".concat(str).concat(timezone));
    }
  }, {
    key: "parseFloat",
    value: function parseFloat(len) {
      if (len === null) {
        return null;
      }

      var result = 0;
      var end = this.offset + len;
      var factor = 1;
      var pastDot = false;
      var charCode = 0;

      if (len === 0) {
        return 0; // TODO: assert? exception?
      }

      if (this.buffer[this.offset] === minus) {
        this.offset++;
        factor = -1;
      }

      if (this.buffer[this.offset] === plus) {
        this.offset++; // just ignore
      }

      while (this.offset < end) {
        charCode = this.buffer[this.offset];

        if (charCode === dot) {
          pastDot = true;
          this.offset++;
        } else if (charCode === exponent || charCode === exponentCapital) {
          this.offset++;
          var exponentValue = this.parseInt(end - this.offset);
          return result / factor * Math.pow(10, exponentValue);
        } else {
          result *= 10;
          result += this.buffer[this.offset] - 48;
          this.offset++;

          if (pastDot) {
            factor = factor * 10;
          }
        }
      }

      return result / factor;
    }
  }, {
    key: "parseLengthCodedIntNoBigCheck",
    value: function parseLengthCodedIntNoBigCheck() {
      return this.parseIntNoBigCheck(this.readLengthCodedNumber());
    }
  }, {
    key: "parseLengthCodedInt",
    value: function parseLengthCodedInt(supportBigNumbers) {
      return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);
    }
  }, {
    key: "parseLengthCodedIntString",
    value: function parseLengthCodedIntString() {
      return this.readLengthCodedString('binary');
    }
  }, {
    key: "parseLengthCodedFloat",
    value: function parseLengthCodedFloat() {
      return this.parseFloat(this.readLengthCodedNumber());
    }
  }, {
    key: "peekByte",
    value: function peekByte() {
      return this.buffer[this.offset];
    } // OxFE is often used as "Alt" flag - not ok, not error.
    // For example, it's first byte of AuthSwitchRequest

  }, {
    key: "isAlt",
    value: function isAlt() {
      return this.peekByte() === 0xfe;
    }
  }, {
    key: "isError",
    value: function isError() {
      return this.peekByte() === 0xff;
    }
  }, {
    key: "asError",
    value: function asError(encoding) {
      this.reset();
      this.readInt8(); // fieldCount

      var errorCode = this.readInt16();
      var sqlState = '';

      if (this.buffer[this.offset] === 0x23) {
        this.skip(1);
        sqlState = this.readBuffer(5).toString();
      }

      var message = this.readString(undefined, encoding);
      var err = new Error(message);
      err.code = ErrorCodeToName[errorCode];
      err.errno = errorCode;
      err.sqlState = sqlState;
      err.sqlMessage = message;
      return err;
    }
  }, {
    key: "writeInt32",
    value: function writeInt32(n) {
      this.buffer.writeUInt32LE(n, this.offset);
      this.offset += 4;
    }
  }, {
    key: "writeInt24",
    value: function writeInt24(n) {
      this.writeInt8(n & 0xff);
      this.writeInt16(n >> 8);
    }
  }, {
    key: "writeInt16",
    value: function writeInt16(n) {
      this.buffer.writeUInt16LE(n, this.offset);
      this.offset += 2;
    }
  }, {
    key: "writeInt8",
    value: function writeInt8(n) {
      this.buffer.writeUInt8(n, this.offset);
      this.offset++;
    }
  }, {
    key: "writeDouble",
    value: function writeDouble(n) {
      this.buffer.writeDoubleLE(n, this.offset);
      this.offset += 8;
    }
  }, {
    key: "writeBuffer",
    value: function writeBuffer(b) {
      b.copy(this.buffer, this.offset);
      this.offset += b.length;
    }
  }, {
    key: "writeNull",
    value: function writeNull() {
      this.buffer[this.offset] = 0xfb;
      this.offset++;
    } // TODO: refactor following three?

  }, {
    key: "writeNullTerminatedString",
    value: function writeNullTerminatedString(s, encoding) {
      var buf = StringParser.encode(s, encoding);
      this.buffer.length && buf.copy(this.buffer, this.offset);
      this.offset += buf.length;
      this.writeInt8(0);
    }
  }, {
    key: "writeString",
    value: function writeString(s, encoding) {
      if (s === null) {
        this.writeInt8(0xfb);
        return;
      }

      if (s.length === 0) {
        return;
      } // const bytes = Buffer.byteLength(s, 'utf8');
      // this.buffer.write(s, this.offset, bytes, 'utf8');
      // this.offset += bytes;


      var buf = StringParser.encode(s, encoding);
      this.buffer.length && buf.copy(this.buffer, this.offset);
      this.offset += buf.length;
    }
  }, {
    key: "writeLengthCodedString",
    value: function writeLengthCodedString(s, encoding) {
      var buf = StringParser.encode(s, encoding);
      this.writeLengthCodedNumber(buf.length);
      this.buffer.length && buf.copy(this.buffer, this.offset);
      this.offset += buf.length;
    }
  }, {
    key: "writeLengthCodedBuffer",
    value: function writeLengthCodedBuffer(b) {
      this.writeLengthCodedNumber(b.length);
      b.copy(this.buffer, this.offset);
      this.offset += b.length;
    }
  }, {
    key: "writeLengthCodedNumber",
    value: function writeLengthCodedNumber(n) {
      if (n < 0xfb) {
        return this.writeInt8(n);
      }

      if (n < 0xffff) {
        this.writeInt8(0xfc);
        return this.writeInt16(n);
      }

      if (n < 0xffffff) {
        this.writeInt8(0xfd);
        return this.writeInt24(n);
      }

      if (n === null) {
        return this.writeInt8(0xfb);
      } // TODO: check that n is out of int precision


      this.writeInt8(0xfe);
      this.buffer.writeUInt32LE(n, this.offset);
      this.offset += 4;
      this.buffer.writeUInt32LE(n >> 32, this.offset);
      this.offset += 4;
      return this.offset;
    }
  }, {
    key: "writeDate",
    value: function writeDate(d, timezone) {
      this.buffer.writeUInt8(11, this.offset);

      if (!timezone || timezone === 'local') {
        this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);
        this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);
        this.buffer.writeUInt8(d.getDate(), this.offset + 4);
        this.buffer.writeUInt8(d.getHours(), this.offset + 5);
        this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);
        this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);
        this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);
      } else {
        if (timezone !== 'Z') {
          var offset = (timezone[0] === '-' ? -1 : 1) * (parseInt(timezone.substring(1, 3), 10) * 60 + parseInt(timezone.substring(4), 10));

          if (offset !== 0) {
            d = new Date(d.getTime() + 60000 * offset);
          }
        }

        this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);
        this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);
        this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);
        this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);
        this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);
        this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);
        this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);
      }

      this.offset += 12;
    }
  }, {
    key: "writeHeader",
    value: function writeHeader(sequenceId) {
      var offset = this.offset;
      this.offset = 0;
      this.writeInt24(this.buffer.length - 4);
      this.writeInt8(sequenceId);
      this.offset = offset;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Packet(this.sequenceId, this.buffer, this.start, this.end);
    }
  }, {
    key: "type",
    value: function type() {
      if (this.isEOF()) {
        return 'EOF';
      }

      if (this.isError()) {
        return 'Error';
      }

      if (this.buffer[this.offset] === 0) {
        return 'maybeOK'; // could be other packet types as well
      }

      return '';
    }
  }], [{
    key: "lengthCodedNumberLength",
    value: function lengthCodedNumberLength(n) {
      if (n < 0xfb) {
        return 1;
      }

      if (n < 0xffff) {
        return 3;
      }

      if (n < 0xffffff) {
        return 5;
      }

      return 9;
    }
  }, {
    key: "lengthCodedStringLength",
    value: function lengthCodedStringLength(str, encoding) {
      var buf = StringParser.encode(str, encoding);
      var slen = buf.length;
      return Packet.lengthCodedNumberLength(slen) + slen;
    }
  }, {
    key: "MockBuffer",
    value: function MockBuffer() {
      var noop = function noop() {};

      var res = Buffer.alloc(0);

      for (var op in NativeBuffer.prototype) {
        if (typeof res[op] === 'function') {
          res[op] = noop;
        }
      }

      return res;
    }
  }]);

  return Packet;
}();

module.exports = Packet;