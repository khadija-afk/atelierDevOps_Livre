"use strict";

function _wrapRegExp(re, groups) { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, undefined, groups); }; var _RegExp = _wrapNativeSuper(RegExp); var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = _RegExp.call(this, re, flags); _groups.set(_this, groups || _groups.get(re)); return _this; } _inherits(BabelRegExp, _RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === "string") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } else if (typeof substitution === "function") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = []; args.push.apply(args, arguments); if (_typeof(args[args.length - 1]) !== "object") { args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;

var __markAsModule = function __markAsModule(target) {
  return __defProp(target, "__esModule", {
    value: true
  });
};

var __export = function __export(target, all) {
  __markAsModule(target);

  for (var name in all) {
    __defProp(target, name, {
      get: all[name],
      enumerable: true
    });
  }
};

var __reExport = function __reExport(target, module2, desc) {
  if (module2 && _typeof(module2) === "object" || typeof module2 === "function") {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      var _loop = function _loop() {
        var key = _step.value;
        if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
          get: function get() {
            return module2[key];
          },
          enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
      };

      for (var _iterator = __getOwnPropNames(module2)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        _loop();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return target;
};

var __toModule = function __toModule(module2) {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
    get: function get() {
      return module2["default"];
    },
    enumerable: true
  } : {
    value: module2,
    enumerable: true
  })), module2);
};

__export(exports, {
  injectReplacements: function injectReplacements() {
    return _injectReplacements;
  }
});

var import_isPlainObject = __toModule(require("lodash/isPlainObject"));

var import_sql_string = __toModule(require("../sql-string"));

function _injectReplacements(sqlString, dialect, replacements) {
  var _a, _b, _c, _d;

  if (replacements == null) {
    return sqlString;
  }

  if (!Array.isArray(replacements) && !(0, import_isPlainObject["default"])(replacements)) {
    throw new TypeError("\"replacements\" must be an array or a plain object, but received ".concat(JSON.stringify(replacements), " instead."));
  }

  var isNamedReplacements = (0, import_isPlainObject["default"])(replacements);
  var isPositionalReplacements = Array.isArray(replacements);
  var lastConsumedPositionalReplacementIndex = -1;
  var output = "";
  var currentDollarStringTagName = null;
  var isString = false;
  var isColumn = false;
  var previousSliceEnd = 0;
  var isSingleLineComment = false;
  var isCommentBlock = false;
  var stringIsBackslashEscapable = false;

  for (var i = 0; i < sqlString.length; i++) {
    var _char = sqlString[i];

    if (isColumn) {
      if (_char === dialect.TICK_CHAR_RIGHT) {
        isColumn = false;
      }

      continue;
    }

    if (isString) {
      if (_char === "'" && (!stringIsBackslashEscapable || !isBackslashEscaped(sqlString, i - 1))) {
        isString = false;
        stringIsBackslashEscapable = false;
      }

      continue;
    }

    if (currentDollarStringTagName !== null) {
      if (_char !== "$") {
        continue;
      }

      var remainingString = sqlString.slice(i, sqlString.length);
      var dollarStringStartMatch = remainingString.match(_wrapRegExp(/^\$([_a-z][0-9_a-z]*)?(\$)/i, {
        name: 1
      }));
      var tagName = ((_a = dollarStringStartMatch == null ? void 0 : dollarStringStartMatch.groups) == null ? void 0 : _a.name) || "";

      if (currentDollarStringTagName === tagName) {
        currentDollarStringTagName = null;
      }

      continue;
    }

    if (isSingleLineComment) {
      if (_char === "\n") {
        isSingleLineComment = false;
      }

      continue;
    }

    if (isCommentBlock) {
      if (_char === "*" && sqlString[i + 1] === "/") {
        isCommentBlock = false;
      }

      continue;
    }

    if (_char === dialect.TICK_CHAR_LEFT) {
      isColumn = true;
      continue;
    }

    if (_char === "'") {
      isString = true;
      stringIsBackslashEscapable = dialect.canBackslashEscape() || dialect.supports.escapeStringConstants && (sqlString[i - 1] === "E" || sqlString[i - 1] === "e") && canPrecedeNewToken(sqlString[i - 2]);
      continue;
    }

    if (_char === "-" && sqlString.slice(i, i + 3) === "-- ") {
      isSingleLineComment = true;
      continue;
    }

    if (_char === "/" && sqlString.slice(i, i + 2) === "/*") {
      isCommentBlock = true;
      continue;
    }

    if (_char === "$") {
      var previousChar = sqlString[i - 1];

      if (/[0-9a-z_]/i.test(previousChar)) {
        continue;
      }

      var _remainingString = sqlString.slice(i, sqlString.length);

      var _dollarStringStartMatch = _remainingString.match(_wrapRegExp(/^\$([_a-z][0-9_a-z]*)?(\$)/i, {
        name: 1
      }));

      if (_dollarStringStartMatch) {
        currentDollarStringTagName = (_c = (_b = _dollarStringStartMatch.groups) == null ? void 0 : _b.name) != null ? _c : "";
        i += _dollarStringStartMatch[0].length - 1;
        continue;
      }

      continue;
    }

    if (isNamedReplacements && _char === ":") {
      var _previousChar = sqlString[i - 1];

      if (!canPrecedeNewToken(_previousChar) && _previousChar !== "[") {
        continue;
      }

      var _remainingString2 = sqlString.slice(i, sqlString.length);

      var match = _remainingString2.match(_wrapRegExp(/^:([_a-z][0-9_a-z]*)(?:\)|,|$|[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]|::|;|\])/i, {
        name: 1
      }));

      var replacementName = (_d = match == null ? void 0 : match.groups) == null ? void 0 : _d.name;

      if (!replacementName) {
        continue;
      }

      var replacementValue = replacements[replacementName];

      if (!Object.prototype.hasOwnProperty.call(replacements, replacementName) || replacementValue === void 0) {
        throw new Error("Named replacement \":".concat(replacementName, "\" has no entry in the replacement map."));
      }

      var escapedReplacement = (0, import_sql_string.escape)(replacementValue, void 0, dialect.name, true);
      output += sqlString.slice(previousSliceEnd, i);
      previousSliceEnd = i + replacementName.length + 1;
      output += escapedReplacement;
      continue;
    }

    if (isPositionalReplacements && _char === "?") {
      var _previousChar2 = sqlString[i - 1];

      if (!canPrecedeNewToken(_previousChar2) && _previousChar2 !== "[") {
        continue;
      }

      var nextChar = sqlString[i + 1];

      if (nextChar === "|" || nextChar === "&") {
        continue;
      }

      var replacementIndex = ++lastConsumedPositionalReplacementIndex;
      var _replacementValue = replacements[lastConsumedPositionalReplacementIndex];

      if (_replacementValue === void 0) {
        throw new Error("Positional replacement (?) ".concat(replacementIndex, " has no entry in the replacement map (replacements[").concat(replacementIndex, "] is undefined)."));
      }

      var _escapedReplacement = (0, import_sql_string.escape)(_replacementValue, void 0, dialect.name, true);

      output += sqlString.slice(previousSliceEnd, i);
      previousSliceEnd = i + 1;
      output += _escapedReplacement;
    }
  }

  if (isString) {
    throw new Error("The following SQL query includes an unterminated string literal:\n".concat(sqlString));
  }

  output += sqlString.slice(previousSliceEnd, sqlString.length);
  return output;
}

function canPrecedeNewToken(_char2) {
  return _char2 === void 0 || /[\s(>,=]/.test(_char2);
}

function isBackslashEscaped(string, pos) {
  var escaped = false;

  for (var i = pos; i >= 0; i--) {
    var _char3 = string[i];

    if (_char3 !== "\\") {
      break;
    }

    escaped = !escaped;
  }

  return escaped;
}