"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return a;
};

var __spreadProps = function __spreadProps(a, b) {
  return __defProps(a, __getOwnPropDescs(b));
};

var _ = require("lodash");

var Utils = require("../../utils");

var AbstractQueryGenerator = require("../abstract/query-generator");

var util = require("util");

var Op = require("../../operators");

var JSON_FUNCTION_REGEX = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
var JSON_OPERATOR_REGEX = /^\s*(->>?|@>|<@|\?[|&]?|\|{2}|#-)/i;
var TOKEN_CAPTURE_REGEX = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;
var FOREIGN_KEY_FIELDS = ["CONSTRAINT_NAME as constraint_name", "CONSTRAINT_NAME as constraintName", "CONSTRAINT_SCHEMA as constraintSchema", "CONSTRAINT_SCHEMA as constraintCatalog", "TABLE_NAME as tableName", "TABLE_SCHEMA as tableSchema", "TABLE_SCHEMA as tableCatalog", "COLUMN_NAME as columnName", "REFERENCED_TABLE_SCHEMA as referencedTableSchema", "REFERENCED_TABLE_SCHEMA as referencedTableCatalog", "REFERENCED_TABLE_NAME as referencedTableName", "REFERENCED_COLUMN_NAME as referencedColumnName"].join(",");
var SNOWFLAKE_RESERVED_WORDS = "account,all,alter,and,any,as,between,by,case,cast,check,column,connect,connections,constraint,create,cross,current,current_date,current_time,current_timestamp,current_user,database,delete,distinct,drop,else,exists,false,following,for,from,full,grant,group,gscluster,having,ilike,in,increment,inner,insert,intersect,into,is,issue,join,lateral,left,like,localtime,localtimestamp,minus,natural,not,null,of,on,or,order,organization,qualify,regexp,revoke,right,rlike,row,rows,sample,schema,select,set,some,start,table,tablesample,then,to,trigger,true,try_cast,union,unique,update,using,values,view,when,whenever,where,with".split(",");
var typeWithoutDefault =
/* @__PURE__ */
new Set(["BLOB", "TEXT", "GEOMETRY", "JSON"]);

var SnowflakeQueryGenerator =
/*#__PURE__*/
function (_AbstractQueryGenerat) {
  _inherits(SnowflakeQueryGenerator, _AbstractQueryGenerat);

  function SnowflakeQueryGenerator(options) {
    var _spreadProps;

    var _this;

    _classCallCheck(this, SnowflakeQueryGenerator);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SnowflakeQueryGenerator).call(this, options));
    _this.OperatorMap = __spreadProps(__spreadValues({}, _this.OperatorMap), (_spreadProps = {}, _defineProperty(_spreadProps, Op.regexp, "REGEXP"), _defineProperty(_spreadProps, Op.notRegexp, "NOT REGEXP"), _spreadProps));
    return _this;
  }

  _createClass(SnowflakeQueryGenerator, [{
    key: "createDatabaseQuery",
    value: function createDatabaseQuery(databaseName, options) {
      options = __spreadValues({
        charset: null,
        collate: null
      }, options);
      return Utils.joinSQLFragments(["CREATE DATABASE IF NOT EXISTS", this.quoteIdentifier(databaseName), options.charset && "DEFAULT CHARACTER SET ".concat(this.escape(options.charset)), options.collate && "DEFAULT COLLATE ".concat(this.escape(options.collate)), ";"]);
    }
  }, {
    key: "dropDatabaseQuery",
    value: function dropDatabaseQuery(databaseName) {
      return "DROP DATABASE IF EXISTS ".concat(this.quoteIdentifier(databaseName), ";");
    }
  }, {
    key: "createSchema",
    value: function createSchema() {
      return "SHOW TABLES";
    }
  }, {
    key: "showSchemasQuery",
    value: function showSchemasQuery() {
      return "SHOW TABLES";
    }
  }, {
    key: "versionQuery",
    value: function versionQuery() {
      return "SELECT CURRENT_VERSION()";
    }
  }, {
    key: "createTableQuery",
    value: function createTableQuery(tableName, attributes, options) {
      var _this2 = this;

      options = __spreadValues({
        charset: null,
        rowFormat: null
      }, options);
      var primaryKeys = [];
      var foreignKeys = {};
      var attrStr = [];

      for (var attr in attributes) {
        if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;
        var dataType = attributes[attr];
        var match = void 0;

        if (dataType.includes("PRIMARY KEY")) {
          primaryKeys.push(attr);

          if (dataType.includes("REFERENCES")) {
            match = dataType.match(/^(.+) (REFERENCES.*)$/);
            attrStr.push("".concat(this.quoteIdentifier(attr), " ").concat(match[1].replace("PRIMARY KEY", "")));
            foreignKeys[attr] = match[2];
          } else {
            attrStr.push("".concat(this.quoteIdentifier(attr), " ").concat(dataType.replace("PRIMARY KEY", "")));
          }
        } else if (dataType.includes("REFERENCES")) {
          match = dataType.match(/^(.+) (REFERENCES.*)$/);
          attrStr.push("".concat(this.quoteIdentifier(attr), " ").concat(match[1]));
          foreignKeys[attr] = match[2];
        } else {
          attrStr.push("".concat(this.quoteIdentifier(attr), " ").concat(dataType));
        }
      }

      var table = this.quoteTable(tableName);
      var attributesClause = attrStr.join(", ");
      var pkString = primaryKeys.map(function (pk) {
        return _this2.quoteIdentifier(pk);
      }).join(", ");

      if (options.uniqueKeys) {
        _.each(options.uniqueKeys, function (columns, indexName) {
          if (columns.customIndex) {
            if (typeof indexName !== "string") {
              indexName = "uniq_".concat(tableName, "_").concat(columns.fields.join("_"));
            }

            attributesClause += ", UNIQUE ".concat(_this2.quoteIdentifier(indexName), " (").concat(columns.fields.map(function (field) {
              return _this2.quoteIdentifier(field);
            }).join(", "), ")");
          }
        });
      }

      if (pkString.length > 0) {
        attributesClause += ", PRIMARY KEY (".concat(pkString, ")");
      }

      for (var fkey in foreignKeys) {
        if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
          attributesClause += ", FOREIGN KEY (".concat(this.quoteIdentifier(fkey), ") ").concat(foreignKeys[fkey]);
        }
      }

      return Utils.joinSQLFragments(["CREATE TABLE IF NOT EXISTS", table, "(".concat(attributesClause, ")"), options.comment && typeof options.comment === "string" && "COMMENT ".concat(this.escape(options.comment)), options.charset && "DEFAULT CHARSET=".concat(options.charset), options.collate && "COLLATE ".concat(options.collate), options.rowFormat && "ROW_FORMAT=".concat(options.rowFormat), ";"]);
    }
  }, {
    key: "describeTableQuery",
    value: function describeTableQuery(tableName, schema, schemaDelimiter) {
      var table = this.quoteTable(this.addSchema({
        tableName: tableName,
        _schema: schema,
        _schemaDelimiter: schemaDelimiter
      }));
      return "SHOW FULL COLUMNS FROM ".concat(table, ";");
    }
  }, {
    key: "showTablesQuery",
    value: function showTablesQuery(database) {
      return Utils.joinSQLFragments(["SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'", database ? "AND TABLE_SCHEMA = ".concat(this.escape(database)) : "AND TABLE_SCHEMA NOT IN ( 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS')", ";"]);
    }
  }, {
    key: "tableExistsQuery",
    value: function tableExistsQuery(table) {
      var tableName = table.tableName || table;
      var schema = table.schema;
      return Utils.joinSQLFragments(["SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'", "AND TABLE_SCHEMA = ".concat(schema !== void 0 ? this.escape(schema) : "CURRENT_SCHEMA()"), "AND TABLE_NAME = ".concat(this.escape(tableName)), ";"]);
    }
  }, {
    key: "addColumnQuery",
    value: function addColumnQuery(table, key, dataType) {
      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(table), "ADD", this.quoteIdentifier(key), this.attributeToSQL(dataType, {
        context: "addColumn",
        tableName: table,
        foreignKey: key
      }), ";"]);
    }
  }, {
    key: "removeColumnQuery",
    value: function removeColumnQuery(tableName, attributeName) {
      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(tableName), "DROP", this.quoteIdentifier(attributeName), ";"]);
    }
  }, {
    key: "changeColumnQuery",
    value: function changeColumnQuery(tableName, attributes) {
      var _this3 = this;

      var query = function query() {
        for (var _len = arguments.length, subQuerys = new Array(_len), _key = 0; _key < _len; _key++) {
          subQuerys[_key] = arguments[_key];
        }

        return Utils.joinSQLFragments(["ALTER TABLE", _this3.quoteTable(tableName), "ALTER COLUMN"].concat(subQuerys, [";"]));
      };

      var sql = [];

      for (var attributeName in attributes) {
        var definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);
        var attrSql = [];

        if (definition.includes("NOT NULL")) {
          attrSql.push(query(this.quoteIdentifier(attributeName), "SET NOT NULL"));
          definition = definition.replace("NOT NULL", "").trim();
        } else if (!definition.includes("REFERENCES")) {
          attrSql.push(query(this.quoteIdentifier(attributeName), "DROP NOT NULL"));
        }

        if (definition.includes("DEFAULT")) {
          attrSql.push(query(this.quoteIdentifier(attributeName), "SET DEFAULT", definition.match(/DEFAULT ([^;]+)/)[1]));
          definition = definition.replace(/(DEFAULT[^;]+)/, "").trim();
        } else if (!definition.includes("REFERENCES")) {
          attrSql.push(query(this.quoteIdentifier(attributeName), "DROP DEFAULT"));
        }

        if (definition.match(/UNIQUE;*$/)) {
          definition = definition.replace(/UNIQUE;*$/, "");
          attrSql.push(query("ADD UNIQUE (", this.quoteIdentifier(attributeName), ")").replace("ALTER COLUMN", ""));
        }

        if (definition.includes("REFERENCES")) {
          definition = definition.replace(/.+?(?=REFERENCES)/, "");
          attrSql.push(query("ADD FOREIGN KEY (", this.quoteIdentifier(attributeName), ")", definition).replace("ALTER COLUMN", ""));
        } else {
          attrSql.push(query(this.quoteIdentifier(attributeName), "TYPE", definition));
        }

        sql.push(attrSql.join(""));
      }

      return sql.join("");
    }
  }, {
    key: "renameColumnQuery",
    value: function renameColumnQuery(tableName, attrBefore, attributes) {
      var attrString = [];

      for (var attrName in attributes) {
        var definition = attributes[attrName];
        attrString.push("'".concat(attrBefore, "' '").concat(attrName, "' ").concat(definition));
      }

      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(tableName), "RENAME COLUMN", attrString.join(" to "), ";"]);
    }
  }, {
    key: "handleSequelizeMethod",
    value: function handleSequelizeMethod(attr, tableName, factory, options, prepend) {
      var _this4 = this;

      if (attr instanceof Utils.Json) {
        if (attr.conditions) {
          var conditions = this.parseConditionObject(attr.conditions).map(function (condition) {
            return "".concat(_this4.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path)), " = '").concat(condition.value, "'");
          });
          return conditions.join(" AND ");
        }

        if (attr.path) {
          var str;

          if (this._checkValidJsonStatement(attr.path)) {
            str = attr.path;
          } else {
            var paths = _.toPath(attr.path);

            var column = paths.shift();
            str = this.jsonPathExtractionQuery(column, paths);
          }

          if (attr.value) {
            str += util.format(" = %s", this.escape(attr.value));
          }

          return str;
        }
      } else if (attr instanceof Utils.Cast) {
        if (/timestamp/i.test(attr.type)) {
          attr.type = "datetime";
        } else if (attr.json && /boolean/i.test(attr.type)) {
          attr.type = "char";
        } else if (/double precision/i.test(attr.type) || /boolean/i.test(attr.type) || /integer/i.test(attr.type)) {
          attr.type = "decimal";
        } else if (/text/i.test(attr.type)) {
          attr.type = "char";
        }
      }

      return _get(_getPrototypeOf(SnowflakeQueryGenerator.prototype), "handleSequelizeMethod", this).call(this, attr, tableName, factory, options, prepend);
    }
  }, {
    key: "truncateTableQuery",
    value: function truncateTableQuery(tableName) {
      return Utils.joinSQLFragments(["TRUNCATE", this.quoteTable(tableName)]);
    }
  }, {
    key: "deleteQuery",
    value: function deleteQuery(tableName, where) {
      var _this5 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var model = arguments.length > 3 ? arguments[3] : undefined;
      var table = this.quoteTable(tableName);
      var whereClause = this.getWhereConditions(where, null, model, options);
      var limit = options.limit && " LIMIT ".concat(this.escape(options.limit));
      var primaryKeys = "";
      var primaryKeysSelection = "";

      if (whereClause) {
        whereClause = "WHERE ".concat(whereClause);
      }

      if (limit) {
        if (!model) {
          throw new Error("Cannot LIMIT delete without a model.");
        }

        var pks = Object.values(model.primaryKeys).map(function (pk) {
          return _this5.quoteIdentifier(pk.field);
        }).join(",");
        primaryKeys = model.primaryKeyAttributes.length > 1 ? "(".concat(pks, ")") : pks;
        primaryKeysSelection = pks;
        return Utils.joinSQLFragments(["DELETE FROM", table, "WHERE", primaryKeys, "IN (SELECT", primaryKeysSelection, "FROM", table, whereClause, limit, ")", ";"]);
      }

      return Utils.joinSQLFragments(["DELETE FROM", table, whereClause, ";"]);
    }
  }, {
    key: "showIndexesQuery",
    value: function showIndexesQuery() {
      return "SELECT '' FROM DUAL";
    }
  }, {
    key: "showConstraintsQuery",
    value: function showConstraintsQuery(table, constraintName) {
      var tableName = table.tableName || table;
      var schemaName = table.schema;
      return Utils.joinSQLFragments(["SELECT CONSTRAINT_CATALOG AS constraintCatalog,", "CONSTRAINT_NAME AS constraintName,", "CONSTRAINT_SCHEMA AS constraintSchema,", "CONSTRAINT_TYPE AS constraintType,", "TABLE_NAME AS tableName,", "TABLE_SCHEMA AS tableSchema", "from INFORMATION_SCHEMA.TABLE_CONSTRAINTS", "WHERE table_name='".concat(tableName, "'"), constraintName && "AND constraint_name = '".concat(constraintName, "'"), schemaName && "AND TABLE_SCHEMA = '".concat(schemaName, "'"), ";"]);
    }
  }, {
    key: "removeIndexQuery",
    value: function removeIndexQuery(tableName, indexNameOrAttributes) {
      var indexName = indexNameOrAttributes;

      if (typeof indexName !== "string") {
        indexName = Utils.underscore("".concat(tableName, "_").concat(indexNameOrAttributes.join("_")));
      }

      return Utils.joinSQLFragments(["DROP INDEX", this.quoteIdentifier(indexName), "ON", this.quoteTable(tableName), ";"]);
    }
  }, {
    key: "attributeToSQL",
    value: function attributeToSQL(attribute, options) {
      if (!_.isPlainObject(attribute)) {
        attribute = {
          type: attribute
        };
      }

      var attributeString = attribute.type.toString({
        escape: this.escape.bind(this)
      });
      var template = attributeString;

      if (attribute.allowNull === false) {
        template += " NOT NULL";
      }

      if (attribute.autoIncrement) {
        template += " AUTOINCREMENT";
      }

      if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {
        template += " DEFAULT ".concat(this.escape(attribute.defaultValue));
      }

      if (attribute.unique === true) {
        template += " UNIQUE";
      }

      if (attribute.primaryKey) {
        template += " PRIMARY KEY";
      }

      if (attribute.comment) {
        template += " COMMENT ".concat(this.escape(attribute.comment));
      }

      if (attribute.first) {
        template += " FIRST";
      }

      if (attribute.after) {
        template += " AFTER ".concat(this.quoteIdentifier(attribute.after));
      }

      if (attribute.references) {
        if (options && options.context === "addColumn" && options.foreignKey) {
          var attrName = this.quoteIdentifier(options.foreignKey);
          var fkName = this.quoteIdentifier("".concat(options.tableName, "_").concat(attrName, "_foreign_idx"));
          template += ", ADD CONSTRAINT ".concat(fkName, " FOREIGN KEY (").concat(attrName, ")");
        }

        template += " REFERENCES ".concat(this.quoteTable(attribute.references.model));

        if (attribute.references.key) {
          template += " (".concat(this.quoteIdentifier(attribute.references.key), ")");
        } else {
          template += " (".concat(this.quoteIdentifier("id"), ")");
        }

        if (attribute.onDelete) {
          template += " ON DELETE ".concat(attribute.onDelete.toUpperCase());
        }

        if (attribute.onUpdate) {
          template += " ON UPDATE ".concat(attribute.onUpdate.toUpperCase());
        }
      }

      return template;
    }
  }, {
    key: "attributesToSQL",
    value: function attributesToSQL(attributes, options) {
      var result = {};

      for (var key in attributes) {
        var attribute = attributes[key];
        result[attribute.field || key] = this.attributeToSQL(attribute, options);
      }

      return result;
    }
  }, {
    key: "_checkValidJsonStatement",
    value: function _checkValidJsonStatement(stmt) {
      if (typeof stmt !== "string") {
        return false;
      }

      var currentIndex = 0;
      var openingBrackets = 0;
      var closingBrackets = 0;
      var hasJsonFunction = false;
      var hasInvalidToken = false;

      while (currentIndex < stmt.length) {
        var string = stmt.substr(currentIndex);
        var functionMatches = JSON_FUNCTION_REGEX.exec(string);

        if (functionMatches) {
          currentIndex += functionMatches[0].indexOf("(");
          hasJsonFunction = true;
          continue;
        }

        var operatorMatches = JSON_OPERATOR_REGEX.exec(string);

        if (operatorMatches) {
          currentIndex += operatorMatches[0].length;
          hasJsonFunction = true;
          continue;
        }

        var tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);

        if (tokenMatches) {
          var capturedToken = tokenMatches[1];

          if (capturedToken === "(") {
            openingBrackets++;
          } else if (capturedToken === ")") {
            closingBrackets++;
          } else if (capturedToken === ";") {
            hasInvalidToken = true;
            break;
          }

          currentIndex += tokenMatches[0].length;
          continue;
        }

        break;
      }

      if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {
        throw new Error("Invalid json statement: ".concat(stmt));
      }

      return hasJsonFunction;
    }
  }, {
    key: "dataTypeMapping",
    value: function dataTypeMapping(tableName, attr, dataType) {
      if (dataType.includes("PRIMARY KEY")) {
        dataType = dataType.replace("PRIMARY KEY", "");
      }

      if (dataType.includes("SERIAL")) {
        if (dataType.includes("BIGINT")) {
          dataType = dataType.replace("SERIAL", "BIGSERIAL");
          dataType = dataType.replace("BIGINT", "");
        } else if (dataType.includes("SMALLINT")) {
          dataType = dataType.replace("SERIAL", "SMALLSERIAL");
          dataType = dataType.replace("SMALLINT", "");
        } else {
          dataType = dataType.replace("INTEGER", "");
        }

        dataType = dataType.replace("NOT NULL", "");
      }

      return dataType;
    }
  }, {
    key: "getForeignKeysQuery",
    value: function getForeignKeysQuery(table, schemaName) {
      var tableName = table.tableName || table;
      return Utils.joinSQLFragments(["SELECT", FOREIGN_KEY_FIELDS, "FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '".concat(tableName, "'"), "AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='".concat(schemaName, "'"), "AND REFERENCED_TABLE_NAME IS NOT NULL", ";"]);
    }
  }, {
    key: "getForeignKeyQuery",
    value: function getForeignKeyQuery(table, columnName) {
      var quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : "";
      var quotedTableName = wrapSingleQuote(table.tableName || table);
      var quotedColumnName = wrapSingleQuote(columnName);
      return Utils.joinSQLFragments(["SELECT", FOREIGN_KEY_FIELDS, "FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE", "WHERE (", ["REFERENCED_TABLE_NAME = ".concat(quotedTableName), table.schema && "AND REFERENCED_TABLE_SCHEMA = ".concat(quotedSchemaName), "AND REFERENCED_COLUMN_NAME = ".concat(quotedColumnName)], ") OR (", ["TABLE_NAME = ".concat(quotedTableName), table.schema && "AND TABLE_SCHEMA = ".concat(quotedSchemaName), "AND COLUMN_NAME = ".concat(quotedColumnName), "AND REFERENCED_TABLE_NAME IS NOT NULL"], ")"]);
    }
  }, {
    key: "dropForeignKeyQuery",
    value: function dropForeignKeyQuery(tableName, foreignKey) {
      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(tableName), "DROP FOREIGN KEY", this.quoteIdentifier(foreignKey), ";"]);
    }
  }, {
    key: "addLimitAndOffset",
    value: function addLimitAndOffset(options) {
      var fragment = [];

      if (options.offset !== null && options.offset !== void 0 && options.offset !== 0) {
        fragment = fragment.concat([" LIMIT ", this.escape(options.limit), " OFFSET ", this.escape(options.offset)]);
      } else if (options.limit !== null && options.limit !== void 0) {
        fragment = [" LIMIT ", this.escape(options.limit)];
      }

      return fragment.join("");
    }
  }, {
    key: "quoteIdentifier",
    value: function quoteIdentifier(identifier, force) {
      var optForceQuote = force || false;
      var optQuoteIdentifiers = this.options.quoteIdentifiers !== false;
      var rawIdentifier = Utils.removeTicks(identifier, '"');

      if (optForceQuote === true || optQuoteIdentifiers !== false || identifier.includes(".") || identifier.includes("->") || SNOWFLAKE_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())) {
        return Utils.addTicks(rawIdentifier, '"');
      }

      return rawIdentifier;
    }
  }]);

  return SnowflakeQueryGenerator;
}(AbstractQueryGenerator);

function wrapSingleQuote(identifier) {
  return Utils.addTicks(identifier, "'");
}

module.exports = SnowflakeQueryGenerator;