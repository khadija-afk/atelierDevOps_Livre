'use strict'; // TODO: rename to OK packet
// https://dev.mysql.com/doc/internals/en/packet-OK_Packet.html

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Packet = require('./packet.js');

var ClientConstants = require('../constants/client.js');

var ServerSatusFlags = require('../constants/server_status.js');

var EncodingToCharset = require('../constants/encoding_charset.js');

var sessionInfoTypes = require('../constants/session_track.js');

var ResultSetHeader =
/*#__PURE__*/
function () {
  function ResultSetHeader(packet, connection) {
    _classCallCheck(this, ResultSetHeader);

    var bigNumberStrings = connection.config.bigNumberStrings;
    var encoding = connection.serverEncoding;
    var flags = connection._handshakePacket.capabilityFlags;

    var isSet = function isSet(flag) {
      return flags & ClientConstants[flag];
    };

    if (packet.buffer[packet.offset] !== 0) {
      this.fieldCount = packet.readLengthCodedNumber();

      if (this.fieldCount === null) {
        this.infileName = packet.readString(undefined, encoding);
      }

      return;
    }

    this.fieldCount = packet.readInt8(); // skip OK byte

    this.affectedRows = packet.readLengthCodedNumber(bigNumberStrings);
    this.insertId = packet.readLengthCodedNumberSigned(bigNumberStrings);
    this.info = '';

    if (isSet('PROTOCOL_41')) {
      this.serverStatus = packet.readInt16();
      this.warningStatus = packet.readInt16();
    } else if (isSet('TRANSACTIONS')) {
      this.serverStatus = packet.readInt16();
    }

    var stateChanges = null;

    if (isSet('SESSION_TRACK') && packet.offset < packet.end) {
      this.info = packet.readLengthCodedString(encoding);

      if (this.serverStatus && ServerSatusFlags.SERVER_SESSION_STATE_CHANGED) {
        // session change info record - see
        // https://dev.mysql.com/doc/internals/en/packet-OK_Packet.html#cs-sect-packet-ok-sessioninfo
        var len = packet.offset < packet.end ? packet.readLengthCodedNumber() : 0;
        var end = packet.offset + len;
        var type, key, stateEnd;

        if (len > 0) {
          stateChanges = {
            systemVariables: {},
            schema: null,
            gtids: [],
            trackStateChange: null
          };
        }

        while (packet.offset < end) {
          type = packet.readInt8();
          len = packet.readLengthCodedNumber();
          stateEnd = packet.offset + len;

          if (type === sessionInfoTypes.SYSTEM_VARIABLES) {
            key = packet.readLengthCodedString(encoding);
            var val = packet.readLengthCodedString(encoding);
            stateChanges.systemVariables[key] = val;

            if (key === 'character_set_client') {
              var charsetNumber = EncodingToCharset[val];
              connection.config.charsetNumber = charsetNumber;
            }
          } else if (type === sessionInfoTypes.SCHEMA) {
            key = packet.readLengthCodedString(encoding);
            stateChanges.schema = key;
          } else if (type === sessionInfoTypes.STATE_CHANGE) {
            stateChanges.trackStateChange = packet.readLengthCodedString(encoding);
          } else if (type === sessionInfoTypes.STATE_GTIDS) {
            // TODO: find if the first length coded string means anything. Usually comes as empty
            // eslint-disable-next-line no-unused-vars
            var _unknownString = packet.readLengthCodedString(encoding);

            var gtid = packet.readLengthCodedString(encoding);
            stateChanges.gtids = gtid.split(',');
          } else {// unsupported session track type. For now just ignore
          }

          packet.offset = stateEnd;
        }
      }
    } else {
      this.info = packet.readString(undefined, encoding);
    }

    if (stateChanges) {
      this.stateChanges = stateChanges;
    }

    var m = this.info.match(/\schanged:\s*(\d+)/i);

    if (m !== null) {
      this.changedRows = parseInt(m[1], 10);
    } else {
      this.changedRows = 0;
    }
  } // TODO: should be consistent instance member, but it's just easier here to have just function


  _createClass(ResultSetHeader, null, [{
    key: "toPacket",
    value: function toPacket(fieldCount, insertId) {
      var length = 4 + Packet.lengthCodedNumberLength(fieldCount);

      if (typeof insertId !== 'undefined') {
        length += Packet.lengthCodedNumberLength(insertId);
      }

      var buffer = Buffer.allocUnsafe(length);
      var packet = new Packet(0, buffer, 0, length);
      packet.offset = 4;
      packet.writeLengthCodedNumber(fieldCount);

      if (typeof insertId !== 'undefined') {
        packet.writeLengthCodedNumber(insertId);
      }

      return packet;
    }
  }]);

  return ResultSetHeader;
}();

module.exports = ResultSetHeader;