"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require("sequelize-pool"),
    Pool = _require.Pool,
    TimeoutError = _require.TimeoutError;

var _ = require("lodash");

var semver = require("semver");

var errors = require("../../errors");

var _require2 = require("../../utils/logger"),
    logger = _require2.logger;

var deprecations = require("../../utils/deprecations");

var debug = logger.debugContext("pool");

var ConnectionManager =
/*#__PURE__*/
function () {
  function ConnectionManager(dialect, sequelize) {
    _classCallCheck(this, ConnectionManager);

    var config = _.cloneDeep(sequelize.config);

    this.sequelize = sequelize;
    this.config = config;
    this.dialect = dialect;
    this.versionPromise = null;
    this.dialectName = this.sequelize.options.dialect;

    if (config.pool === false) {
      throw new Error("Support for pool:false was removed in v4.0");
    }

    config.pool = _.defaults(config.pool || {}, {
      max: 5,
      min: 0,
      idle: 1e4,
      acquire: 6e4,
      evict: 1e3,
      validate: this._validate.bind(this)
    });
    this.initPools();
  }

  _createClass(ConnectionManager, [{
    key: "refreshTypeParser",
    value: function refreshTypeParser(dataTypes) {
      var _this = this;

      _.each(dataTypes, function (dataType) {
        if (Object.prototype.hasOwnProperty.call(dataType, "parse")) {
          if (dataType.types[_this.dialectName]) {
            _this._refreshTypeParser(dataType);
          } else {
            throw new Error("Parse function not supported for type ".concat(dataType.key, " in dialect ").concat(_this.dialectName));
          }
        }
      });
    }
  }, {
    key: "_loadDialectModule",
    value: function _loadDialectModule(moduleName) {
      try {
        if (this.sequelize.config.dialectModulePath) {
          return require(this.sequelize.config.dialectModulePath);
        }

        if (this.sequelize.config.dialectModule) {
          return this.sequelize.config.dialectModule;
        }

        return require(moduleName);
      } catch (err) {
        if (err.code === "MODULE_NOT_FOUND") {
          if (this.sequelize.config.dialectModulePath) {
            throw new Error("Unable to find dialect at ".concat(this.sequelize.config.dialectModulePath));
          }

          throw new Error("Please install ".concat(moduleName, " package manually"));
        }

        throw err;
      }
    }
  }, {
    key: "_onProcessExit",
    value: function _onProcessExit() {
      return regeneratorRuntime.async(function _onProcessExit$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (this.pool) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return");

            case 2:
              _context.next = 4;
              return regeneratorRuntime.awrap(this.pool.drain());

            case 4:
              debug("connection drain due to process exit");
              _context.next = 7;
              return regeneratorRuntime.awrap(this.pool.destroyAllNow());

            case 7:
              return _context.abrupt("return", _context.sent);

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "close",
    value: function close() {
      return regeneratorRuntime.async(function close$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              this.getConnection = function getConnection() {
                return regeneratorRuntime.async(function getConnection$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        throw new Error("ConnectionManager.getConnection was called after the connection manager was closed!");

                      case 1:
                      case "end":
                        return _context2.stop();
                    }
                  }
                });
              };

              _context3.next = 3;
              return regeneratorRuntime.awrap(this._onProcessExit());

            case 3:
              return _context3.abrupt("return", _context3.sent);

            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "initPools",
    value: function initPools() {
      var _this2 = this;

      var config = this.config;

      if (!config.replication) {
        this.pool = new Pool({
          name: "sequelize",
          create: function create() {
            return _this2._connect(config);
          },
          destroy: function destroy(connection) {
            var result;
            return regeneratorRuntime.async(function destroy$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return regeneratorRuntime.awrap(_this2._disconnect(connection));

                  case 2:
                    result = _context4.sent;
                    debug("connection destroy");
                    return _context4.abrupt("return", result);

                  case 5:
                  case "end":
                    return _context4.stop();
                }
              }
            });
          },
          validate: config.pool.validate,
          max: config.pool.max,
          min: config.pool.min,
          acquireTimeoutMillis: config.pool.acquire,
          idleTimeoutMillis: config.pool.idle,
          reapIntervalMillis: config.pool.evict,
          maxUses: config.pool.maxUses
        });
        debug("pool created with max/min: ".concat(config.pool.max, "/").concat(config.pool.min, ", no replication"));
        return;
      }

      if (!Array.isArray(config.replication.read)) {
        config.replication.read = [config.replication.read];
      }

      config.replication.write = _.defaults(config.replication.write, _.omit(config, "replication"));
      config.replication.read = config.replication.read.map(function (readConfig) {
        return _.defaults(readConfig, _.omit(_this2.config, "replication"));
      });
      var reads = 0;
      this.pool = {
        release: function release(client) {
          if (client.queryType === "read") {
            _this2.pool.read.release(client);
          } else {
            _this2.pool.write.release(client);
          }
        },
        acquire: function acquire(queryType, useMaster) {
          useMaster = useMaster === void 0 ? false : useMaster;

          if (queryType === "SELECT" && !useMaster) {
            return _this2.pool.read.acquire();
          }

          return _this2.pool.write.acquire();
        },
        destroy: function destroy(connection) {
          _this2.pool[connection.queryType].destroy(connection);

          debug("connection destroy");
        },
        destroyAllNow: function destroyAllNow() {
          return regeneratorRuntime.async(function destroyAllNow$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return regeneratorRuntime.awrap(Promise.all([_this2.pool.read.destroyAllNow(), _this2.pool.write.destroyAllNow()]));

                case 2:
                  debug("all connections destroyed");

                case 3:
                case "end":
                  return _context5.stop();
              }
            }
          });
        },
        drain: function drain() {
          return regeneratorRuntime.async(function drain$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  return _context6.abrupt("return", Promise.all([_this2.pool.write.drain(), _this2.pool.read.drain()]));

                case 1:
                case "end":
                  return _context6.stop();
              }
            }
          });
        },
        read: new Pool({
          name: "sequelize:read",
          create: function create() {
            var nextRead, connection;
            return regeneratorRuntime.async(function create$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    nextRead = reads++ % config.replication.read.length;
                    _context7.next = 3;
                    return regeneratorRuntime.awrap(_this2._connect(config.replication.read[nextRead]));

                  case 3:
                    connection = _context7.sent;
                    connection.queryType = "read";
                    return _context7.abrupt("return", connection);

                  case 6:
                  case "end":
                    return _context7.stop();
                }
              }
            });
          },
          destroy: function destroy(connection) {
            return _this2._disconnect(connection);
          },
          validate: config.pool.validate,
          max: config.pool.max,
          min: config.pool.min,
          acquireTimeoutMillis: config.pool.acquire,
          idleTimeoutMillis: config.pool.idle,
          reapIntervalMillis: config.pool.evict,
          maxUses: config.pool.maxUses
        }),
        write: new Pool({
          name: "sequelize:write",
          create: function create() {
            var connection;
            return regeneratorRuntime.async(function create$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    _context8.next = 2;
                    return regeneratorRuntime.awrap(_this2._connect(config.replication.write));

                  case 2:
                    connection = _context8.sent;
                    connection.queryType = "write";
                    return _context8.abrupt("return", connection);

                  case 5:
                  case "end":
                    return _context8.stop();
                }
              }
            });
          },
          destroy: function destroy(connection) {
            return _this2._disconnect(connection);
          },
          validate: config.pool.validate,
          max: config.pool.max,
          min: config.pool.min,
          acquireTimeoutMillis: config.pool.acquire,
          idleTimeoutMillis: config.pool.idle,
          reapIntervalMillis: config.pool.evict,
          maxUses: config.pool.maxUses
        })
      };
      debug("pool created with max/min: ".concat(config.pool.max, "/").concat(config.pool.min, ", with replication"));
    }
  }, {
    key: "getConnection",
    value: function getConnection(options) {
      var _this3 = this;

      var result;
      return regeneratorRuntime.async(function getConnection$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              options = options || {};

              if (!(this.sequelize.options.databaseVersion === 0)) {
                _context10.next = 5;
                break;
              }

              if (!this.versionPromise) {
                this.versionPromise = function _callee() {
                  var connection, _options, version, parsedVersion;

                  return regeneratorRuntime.async(function _callee$(_context9) {
                    while (1) {
                      switch (_context9.prev = _context9.next) {
                        case 0:
                          _context9.prev = 0;
                          _context9.next = 3;
                          return regeneratorRuntime.awrap(_this3._connect(_this3.config.replication.write || _this3.config));

                        case 3:
                          connection = _context9.sent;
                          _options = {};
                          _options.transaction = {
                            connection: connection
                          };

                          _options.logging = function () {};

                          _options.logging.__testLoggingFn = true;

                          if (!(_this3.sequelize.options.databaseVersion === 0)) {
                            _context9.next = 14;
                            break;
                          }

                          _context9.next = 11;
                          return regeneratorRuntime.awrap(_this3.sequelize.databaseVersion(_options));

                        case 11:
                          version = _context9.sent;
                          parsedVersion = _.get(semver.coerce(version), "version") || version;
                          _this3.sequelize.options.databaseVersion = semver.valid(parsedVersion) ? parsedVersion : _this3.dialect.defaultVersion;

                        case 14:
                          if (semver.lt(_this3.sequelize.options.databaseVersion, _this3.dialect.defaultVersion)) {
                            deprecations.unsupportedEngine();
                            debug("Unsupported database engine version ".concat(_this3.sequelize.options.databaseVersion));
                          }

                          _this3.versionPromise = null;
                          _context9.next = 18;
                          return regeneratorRuntime.awrap(_this3._disconnect(connection));

                        case 18:
                          return _context9.abrupt("return", _context9.sent);

                        case 21:
                          _context9.prev = 21;
                          _context9.t0 = _context9["catch"](0);
                          _this3.versionPromise = null;
                          throw _context9.t0;

                        case 25:
                        case "end":
                          return _context9.stop();
                      }
                    }
                  }, null, null, [[0, 21]]);
                }();
              }

              _context10.next = 5;
              return regeneratorRuntime.awrap(this.versionPromise);

            case 5:
              _context10.prev = 5;
              _context10.next = 8;
              return regeneratorRuntime.awrap(this.sequelize.runHooks("beforePoolAcquire", options));

            case 8:
              _context10.next = 10;
              return regeneratorRuntime.awrap(this.pool.acquire(options.type, options.useMaster));

            case 10:
              result = _context10.sent;
              _context10.next = 13;
              return regeneratorRuntime.awrap(this.sequelize.runHooks("afterPoolAcquire", result, options));

            case 13:
              _context10.next = 20;
              break;

            case 15:
              _context10.prev = 15;
              _context10.t0 = _context10["catch"](5);

              if (!(_context10.t0 instanceof TimeoutError)) {
                _context10.next = 19;
                break;
              }

              throw new errors.ConnectionAcquireTimeoutError(_context10.t0);

            case 19:
              throw _context10.t0;

            case 20:
              debug("connection acquired");
              return _context10.abrupt("return", result);

            case 22:
            case "end":
              return _context10.stop();
          }
        }
      }, null, this, [[5, 15]]);
    }
  }, {
    key: "releaseConnection",
    value: function releaseConnection(connection) {
      this.pool.release(connection);
      debug("connection released");
    }
  }, {
    key: "destroyConnection",
    value: function destroyConnection(connection) {
      return regeneratorRuntime.async(function destroyConnection$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _context11.next = 2;
              return regeneratorRuntime.awrap(this.pool.destroy(connection));

            case 2:
              debug("connection ".concat(connection.uuid, " destroyed"));

            case 3:
            case "end":
              return _context11.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_connect",
    value: function _connect(config) {
      var connection;
      return regeneratorRuntime.async(function _connect$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return regeneratorRuntime.awrap(this.sequelize.runHooks("beforeConnect", config));

            case 2:
              _context12.next = 4;
              return regeneratorRuntime.awrap(this.dialect.connectionManager.connect(config));

            case 4:
              connection = _context12.sent;
              _context12.next = 7;
              return regeneratorRuntime.awrap(this.sequelize.runHooks("afterConnect", connection, config));

            case 7:
              return _context12.abrupt("return", connection);

            case 8:
            case "end":
              return _context12.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_disconnect",
    value: function _disconnect(connection) {
      return regeneratorRuntime.async(function _disconnect$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              _context13.next = 2;
              return regeneratorRuntime.awrap(this.sequelize.runHooks("beforeDisconnect", connection));

            case 2:
              _context13.next = 4;
              return regeneratorRuntime.awrap(this.dialect.connectionManager.disconnect(connection));

            case 4:
              return _context13.abrupt("return", this.sequelize.runHooks("afterDisconnect", connection));

            case 5:
            case "end":
              return _context13.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_validate",
    value: function _validate(connection) {
      if (!this.dialect.connectionManager.validate) {
        return true;
      }

      return this.dialect.connectionManager.validate(connection);
    }
  }]);

  return ConnectionManager;
}();

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports["default"] = ConnectionManager;