"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return a;
};

var __spreadProps = function __spreadProps(a, b) {
  return __defProps(a, __getOwnPropDescs(b));
};

var Utils = require("../../utils");

var Transaction = require("../../transaction");

var _ = require("lodash");

var MySqlQueryGenerator = require("../mysql/query-generator");

var AbstractQueryGenerator = require("../abstract/query-generator");

var SQLiteQueryGenerator =
/*#__PURE__*/
function (_MySqlQueryGenerator) {
  _inherits(SQLiteQueryGenerator, _MySqlQueryGenerator);

  function SQLiteQueryGenerator() {
    _classCallCheck(this, SQLiteQueryGenerator);

    return _possibleConstructorReturn(this, _getPrototypeOf(SQLiteQueryGenerator).apply(this, arguments));
  }

  _createClass(SQLiteQueryGenerator, [{
    key: "createSchema",
    value: function createSchema() {
      return "SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';";
    }
  }, {
    key: "showSchemasQuery",
    value: function showSchemasQuery() {
      return "SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';";
    }
  }, {
    key: "versionQuery",
    value: function versionQuery() {
      return "SELECT sqlite_version() as `version`";
    }
  }, {
    key: "createTableQuery",
    value: function createTableQuery(tableName, attributes, options) {
      var _this = this;

      options = options || {};
      var primaryKeys = [];
      var needsMultiplePrimaryKeys = Object.values(attributes).filter(function (definition) {
        return definition.includes("PRIMARY KEY");
      }).length > 1;
      var attrArray = [];

      for (var attr in attributes) {
        if (Object.prototype.hasOwnProperty.call(attributes, attr)) {
          var dataType = attributes[attr];
          var containsAutoIncrement = dataType.includes("AUTOINCREMENT");
          var dataTypeString = dataType;

          if (dataType.includes("PRIMARY KEY")) {
            if (dataType.includes("INT")) {
              dataTypeString = containsAutoIncrement ? "INTEGER PRIMARY KEY AUTOINCREMENT" : "INTEGER PRIMARY KEY";

              if (dataType.includes(" REFERENCES")) {
                dataTypeString += dataType.substr(dataType.indexOf(" REFERENCES"));
              }
            }

            if (needsMultiplePrimaryKeys) {
              primaryKeys.push(attr);

              if (dataType.includes("NOT NULL")) {
                dataTypeString = dataType.replace(" PRIMARY KEY", "");
              } else {
                dataTypeString = dataType.replace("PRIMARY KEY", "NOT NULL");
              }
            }
          }

          attrArray.push("".concat(this.quoteIdentifier(attr), " ").concat(dataTypeString));
        }
      }

      var table = this.quoteTable(tableName);
      var attrStr = attrArray.join(", ");
      var pkString = primaryKeys.map(function (pk) {
        return _this.quoteIdentifier(pk);
      }).join(", ");

      if (options.uniqueKeys) {
        _.each(options.uniqueKeys, function (columns) {
          if (columns.customIndex) {
            attrStr += ", UNIQUE (".concat(columns.fields.map(function (field) {
              return _this.quoteIdentifier(field);
            }).join(", "), ")");
          }
        });
      }

      if (pkString.length > 0) {
        attrStr += ", PRIMARY KEY (".concat(pkString, ")");
      }

      var sql = "CREATE TABLE IF NOT EXISTS ".concat(table, " (").concat(attrStr, ");");
      return this.replaceBooleanDefaults(sql);
    }
  }, {
    key: "booleanValue",
    value: function booleanValue(value) {
      return value ? 1 : 0;
    }
  }, {
    key: "_checkValidJsonStatement",
    value: function _checkValidJsonStatement(stmt) {
      if (typeof stmt !== "string") {
        return false;
      }

      var jsonFunctionRegex = /^\s*(json(?:_[a-z]+){0,2})\([^)]*\)/i;
      var tokenCaptureRegex = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;
      var currentIndex = 0;
      var openingBrackets = 0;
      var closingBrackets = 0;
      var hasJsonFunction = false;
      var hasInvalidToken = false;

      while (currentIndex < stmt.length) {
        var string = stmt.substr(currentIndex);
        var functionMatches = jsonFunctionRegex.exec(string);

        if (functionMatches) {
          currentIndex += functionMatches[0].indexOf("(");
          hasJsonFunction = true;
          continue;
        }

        var tokenMatches = tokenCaptureRegex.exec(string);

        if (tokenMatches) {
          var capturedToken = tokenMatches[1];

          if (capturedToken === "(") {
            openingBrackets++;
          } else if (capturedToken === ")") {
            closingBrackets++;
          } else if (capturedToken === ";") {
            hasInvalidToken = true;
            break;
          }

          currentIndex += tokenMatches[0].length;
          continue;
        }

        break;
      }

      hasInvalidToken |= openingBrackets !== closingBrackets;

      if (hasJsonFunction && hasInvalidToken) {
        throw new Error("Invalid json statement: ".concat(stmt));
      }

      return hasJsonFunction;
    }
  }, {
    key: "_toJSONValue",
    value: function _toJSONValue(value) {
      if (value instanceof Date) {
        return value.toISOString();
      }

      if (Array.isArray(value) && value[0] instanceof Date) {
        return value.map(function (val) {
          return val.toISOString();
        });
      }

      return value;
    }
  }, {
    key: "handleSequelizeMethod",
    value: function handleSequelizeMethod(smth, tableName, factory, options, prepend) {
      if (smth instanceof Utils.Json) {
        return _get(_getPrototypeOf(SQLiteQueryGenerator.prototype), "handleSequelizeMethod", this).call(this, smth, tableName, factory, options, prepend);
      }

      if (smth instanceof Utils.Cast) {
        if (/timestamp/i.test(smth.type)) {
          smth.type = "datetime";
        }
      }

      return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);
    }
  }, {
    key: "addColumnQuery",
    value: function addColumnQuery(table, key, dataType) {
      var attributes = {};
      attributes[key] = dataType;
      var fields = this.attributesToSQL(attributes, {
        context: "addColumn"
      });
      var attribute = "".concat(this.quoteIdentifier(key), " ").concat(fields[key]);
      var sql = "ALTER TABLE ".concat(this.quoteTable(table), " ADD ").concat(attribute, ";");
      return this.replaceBooleanDefaults(sql);
    }
  }, {
    key: "showTablesQuery",
    value: function showTablesQuery() {
      return "SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';";
    }
  }, {
    key: "updateQuery",
    value: function updateQuery(tableName, attrValueHash, where, options, attributes) {
      options = options || {};

      _.defaults(options, this.options);

      attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);
      var modelAttributeMap = {};
      var values = [];
      var bind = [];
      var bindParam = options.bindParam || this.bindParam(bind);

      if (attributes) {
        _.each(attributes, function (attribute, key) {
          modelAttributeMap[key] = attribute;

          if (attribute.field) {
            modelAttributeMap[attribute.field] = attribute;
          }
        });
      }

      for (var key in attrValueHash) {
        var value = attrValueHash[key];

        if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
          values.push("".concat(this.quoteIdentifier(key), "=").concat(this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
            context: "UPDATE"
          })));
        } else {
          values.push("".concat(this.quoteIdentifier(key), "=").concat(this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
            context: "UPDATE"
          }, bindParam)));
        }
      }

      var query;

      var whereOptions = __spreadProps(__spreadValues({}, options), {
        bindParam: bindParam
      });

      if (options.limit) {
        query = "UPDATE ".concat(this.quoteTable(tableName), " SET ").concat(values.join(","), " WHERE rowid IN (SELECT rowid FROM ").concat(this.quoteTable(tableName), " ").concat(this.whereQuery(where, whereOptions), " LIMIT ").concat(this.escape(options.limit), ")");
      } else {
        query = "UPDATE ".concat(this.quoteTable(tableName), " SET ").concat(values.join(","), " ").concat(this.whereQuery(where, whereOptions));
      }

      return {
        query: query,
        bind: bind
      };
    }
  }, {
    key: "truncateTableQuery",
    value: function truncateTableQuery(tableName) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return ["DELETE FROM ".concat(this.quoteTable(tableName)), options.restartIdentity ? "; DELETE FROM ".concat(this.quoteTable("sqlite_sequence"), " WHERE ").concat(this.quoteIdentifier("name"), " = ").concat(Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), "`"), "'"), ";") : ""].join("");
    }
  }, {
    key: "deleteQuery",
    value: function deleteQuery(tableName, where) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var model = arguments.length > 3 ? arguments[3] : undefined;

      _.defaults(options, this.options);

      var whereClause = this.getWhereConditions(where, null, model, options);

      if (whereClause) {
        whereClause = "WHERE ".concat(whereClause);
      }

      if (options.limit) {
        whereClause = "WHERE rowid IN (SELECT rowid FROM ".concat(this.quoteTable(tableName), " ").concat(whereClause, " LIMIT ").concat(this.escape(options.limit), ")");
      }

      return "DELETE FROM ".concat(this.quoteTable(tableName), " ").concat(whereClause);
    }
  }, {
    key: "attributesToSQL",
    value: function attributesToSQL(attributes) {
      var result = {};

      for (var name in attributes) {
        var dataType = attributes[name];
        var fieldName = dataType.field || name;

        if (_.isObject(dataType)) {
          var sql = dataType.type.toString();

          if (Object.prototype.hasOwnProperty.call(dataType, "allowNull") && !dataType.allowNull) {
            sql += " NOT NULL";
          }

          if (Utils.defaultValueSchemable(dataType.defaultValue)) {
            sql += " DEFAULT ".concat(this.escape(dataType.defaultValue, dataType));
          }

          if (dataType.unique === true) {
            sql += " UNIQUE";
          }

          if (dataType.primaryKey) {
            sql += " PRIMARY KEY";

            if (dataType.autoIncrement) {
              sql += " AUTOINCREMENT";
            }
          }

          if (dataType.references) {
            var referencesTable = this.quoteTable(dataType.references.model);
            var referencesKey = void 0;

            if (dataType.references.key) {
              referencesKey = this.quoteIdentifier(dataType.references.key);
            } else {
              referencesKey = this.quoteIdentifier("id");
            }

            sql += " REFERENCES ".concat(referencesTable, " (").concat(referencesKey, ")");

            if (dataType.onDelete) {
              sql += " ON DELETE ".concat(dataType.onDelete.toUpperCase());
            }

            if (dataType.onUpdate) {
              sql += " ON UPDATE ".concat(dataType.onUpdate.toUpperCase());
            }
          }

          result[fieldName] = sql;
        } else {
          result[fieldName] = dataType;
        }
      }

      return result;
    }
  }, {
    key: "showIndexesQuery",
    value: function showIndexesQuery(tableName) {
      return "PRAGMA INDEX_LIST(".concat(this.quoteTable(tableName), ")");
    }
  }, {
    key: "showConstraintsQuery",
    value: function showConstraintsQuery(tableName, constraintName) {
      var sql = "SELECT sql FROM sqlite_master WHERE tbl_name='".concat(tableName, "'");

      if (constraintName) {
        sql += " AND sql LIKE '%".concat(constraintName, "%'");
      }

      return "".concat(sql, ";");
    }
  }, {
    key: "removeIndexQuery",
    value: function removeIndexQuery(tableName, indexNameOrAttributes) {
      var indexName = indexNameOrAttributes;

      if (typeof indexName !== "string") {
        indexName = Utils.underscore("".concat(tableName, "_").concat(indexNameOrAttributes.join("_")));
      }

      return "DROP INDEX IF EXISTS ".concat(this.quoteIdentifier(indexName));
    }
  }, {
    key: "describeTableQuery",
    value: function describeTableQuery(tableName, schema, schemaDelimiter) {
      var table = {
        _schema: schema,
        _schemaDelimiter: schemaDelimiter,
        tableName: tableName
      };
      return "PRAGMA TABLE_INFO(".concat(this.quoteTable(this.addSchema(table)), ");");
    }
  }, {
    key: "describeCreateTableQuery",
    value: function describeCreateTableQuery(tableName) {
      return "SELECT sql FROM sqlite_master WHERE tbl_name='".concat(tableName, "';");
    }
  }, {
    key: "removeColumnQuery",
    value: function removeColumnQuery(tableName, attributes) {
      var _this2 = this;

      attributes = this.attributesToSQL(attributes);
      var backupTableName;

      if (_typeof(tableName) === "object") {
        backupTableName = {
          tableName: "".concat(tableName.tableName, "_backup"),
          schema: tableName.schema
        };
      } else {
        backupTableName = "".concat(tableName, "_backup");
      }

      var quotedTableName = this.quoteTable(tableName);
      var quotedBackupTableName = this.quoteTable(backupTableName);
      var attributeNames = Object.keys(attributes).map(function (attr) {
        return _this2.quoteIdentifier(attr);
      }).join(", ");
      return "".concat(this.createTableQuery(backupTableName, attributes), "INSERT INTO ").concat(quotedBackupTableName, " SELECT ").concat(attributeNames, " FROM ").concat(quotedTableName, ";DROP TABLE ").concat(quotedTableName, ";").concat(this.createTableQuery(tableName, attributes), "INSERT INTO ").concat(quotedTableName, " SELECT ").concat(attributeNames, " FROM ").concat(quotedBackupTableName, ";DROP TABLE ").concat(quotedBackupTableName, ";");
    }
  }, {
    key: "_alterConstraintQuery",
    value: function _alterConstraintQuery(tableName, attributes, createTableSql) {
      var _this3 = this;

      var backupTableName;
      attributes = this.attributesToSQL(attributes);

      if (_typeof(tableName) === "object") {
        backupTableName = {
          tableName: "".concat(tableName.tableName, "_backup"),
          schema: tableName.schema
        };
      } else {
        backupTableName = "".concat(tableName, "_backup");
      }

      var quotedTableName = this.quoteTable(tableName);
      var quotedBackupTableName = this.quoteTable(backupTableName);
      var attributeNames = Object.keys(attributes).map(function (attr) {
        return _this3.quoteIdentifier(attr);
      }).join(", ");
      return "".concat(createTableSql.replace("CREATE TABLE ".concat(quotedTableName), "CREATE TABLE ".concat(quotedBackupTableName)).replace("CREATE TABLE ".concat(quotedTableName.replace(/`/g, '"')), "CREATE TABLE ".concat(quotedBackupTableName)), "INSERT INTO ").concat(quotedBackupTableName, " SELECT ").concat(attributeNames, " FROM ").concat(quotedTableName, ";DROP TABLE ").concat(quotedTableName, ";ALTER TABLE ").concat(quotedBackupTableName, " RENAME TO ").concat(quotedTableName, ";");
    }
  }, {
    key: "renameColumnQuery",
    value: function renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {
      var _this4 = this;

      var backupTableName;
      attributes = this.attributesToSQL(attributes);

      if (_typeof(tableName) === "object") {
        backupTableName = {
          tableName: "".concat(tableName.tableName, "_backup"),
          schema: tableName.schema
        };
      } else {
        backupTableName = "".concat(tableName, "_backup");
      }

      var quotedTableName = this.quoteTable(tableName);
      var quotedBackupTableName = this.quoteTable(backupTableName);
      var attributeNamesImport = Object.keys(attributes).map(function (attr) {
        return attrNameAfter === attr ? "".concat(_this4.quoteIdentifier(attrNameBefore), " AS ").concat(_this4.quoteIdentifier(attr)) : _this4.quoteIdentifier(attr);
      }).join(", ");
      var attributeNamesExport = Object.keys(attributes).map(function (attr) {
        return _this4.quoteIdentifier(attr);
      }).join(", ");
      return "".concat(this.createTableQuery(backupTableName, attributes), "INSERT INTO ").concat(quotedBackupTableName, " SELECT ").concat(attributeNamesImport, " FROM ").concat(quotedTableName, ";DROP TABLE ").concat(quotedTableName, ";").concat(this.createTableQuery(tableName, attributes), "INSERT INTO ").concat(quotedTableName, " SELECT ").concat(attributeNamesExport, " FROM ").concat(quotedBackupTableName, ";DROP TABLE ").concat(quotedBackupTableName, ";");
    }
  }, {
    key: "startTransactionQuery",
    value: function startTransactionQuery(transaction) {
      if (transaction.parent) {
        return "SAVEPOINT ".concat(this.quoteIdentifier(transaction.name), ";");
      }

      return "BEGIN ".concat(transaction.options.type, " TRANSACTION;");
    }
  }, {
    key: "setIsolationLevelQuery",
    value: function setIsolationLevelQuery(value) {
      switch (value) {
        case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:
          return "-- SQLite is not able to choose the isolation level REPEATABLE READ.";

        case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:
          return "PRAGMA read_uncommitted = ON;";

        case Transaction.ISOLATION_LEVELS.READ_COMMITTED:
          return "PRAGMA read_uncommitted = OFF;";

        case Transaction.ISOLATION_LEVELS.SERIALIZABLE:
          return "-- SQLite's default isolation level is SERIALIZABLE. Nothing to do.";

        default:
          throw new Error("Unknown isolation level: ".concat(value));
      }
    }
  }, {
    key: "replaceBooleanDefaults",
    value: function replaceBooleanDefaults(sql) {
      return sql.replace(/DEFAULT '?false'?/g, "DEFAULT 0").replace(/DEFAULT '?true'?/g, "DEFAULT 1");
    }
  }, {
    key: "getForeignKeysQuery",
    value: function getForeignKeysQuery(tableName) {
      return "PRAGMA foreign_key_list(".concat(this.quoteTable(this.addSchema(tableName)), ")");
    }
  }, {
    key: "tableExistsQuery",
    value: function tableExistsQuery(tableName) {
      return "SELECT name FROM sqlite_master WHERE type='table' AND name=".concat(this.escape(this.addSchema(tableName)), ";");
    }
  }, {
    key: "quoteIdentifier",
    value: function quoteIdentifier(identifier, force) {
      return Utils.addTicks(Utils.removeTicks(identifier, "`"), "`");
    }
  }]);

  return SQLiteQueryGenerator;
}(MySqlQueryGenerator);

module.exports = SQLiteQueryGenerator;