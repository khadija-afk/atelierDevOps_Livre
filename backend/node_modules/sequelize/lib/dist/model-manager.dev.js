"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Toposort = require("toposort-class");

var _ = require("lodash");

var ModelManager =
/*#__PURE__*/
function () {
  function ModelManager(sequelize) {
    _classCallCheck(this, ModelManager);

    this.models = [];
    this.sequelize = sequelize;
  }

  _createClass(ModelManager, [{
    key: "addModel",
    value: function addModel(model) {
      this.models.push(model);
      this.sequelize.models[model.name] = model;
      return model;
    }
  }, {
    key: "removeModel",
    value: function removeModel(modelToRemove) {
      this.models = this.models.filter(function (model) {
        return model.name !== modelToRemove.name;
      });
      delete this.sequelize.models[modelToRemove.name];
    }
  }, {
    key: "getModel",
    value: function getModel(against, options) {
      options = _.defaults(options || {}, {
        attribute: "name"
      });
      return this.models.find(function (model) {
        return model[options.attribute] === against;
      });
    }
  }, {
    key: "findModel",
    value: function findModel(callback) {
      return this.models.find(callback);
    }
  }, {
    key: "getModelsTopoSortedByForeignKey",
    value: function getModelsTopoSortedByForeignKey() {
      var models =
      /* @__PURE__ */
      new Map();
      var sorter = new Toposort();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var model = _step.value;
          var deps = [];
          var tableName = model.getTableName();

          if (_.isObject(tableName)) {
            tableName = "".concat(tableName.schema, ".").concat(tableName.tableName);
          }

          models.set(tableName, model);

          for (var attrName in model.rawAttributes) {
            if (Object.prototype.hasOwnProperty.call(model.rawAttributes, attrName)) {
              var attribute = model.rawAttributes[attrName];

              if (attribute.references) {
                var dep = attribute.references.model;

                if (_.isObject(dep)) {
                  dep = "".concat(dep.schema, ".").concat(dep.tableName);
                }

                deps.push(dep);
              }
            }
          }

          deps = deps.filter(function (dep) {
            return tableName !== dep;
          });
          sorter.add(tableName, deps);
        };

        for (var _iterator = this.models[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var sorted;

      try {
        sorted = sorter.sort();
      } catch (e) {
        if (!e.message.startsWith("Cyclic dependency found.")) {
          throw e;
        }

        return null;
      }

      return sorted.map(function (modelName) {
        return models.get(modelName);
      }).filter(Boolean);
    }
  }, {
    key: "forEachModel",
    value: function forEachModel(iterator, options) {
      var sortedModels = this.getModelsTopoSortedByForeignKey();

      if (sortedModels == null) {
        throw new Error("Cyclic dependency found.");
      }

      options = _.defaults(options || {}, {
        reverse: true
      });

      if (options.reverse) {
        sortedModels.reverse();
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = sortedModels[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var model = _step2.value;
          iterator(model);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "all",
    get: function get() {
      return this.models;
    }
  }]);

  return ModelManager;
}();

module.exports = ModelManager;
module.exports.ModelManager = ModelManager;
module.exports["default"] = ModelManager;