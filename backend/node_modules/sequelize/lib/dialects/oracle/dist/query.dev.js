"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return a;
};

var __spreadProps = function __spreadProps(a, b) {
  return __defProps(a, __getOwnPropDescs(b));
};

var __markAsModule = function __markAsModule(target) {
  return __defProp(target, "__esModule", {
    value: true
  });
};

var __export = function __export(target, all) {
  __markAsModule(target);

  for (var name in all) {
    __defProp(target, name, {
      get: all[name],
      enumerable: true
    });
  }
};

__export(exports, {
  OracleQuery: function OracleQuery() {
    return _OracleQuery;
  }
});

var AbstractQuery = require("../abstract/query");

var SequelizeErrors = require("../../errors");

var parserStore = require("../parserStore")("oracle");

var _ = require("lodash");

var Utils = require("../../utils");

var _require = require("../../utils/logger"),
    logger = _require.logger;

var debug = logger.debugContext("sql:oracle");

var _OracleQuery =
/*#__PURE__*/
function (_AbstractQuery) {
  _inherits(_OracleQuery, _AbstractQuery);

  function _OracleQuery(connection, sequelize, options) {
    var _this;

    _classCallCheck(this, _OracleQuery);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(_OracleQuery).call(this, connection, sequelize, options));
    _this.options = _.extend({
      logging: console.log,
      plain: false,
      raw: false
    }, options || {});

    _this.checkLoggingOption();

    _this.outFormat = options.outFormat || _this.sequelize.connectionManager.lib.OBJECT;
    return _this;
  }

  _createClass(_OracleQuery, [{
    key: "getInsertIdField",
    value: function getInsertIdField() {
      return "id";
    }
  }, {
    key: "getExecOptions",
    value: function getExecOptions() {
      var execOpts = {
        outFormat: this.outFormat,
        autoCommit: this.autoCommit
      };
      var oracledb = this.sequelize.connectionManager.lib;

      if (this.model && this.isSelectQuery()) {
        var fInfo = {};
        var keys = Object.keys(this.model.tableAttributes);

        for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
          var key = _keys[_i];
          var keyValue = this.model.tableAttributes[key];

          if (keyValue.type.key === "DECIMAL") {
            fInfo[key] = {
              type: oracledb.STRING
            };
          }

          if (keyValue.type.key === "BIGINT") {
            fInfo[key] = {
              type: oracledb.STRING
            };
          }
        }

        if (fInfo) {
          execOpts.fetchInfo = fInfo;
        }
      }

      return execOpts;
    }
  }, {
    key: "_convertBindAttributes",
    value: function _convertBindAttributes(bindingDictionary, oracledb) {
      if (this.model && this.options[bindingDictionary]) {
        var keys = Object.keys(this.model.tableAttributes);

        for (var _i2 = 0, _keys2 = keys; _i2 < _keys2.length; _i2++) {
          var key = _keys2[_i2];
          var keyValue = this.model.tableAttributes[key];

          if (keyValue.type.key === "BIGINT") {
            var oldBinding = this.options[bindingDictionary][key];

            if (oldBinding) {
              this.options[bindingDictionary][key] = __spreadProps(__spreadValues({}, oldBinding), {
                type: oracledb.STRING,
                maxSize: 1e7
              });
            }
          }
        }
      }
    }
  }, {
    key: "run",
    value: function run(sql, parameters) {
      var oracledb, complete, outParameters, bindParameters, bindDef, result, execOpts, executePromise, _result2;

      return regeneratorRuntime.async(function run$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              oracledb = this.sequelize.connectionManager.lib;
              complete = this._logQuery(sql, debug, parameters);
              outParameters = [];
              bindParameters = [];
              bindDef = [];

              if (!sql.match(/END;$/)) {
                this.sql = sql.replace(/; *$/, "");
              } else {
                this.sql = sql;
              }

              if (this.options.outBindAttributes && (Array.isArray(parameters) || _.isPlainObject(parameters))) {
                this._convertBindAttributes("outBindAttributes", oracledb);

                outParameters.push.apply(outParameters, _toConsumableArray(Object.values(this.options.outBindAttributes)));

                if (this.isUpsertQuery()) {
                  outParameters.push({
                    dir: oracledb.BIND_OUT
                  });
                }
              }

              this.bindParameters = outParameters;

              if (Array.isArray(parameters) || _.isPlainObject(parameters)) {
                if (this.options.executeMany) {
                  this._convertBindAttributes("inbindAttributes", oracledb);

                  bindDef.push.apply(bindDef, _toConsumableArray(Object.values(this.options.inbindAttributes)));
                  bindDef.push.apply(bindDef, outParameters);
                  this.bindParameters = parameters;
                } else if (this.isRawQuery()) {
                  this.bindParameters = parameters;
                } else {
                  Object.values(parameters).forEach(function (value) {
                    bindParameters.push(value);
                  });
                  bindParameters.push.apply(bindParameters, outParameters);
                  Object.assign(this.bindParameters, bindParameters);
                }
              }

              if (!this.sql.startsWith("BEGIN TRANSACTION")) {
                _context.next = 12;
                break;
              }

              this.autocommit = false;
              return _context.abrupt("return", Promise.resolve());

            case 12:
              if (!this.sql.startsWith("SET AUTOCOMMIT ON")) {
                _context.next = 15;
                break;
              }

              this.autocommit = true;
              return _context.abrupt("return", Promise.resolve());

            case 15:
              if (!this.sql.startsWith("SET AUTOCOMMIT OFF")) {
                _context.next = 18;
                break;
              }

              this.autocommit = false;
              return _context.abrupt("return", Promise.resolve());

            case 18:
              if (!this.sql.startsWith("DECLARE x NUMBER")) {
                _context.next = 32;
                break;
              }

              if (this.autoCommit === void 0) {
                if (this.connection.uuid) {
                  this.autoCommit = false;
                } else {
                  this.autoCommit = true;
                }
              }

              _context.prev = 20;
              _context.next = 23;
              return regeneratorRuntime.awrap(this.connection.execute(this.sql, this.bindParameters, {
                autoCommit: this.autoCommit
              }));

            case 23:
              return _context.abrupt("return", Object.create(null));

            case 26:
              _context.prev = 26;
              _context.t0 = _context["catch"](20);
              throw this.formatError(_context.t0);

            case 29:
              _context.prev = 29;
              complete();
              return _context.finish(29);

            case 32:
              if (!this.sql.startsWith("BEGIN")) {
                _context.next = 49;
                break;
              }

              if (this.autoCommit === void 0) {
                if (this.connection.uuid) {
                  this.autoCommit = false;
                } else {
                  this.autoCommit = true;
                }
              }

              _context.prev = 34;
              _context.next = 37;
              return regeneratorRuntime.awrap(this.connection.execute(this.sql, this.bindParameters, {
                outFormat: this.outFormat,
                autoCommit: this.autoCommit
              }));

            case 37:
              result = _context.sent;

              if (Array.isArray(result.outBinds)) {
                _context.next = 40;
                break;
              }

              return _context.abrupt("return", [result.outBinds]);

            case 40:
              return _context.abrupt("return", result.outBinds);

            case 43:
              _context.prev = 43;
              _context.t1 = _context["catch"](34);
              throw this.formatError(_context.t1);

            case 46:
              _context.prev = 46;
              complete();
              return _context.finish(46);

            case 49:
              if (!this.sql.startsWith("COMMIT TRANSACTION")) {
                _context.next = 62;
                break;
              }

              _context.prev = 50;
              _context.next = 53;
              return regeneratorRuntime.awrap(this.connection.commit());

            case 53:
              return _context.abrupt("return", Object.create(null));

            case 56:
              _context.prev = 56;
              _context.t2 = _context["catch"](50);
              throw this.formatError(_context.t2);

            case 59:
              _context.prev = 59;
              complete();
              return _context.finish(59);

            case 62:
              if (!this.sql.startsWith("ROLLBACK TRANSACTION")) {
                _context.next = 75;
                break;
              }

              _context.prev = 63;
              _context.next = 66;
              return regeneratorRuntime.awrap(this.connection.rollback());

            case 66:
              return _context.abrupt("return", Object.create(null));

            case 69:
              _context.prev = 69;
              _context.t3 = _context["catch"](63);
              throw this.formatError(_context.t3);

            case 72:
              _context.prev = 72;
              complete();
              return _context.finish(72);

            case 75:
              if (!this.sql.startsWith("SET TRANSACTION")) {
                _context.next = 88;
                break;
              }

              _context.prev = 76;
              _context.next = 79;
              return regeneratorRuntime.awrap(this.connection.execute(this.sql, [], {
                autoCommit: false
              }));

            case 79:
              return _context.abrupt("return", Object.create(null));

            case 82:
              _context.prev = 82;
              _context.t4 = _context["catch"](76);
              throw this.formatError(_context.t4);

            case 85:
              _context.prev = 85;
              complete();
              return _context.finish(85);

            case 88:
              if (this.autoCommit === void 0) {
                if (this.connection.uuid) {
                  this.autoCommit = false;
                } else {
                  this.autoCommit = true;
                }
              }

              if ("inputParameters" in this.options && this.options.inputParameters !== null) {
                Object.assign(this.bindParameters, this.options.inputParameters);
              }

              execOpts = this.getExecOptions();

              if (this.options.executeMany && bindDef.length > 0) {
                execOpts.bindDefs = bindDef;
              }

              executePromise = this.options.executeMany ? this.connection.executeMany(this.sql, this.bindParameters, execOpts) : this.connection.execute(this.sql, this.bindParameters, execOpts);
              _context.prev = 93;
              _context.next = 96;
              return regeneratorRuntime.awrap(executePromise);

            case 96:
              _result2 = _context.sent;
              return _context.abrupt("return", this.formatResults(_result2));

            case 100:
              _context.prev = 100;
              _context.t5 = _context["catch"](93);
              throw this.formatError(_context.t5);

            case 103:
              _context.prev = 103;
              complete();
              return _context.finish(103);

            case 106:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[20, 26, 29, 32], [34, 43, 46, 49], [50, 56, 59, 62], [63, 69, 72, 75], [76, 82, 85, 88], [93, 100, 103, 106]]);
    }
  }, {
    key: "_getAttributeMap",
    value: function _getAttributeMap(attrsMap, rawAttributes) {
      var _this2 = this;

      attrsMap = Object.assign(attrsMap, _.reduce(rawAttributes, function (mp, _2, key) {
        var catalogKey = _this2.sequelize.queryInterface.queryGenerator.getCatalogName(key);

        mp[catalogKey] = key;
        return mp;
      }, {}));
    }
  }, {
    key: "_processRows",
    value: function _processRows(rows) {
      var _this3 = this;

      var result = rows;
      var attrsMap = {};

      if (this.sequelize.options.quoteIdentifiers === false) {
        attrsMap = _.reduce(this.options.attributes, function (mp, v) {
          if (_typeof(v) === "object") {
            v = v[1];
          }

          var catalogv = _this3.sequelize.queryInterface.queryGenerator.getCatalogName(v);

          mp[catalogv] = v;
          return mp;
        }, {});

        if (this.model) {
          this._getAttributeMap(attrsMap, this.model.rawAttributes);
        }

        if (this.options.aliasesMapping) {
          var obj = Object.fromEntries(this.options.aliasesMapping);
          rows = rows.map(function (row) {
            return _.toPairs(row).reduce(function (acc, _ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                  key = _ref2[0],
                  value = _ref2[1];

              var mapping = Object.values(obj).find(function (element) {
                var catalogElement = _this3.sequelize.queryInterface.queryGenerator.getCatalogName(element);

                return catalogElement === key;
              });
              if (mapping) acc[mapping || key] = value;
              return acc;
            }, {});
          });
        }

        result = rows.map(function (row) {
          return _.mapKeys(row, function (value, key) {
            var targetAttr = attrsMap[key];

            if (typeof targetAttr === "string" && targetAttr !== key) {
              return targetAttr;
            }

            return key;
          });
        });
      }

      if (this.model) {
        result = result.map(function (row) {
          return _.mapValues(row, function (value, key) {
            if (_this3.model.rawAttributes[key] && _this3.model.rawAttributes[key].type) {
              var typeid = _this3.model.rawAttributes[key].type.toLocaleString();

              if (_this3.model.rawAttributes[key].type.key === "JSON") {
                value = JSON.parse(value);
              }

              if (typeid.indexOf("(") > -1 && _this3.model.rawAttributes[key].type.key !== "BOOLEAN") {
                typeid = typeid.substr(0, typeid.indexOf("("));
              }

              var parse = parserStore.get(typeid);

              if (value !== null & !!parse) {
                value = parse(value);
              }
            }

            return value;
          });
        });
      }

      return result;
    }
  }, {
    key: "formatResults",
    value: function formatResults(data) {
      var result = this.instance;

      if (this.isInsertQuery(data)) {
        var insertData;

        if (data.outBinds) {
          var keys = Object.keys(this.options.outBindAttributes);
          insertData = data.outBinds;

          if (this.instance) {
            insertData = [insertData];
          }

          var res = insertData.map(function (row) {
            var obj = {};
            row.forEach(function (element, index) {
              obj[keys[index]] = element[0];
            });
            return obj;
          });
          insertData = res;

          if (!this.instance) {
            result = res;
          }
        }

        this.handleInsertQuery(insertData);
        return [result, data.rowsAffected];
      }

      if (this.isShowTablesQuery()) {
        result = this.handleShowTablesQuery(data.rows);
      } else if (this.isDescribeQuery()) {
        result = {};
        var table = Object.keys(this.sequelize.models);
        var modelAttributes = {};

        if (this.sequelize.models && table.length > 0) {
          this._getAttributeMap(modelAttributes, this.sequelize.models[table[0]].rawAttributes);
        }

        data.rows.forEach(function (_result) {
          if (_result.Default) {
            _result.Default = _result.Default.replace("('", "").replace("')", "").replace(/'/g, "");
          }

          if (!(modelAttributes[_result.COLUMN_NAME] in result)) {
            var key = modelAttributes[_result.COLUMN_NAME];

            if (!key) {
              key = _result.COLUMN_NAME;
            }

            result[key] = {
              type: _result.DATA_TYPE.toUpperCase(),
              allowNull: _result.NULLABLE === "N" ? false : true,
              defaultValue: void 0,
              primaryKey: _result.CONSTRAINT_TYPE === "P"
            };
          }
        });
      } else if (this.isShowIndexesQuery()) {
        result = this.handleShowIndexesQuery(data.rows);
      } else if (this.isSelectQuery()) {
        var rows = data.rows;

        var result2 = this._processRows(rows);

        return this.handleSelectQuery(result2);
      } else if (this.isCallQuery()) {
        result = data.rows[0];
      } else if (this.isUpdateQuery()) {
        result = [result, data.rowsAffected];
      } else if (this.isBulkUpdateQuery()) {
        result = data.rowsAffected;
      } else if (this.isBulkDeleteQuery()) {
        result = data.rowsAffected;
      } else if (this.isVersionQuery()) {
        var version = data.rows[0].VERSION_FULL;

        if (version) {
          var versions = version.split(".");
          result = "".concat(versions[0], ".").concat(versions[1], ".").concat(versions[2]);
        } else {
          result = "0.0.0";
        }
      } else if (this.isForeignKeysQuery()) {
        result = data.rows;
      } else if (this.isUpsertQuery()) {
        data = data.outBinds;

        var _keys3 = Object.keys(this.options.outBindAttributes);

        var obj = {};

        for (var k in _keys3) {
          obj[_keys3[k]] = data[k];
        }

        obj.isUpdate = data[data.length - 1];
        data = obj;
        result = [{
          isNewRecord: data.isUpdate,
          value: data
        }, data.isUpdate == 0];
      } else if (this.isShowConstraintsQuery()) {
        result = this.handleShowConstraintsQuery(data);
      } else if (this.isRawQuery()) {
        if (data && data.rows) {
          return [data.rows, data.metaData];
        }

        return [data, data];
      }

      return result;
    }
  }, {
    key: "handleShowConstraintsQuery",
    value: function handleShowConstraintsQuery(data) {
      return data.rows.map(function (result) {
        var constraint = {};

        for (var key in result) {
          constraint[_.camelCase(key)] = result[key].toLowerCase();
        }

        return constraint;
      });
    }
  }, {
    key: "handleShowTablesQuery",
    value: function handleShowTablesQuery(results) {
      return results.map(function (resultSet) {
        return {
          tableName: resultSet.TABLE_NAME,
          schema: resultSet.TABLE_SCHEMA
        };
      });
    }
  }, {
    key: "formatError",
    value: function formatError(err) {
      var _this4 = this;

      var match;
      match = err.message.match(/unique constraint ([\s\S]*) violated/);

      if (match && match.length > 1) {
        match[1] = match[1].replace("(", "").replace(")", "").split(".")[1];
        var errors = [];
        var fields = [],
            message = "Validation error",
            uniqueKey = null;

        if (this.model) {
          var uniqueKeys = Object.keys(this.model.uniqueKeys);
          var currKey = uniqueKeys.find(function (key) {
            return key.toUpperCase() === match[1].toUpperCase() || key.toUpperCase() === "\"".concat(match[1].toUpperCase(), "\"");
          });

          if (currKey) {
            uniqueKey = this.model.uniqueKeys[currKey];
            fields = uniqueKey.fields;
          }

          if (uniqueKey && !!uniqueKey.msg) {
            message = uniqueKey.msg;
          }

          fields.forEach(function (field) {
            errors.push(new SequelizeErrors.ValidationErrorItem(_this4.getUniqueConstraintErrorMessage(field), "unique violation", field, null));
          });
        }

        return new SequelizeErrors.UniqueConstraintError({
          message: message,
          errors: errors,
          err: err,
          fields: fields
        });
      }

      match = err.message.match(/ORA-02291/) || err.message.match(/ORA-02292/);

      if (match && match.length > 0) {
        return new SequelizeErrors.ForeignKeyConstraintError({
          fields: null,
          index: match[1],
          parent: err
        });
      }

      match = err.message.match(/ORA-02443/);

      if (match && match.length > 0) {
        return new SequelizeErrors.UnknownConstraintError(match[1]);
      }

      return new SequelizeErrors.DatabaseError(err);
    }
  }, {
    key: "isShowIndexesQuery",
    value: function isShowIndexesQuery() {
      return this.sql.indexOf("SELECT i.index_name,i.table_name, i.column_name, u.uniqueness") > -1;
    }
  }, {
    key: "isSelectCountQuery",
    value: function isSelectCountQuery() {
      return this.sql.toUpperCase().indexOf("SELECT COUNT(") > -1;
    }
  }, {
    key: "handleShowIndexesQuery",
    value: function handleShowIndexesQuery(data) {
      var acc = [];
      data.forEach(function (indexRecord) {
        if (!acc[indexRecord.INDEX_NAME]) {
          acc[indexRecord.INDEX_NAME] = {
            unique: indexRecord.UNIQUENESS === "UNIQUE" ? true : false,
            primary: indexRecord.CONSTRAINT_TYPE === "P",
            name: indexRecord.INDEX_NAME.toLowerCase(),
            tableName: indexRecord.TABLE_NAME.toLowerCase(),
            type: void 0
          };
          acc[indexRecord.INDEX_NAME].fields = [];
        }

        acc[indexRecord.INDEX_NAME].fields.push({
          attribute: indexRecord.COLUMN_NAME,
          length: void 0,
          order: indexRecord.DESCEND,
          collate: void 0
        });
      });
      var returnIndexes = [];
      var accKeys = Object.keys(acc);

      for (var _i3 = 0, _accKeys = accKeys; _i3 < _accKeys.length; _i3++) {
        var accKey = _accKeys[_i3];
        var columns = {};
        columns.fields = acc[accKey].fields;

        if (acc[accKey].name.match(/sys_c[0-9]*/)) {
          acc[accKey].name = Utils.nameIndex(columns, acc[accKey].tableName).name;
        }

        returnIndexes.push(acc[accKey]);
      }

      return returnIndexes;
    }
  }, {
    key: "handleInsertQuery",
    value: function handleInsertQuery(results, metaData) {
      if (this.instance && results.length > 0) {
        if ("pkReturnVal" in results[0]) {
          results[0][this.model.primaryKeyAttribute] = results[0].pkReturnVal;
          delete results[0].pkReturnVal;
        }

        var autoIncrementField = this.model.autoIncrementAttribute;
        var autoIncrementFieldAlias = null,
            id = null;
        if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementField) && this.model.rawAttributes[autoIncrementField].field !== void 0) autoIncrementFieldAlias = this.model.rawAttributes[autoIncrementField].field;
        id = id || results && results[0][this.getInsertIdField()];
        id = id || metaData && metaData[this.getInsertIdField()];
        id = id || results && results[0][autoIncrementField];
        id = id || autoIncrementFieldAlias && results && results[0][autoIncrementFieldAlias];
        this.instance[autoIncrementField] = id;
      }
    }
  }], [{
    key: "formatBindParameters",
    value: function formatBindParameters(sql, values, dialect) {
      var replacementFunc = function replacementFunc(match, key, values2) {
        if (values2[key] !== void 0) {
          return ":".concat(key);
        }

        return void 0;
      };

      sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
      return [sql, values];
    }
  }]);

  return _OracleQuery;
}(AbstractQuery);