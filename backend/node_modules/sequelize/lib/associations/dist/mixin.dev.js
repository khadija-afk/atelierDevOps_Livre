"use strict";

var _ = require("lodash");

var HasOne = require("./has-one");

var HasMany = require("./has-many");

var BelongsToMany = require("./belongs-to-many");

var BelongsTo = require("./belongs-to");

function isModel(model, sequelize) {
  return model && model.prototype && model.prototype instanceof sequelize.Sequelize.Model;
}

var Mixin = {
  hasMany: function hasMany(target) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!isModel(target, this.sequelize)) {
      throw new Error("".concat(this.name, ".hasMany called with something that's not a subclass of Sequelize.Model"));
    }

    var source = this;
    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);
    options.useHooks = options.hooks;
    Object.assign(options, _.omit(source.options, ["hooks"]));

    if (options.useHooks) {
      this.runHooks("beforeAssociate", {
        source: source,
        target: target,
        type: HasMany
      }, options);
    }

    var association = new HasMany(source, target, options);
    source.associations[association.associationAccessor] = association;

    association._injectAttributes();

    association.mixin(source.prototype);

    if (options.useHooks) {
      this.runHooks("afterAssociate", {
        source: source,
        target: target,
        type: HasMany,
        association: association
      }, options);
    }

    return association;
  },
  belongsToMany: function belongsToMany(target) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!isModel(target, this.sequelize)) {
      throw new Error("".concat(this.name, ".belongsToMany called with something that's not a subclass of Sequelize.Model"));
    }

    var source = this;
    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);
    options.useHooks = options.hooks;
    options.timestamps = options.timestamps === void 0 ? this.sequelize.options.timestamps : options.timestamps;
    Object.assign(options, _.omit(source.options, ["hooks", "timestamps", "scopes", "defaultScope"]));

    if (options.useHooks) {
      this.runHooks("beforeAssociate", {
        source: source,
        target: target,
        type: BelongsToMany
      }, options);
    }

    var association = new BelongsToMany(source, target, options);
    source.associations[association.associationAccessor] = association;

    association._injectAttributes();

    association.mixin(source.prototype);

    if (options.useHooks) {
      this.runHooks("afterAssociate", {
        source: source,
        target: target,
        type: BelongsToMany,
        association: association
      }, options);
    }

    return association;
  },
  getAssociations: function getAssociations(target) {
    return Object.values(this.associations).filter(function (association) {
      return association.target.name === target.name;
    });
  },
  getAssociationForAlias: function getAssociationForAlias(target, alias) {
    return this.getAssociations(target).find(function (association) {
      return association.verifyAssociationAlias(alias);
    }) || null;
  }
};

function singleLinked(Type) {
  return function (target) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var source = this;

    if (!isModel(target, source.sequelize)) {
      throw new Error("".concat(source.name, ".").concat(_.lowerFirst(Type.name), " called with something that's not a subclass of Sequelize.Model"));
    }

    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);
    options.useHooks = options.hooks;

    if (options.useHooks) {
      source.runHooks("beforeAssociate", {
        source: source,
        target: target,
        type: Type
      }, options);
    }

    var association = new Type(source, target, Object.assign(options, source.options));
    source.associations[association.associationAccessor] = association;

    association._injectAttributes();

    association.mixin(source.prototype);

    if (options.useHooks) {
      source.runHooks("afterAssociate", {
        source: source,
        target: target,
        type: Type,
        association: association
      }, options);
    }

    return association;
  };
}

Mixin.hasOne = singleLinked(HasOne);
Mixin.belongsTo = singleLinked(BelongsTo);
module.exports = Mixin;
module.exports.Mixin = Mixin;
module.exports["default"] = Mixin;