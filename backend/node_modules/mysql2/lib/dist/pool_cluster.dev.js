'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var process = require('process');

var Pool = require('./pool.js');

var PoolConfig = require('./pool_config.js');

var Connection = require('./connection.js');

var EventEmitter = require('events').EventEmitter;
/**
 * Selector
 */


var makeSelector = {
  RR: function RR() {
    var index = 0;
    return function (clusterIds) {
      return clusterIds[index++ % clusterIds.length];
    };
  },
  RANDOM: function RANDOM() {
    return function (clusterIds) {
      return clusterIds[Math.floor(Math.random() * clusterIds.length)];
    };
  },
  ORDER: function ORDER() {
    return function (clusterIds) {
      return clusterIds[0];
    };
  }
};

var PoolNamespace =
/*#__PURE__*/
function () {
  function PoolNamespace(cluster, pattern, selector) {
    _classCallCheck(this, PoolNamespace);

    this._cluster = cluster;
    this._pattern = pattern;
    this._selector = makeSelector[selector]();
  }

  _createClass(PoolNamespace, [{
    key: "getConnection",
    value: function getConnection(cb) {
      var _this = this;

      var clusterNode = this._getClusterNode();

      if (clusterNode === null) {
        return cb(new Error('Pool does Not exists.'));
      }

      return this._cluster._getConnection(clusterNode, function (err, connection) {
        if (err) {
          return cb(err);
        }

        if (connection === 'retry') {
          return _this.getConnection(cb);
        }

        return cb(null, connection);
      });
    }
    /**
     * pool cluster query
     * @param {*} sql
     * @param {*} values
     * @param {*} cb
     * @returns query
     */

  }, {
    key: "query",
    value: function query(sql, values, cb) {
      var query = Connection.createQuery(sql, values, cb, {});
      this.getConnection(function (err, conn) {
        if (err) {
          if (typeof query.onResult === 'function') {
            query.onResult(err);
          } else {
            query.emit('error', err);
          }

          return;
        }

        try {
          conn.query(query).once('end', function () {
            conn.release();
          });
        } catch (e) {
          conn.release();
          throw e;
        }
      });
      return query;
    }
    /**
     * pool cluster execute
     * @param {*} sql 
     * @param {*} values 
     * @param {*} cb 
     */

  }, {
    key: "execute",
    value: function execute(sql, values, cb) {
      if (typeof values === 'function') {
        cb = values;
        values = [];
      }

      this.getConnection(function (err, conn) {
        if (err) {
          return cb(err);
        }

        try {
          conn.execute(sql, values, cb).once('end', function () {
            conn.release();
          });
        } catch (e) {
          conn.release();
          throw e;
        }
      });
    }
  }, {
    key: "_getClusterNode",
    value: function _getClusterNode() {
      var foundNodeIds = this._cluster._findNodeIds(this._pattern);

      if (foundNodeIds.length === 0) {
        return null;
      }

      var nodeId = foundNodeIds.length === 1 ? foundNodeIds[0] : this._selector(foundNodeIds);
      return this._cluster._getNode(nodeId);
    }
  }]);

  return PoolNamespace;
}();

var PoolCluster =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(PoolCluster, _EventEmitter);

  function PoolCluster(config) {
    var _this2;

    _classCallCheck(this, PoolCluster);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(PoolCluster).call(this));
    config = config || {};
    _this2._canRetry = typeof config.canRetry === 'undefined' ? true : config.canRetry;
    _this2._removeNodeErrorCount = config.removeNodeErrorCount || 5;
    _this2._defaultSelector = config.defaultSelector || 'RR';
    _this2._closed = false;
    _this2._lastId = 0;
    _this2._nodes = {};
    _this2._serviceableNodeIds = [];
    _this2._namespaces = {};
    _this2._findCaches = {};
    return _this2;
  }

  _createClass(PoolCluster, [{
    key: "of",
    value: function of(pattern, selector) {
      pattern = pattern || '*';
      selector = selector || this._defaultSelector;
      selector = selector.toUpperCase();

      if (!makeSelector[selector] === 'undefined') {
        selector = this._defaultSelector;
      }

      var key = pattern + selector;

      if (typeof this._namespaces[key] === 'undefined') {
        this._namespaces[key] = new PoolNamespace(this, pattern, selector);
      }

      return this._namespaces[key];
    }
  }, {
    key: "add",
    value: function add(id, config) {
      if (_typeof(id) === 'object') {
        config = id;
        id = "CLUSTER::".concat(++this._lastId);
      }

      if (typeof this._nodes[id] === 'undefined') {
        this._nodes[id] = {
          id: id,
          errorCount: 0,
          pool: new Pool({
            config: new PoolConfig(config)
          })
        };

        this._serviceableNodeIds.push(id);

        this._clearFindCaches();
      }
    }
  }, {
    key: "getConnection",
    value: function getConnection(pattern, selector, cb) {
      var namespace;

      if (typeof pattern === 'function') {
        cb = pattern;
        namespace = this.of();
      } else {
        if (typeof selector === 'function') {
          cb = selector;
          selector = this._defaultSelector;
        }

        namespace = this.of(pattern, selector);
      }

      namespace.getConnection(cb);
    }
  }, {
    key: "end",
    value: function end(callback) {
      var cb = callback !== undefined ? callback : function (err) {
        if (err) {
          throw err;
        }
      };

      if (this._closed) {
        process.nextTick(cb);
        return;
      }

      this._closed = true;
      var calledBack = false;
      var waitingClose = 0;

      var onEnd = function onEnd(err) {
        if (!calledBack && (err || --waitingClose <= 0)) {
          calledBack = true;
          return cb(err);
        }
      };

      for (var id in this._nodes) {
        waitingClose++;

        this._nodes[id].pool.end(onEnd);
      }

      if (waitingClose === 0) {
        process.nextTick(onEnd);
      }
    }
  }, {
    key: "_findNodeIds",
    value: function _findNodeIds(pattern) {
      if (typeof this._findCaches[pattern] !== 'undefined') {
        return this._findCaches[pattern];
      }

      var foundNodeIds;

      if (pattern === '*') {
        // all
        foundNodeIds = this._serviceableNodeIds;
      } else if (this._serviceableNodeIds.indexOf(pattern) !== -1) {
        // one
        foundNodeIds = [pattern];
      } else {
        // wild matching
        var keyword = pattern.substring(pattern.length - 1, 0);
        foundNodeIds = this._serviceableNodeIds.filter(function (id) {
          return id.startsWith(keyword);
        });
      }

      this._findCaches[pattern] = foundNodeIds;
      return foundNodeIds;
    }
  }, {
    key: "_getNode",
    value: function _getNode(id) {
      return this._nodes[id] || null;
    }
  }, {
    key: "_increaseErrorCount",
    value: function _increaseErrorCount(node) {
      if (++node.errorCount >= this._removeNodeErrorCount) {
        var index = this._serviceableNodeIds.indexOf(node.id);

        if (index !== -1) {
          this._serviceableNodeIds.splice(index, 1);

          delete this._nodes[node.id];

          this._clearFindCaches();

          node.pool.end();
          this.emit('remove', node.id);
        }
      }
    }
  }, {
    key: "_decreaseErrorCount",
    value: function _decreaseErrorCount(node) {
      if (node.errorCount > 0) {
        --node.errorCount;
      }
    }
  }, {
    key: "_getConnection",
    value: function _getConnection(node, cb) {
      var _this3 = this;

      node.pool.getConnection(function (err, connection) {
        if (err) {
          _this3._increaseErrorCount(node);

          if (_this3._canRetry) {
            // REVIEW: this seems wrong?
            _this3.emit('warn', err); // eslint-disable-next-line no-console


            console.warn("[Error] PoolCluster : ".concat(err));
            return cb(null, 'retry');
          }

          return cb(err);
        }

        _this3._decreaseErrorCount(node);

        connection._clusterId = node.id;
        return cb(null, connection);
      });
    }
  }, {
    key: "_clearFindCaches",
    value: function _clearFindCaches() {
      this._findCaches = {};
    }
  }]);

  return PoolCluster;
}(EventEmitter);

module.exports = PoolCluster;