"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return a;
};

var __spreadProps = function __spreadProps(a, b) {
  return __defProps(a, __getOwnPropDescs(b));
};

var util = require("util");

var _ = require("lodash");

var uuidv4 = require("uuid").v4;

var Utils = require("../../utils");

var deprecations = require("../../utils/deprecations");

var SqlString = require("../../sql-string");

var DataTypes = require("../../data-types");

var Model = require("../../model");

var Association = require("../../associations/base");

var BelongsTo = require("../../associations/belongs-to");

var BelongsToMany = require("../../associations/belongs-to-many");

var HasMany = require("../../associations/has-many");

var Op = require("../../operators");

var sequelizeError = require("../../errors");

var IndexHints = require("../../index-hints");

var QueryGenerator =
/*#__PURE__*/
function () {
  function QueryGenerator(options) {
    _classCallCheck(this, QueryGenerator);

    if (!options.sequelize) throw new Error("QueryGenerator initialized without options.sequelize");
    if (!options._dialect) throw new Error("QueryGenerator initialized without options._dialect");
    this.sequelize = options.sequelize;
    this.options = options.sequelize.options;
    this.dialect = options._dialect.name;
    this._dialect = options._dialect;

    this._initQuoteIdentifier();
  }

  _createClass(QueryGenerator, [{
    key: "extractTableDetails",
    value: function extractTableDetails(tableName, options) {
      options = options || {};
      tableName = tableName || {};
      return {
        schema: tableName.schema || options.schema || this.options.schema || "public",
        tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,
        delimiter: tableName.delimiter || options.delimiter || "."
      };
    }
  }, {
    key: "addSchema",
    value: function addSchema(param) {
      if (!param._schema) return param.tableName || param;
      var self = this;
      return {
        tableName: param.tableName || param,
        table: param.tableName || param,
        name: param.name || param,
        schema: param._schema,
        delimiter: param._schemaDelimiter || ".",
        toString: function toString() {
          return self.quoteTable(this);
        }
      };
    }
  }, {
    key: "dropSchema",
    value: function dropSchema(tableName, options) {
      return this.dropTableQuery(tableName, options);
    }
  }, {
    key: "describeTableQuery",
    value: function describeTableQuery(tableName, schema, schemaDelimiter) {
      var table = this.quoteTable(this.addSchema({
        tableName: tableName,
        _schema: schema,
        _schemaDelimiter: schemaDelimiter
      }));
      return "DESCRIBE ".concat(table, ";");
    }
  }, {
    key: "dropTableQuery",
    value: function dropTableQuery(tableName) {
      return "DROP TABLE IF EXISTS ".concat(this.quoteTable(tableName), ";");
    }
  }, {
    key: "renameTableQuery",
    value: function renameTableQuery(before, after) {
      return "ALTER TABLE ".concat(this.quoteTable(before), " RENAME TO ").concat(this.quoteTable(after), ";");
    }
  }, {
    key: "populateInsertQueryReturnIntoBinds",
    value: function populateInsertQueryReturnIntoBinds() {}
  }, {
    key: "insertQuery",
    value: function insertQuery(table, valueHash, modelAttributes, options) {
      var _this = this;

      options = options || {};

      _.defaults(options, this.options);

      var modelAttributeMap = {};
      var bind = options.bind || [];
      var fields = [];
      var returningModelAttributes = [];
      var returnTypes = [];
      var values = [];
      var quotedTable = this.quoteTable(table);
      var bindParam = options.bindParam === void 0 ? this.bindParam(bind) : options.bindParam;
      var returnAttributes = [];
      var query;
      var valueQuery = "";
      var emptyQuery = "";
      var outputFragment = "";
      var returningFragment = "";
      var identityWrapperRequired = false;
      var tmpTable = "";

      if (modelAttributes) {
        _.each(modelAttributes, function (attribute, key) {
          modelAttributeMap[key] = attribute;

          if (attribute.field) {
            modelAttributeMap[attribute.field] = attribute;
          }
        });
      }

      if (this._dialect.supports["DEFAULT VALUES"]) {
        emptyQuery += " DEFAULT VALUES";
      } else if (this._dialect.supports["VALUES ()"]) {
        emptyQuery += " VALUES ()";
      }

      if ((this._dialect.supports.returnValues || this._dialect.supports.returnIntoValues) && options.returning) {
        var returnValues = this.generateReturnValues(modelAttributes, options);
        returningModelAttributes.push.apply(returningModelAttributes, _toConsumableArray(returnValues.returnFields));

        if (this._dialect.supports.returnIntoValues) {
          returnTypes.push.apply(returnTypes, _toConsumableArray(returnValues.returnTypes));
        }

        returningFragment = returnValues.returningFragment;
        tmpTable = returnValues.tmpTable || "";
        outputFragment = returnValues.outputFragment || "";
      }

      if (_.get(this, ["sequelize", "options", "dialectOptions", "prependSearchPath"]) || options.searchPath) {
        options.bindParam = false;
      }

      if (this._dialect.supports.EXCEPTION && options.exception) {
        options.bindParam = false;
      }

      valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);

      for (var key in valueHash) {
        if (Object.prototype.hasOwnProperty.call(valueHash, key)) {
          var value = valueHash[key];
          fields.push(this.quoteIdentifier(key));

          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && value == null) {
            if (!this._dialect.supports.autoIncrement.defaultValue) {
              fields.splice(-1, 1);
            } else if (this._dialect.supports.DEFAULT) {
              values.push("DEFAULT");
            } else {
              values.push(this.escape(null));
            }
          } else {
            if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {
              identityWrapperRequired = true;
            }

            if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
              values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
                context: "INSERT"
              }));
            } else {
              values.push(this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
                context: "INSERT"
              }, bindParam));
            }
          }
        }
      }

      var onDuplicateKeyUpdate = "";

      if (!_.isEmpty(options.conflictWhere) && !this._dialect.supports.inserts.onConflictWhere) {
        throw new Error("missing dialect support for conflictWhere option");
      }

      if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {
        if (this._dialect.supports.inserts.updateOnDuplicate == " ON CONFLICT DO UPDATE SET") {
          var conflictKeys = options.upsertKeys.map(function (attr) {
            return _this.quoteIdentifier(attr);
          });
          var updateKeys = options.updateOnDuplicate.map(function (attr) {
            return "".concat(_this.quoteIdentifier(attr), "=EXCLUDED.").concat(_this.quoteIdentifier(attr));
          });
          var fragments = ["ON CONFLICT", "(", conflictKeys.join(","), ")"];

          if (!_.isEmpty(options.conflictWhere)) {
            fragments.push(this.whereQuery(options.conflictWhere, options));
          }

          if (_.isEmpty(updateKeys)) {
            fragments.push("DO NOTHING");
          } else {
            fragments.push("DO UPDATE SET", updateKeys.join(","));
          }

          onDuplicateKeyUpdate = " ".concat(Utils.joinSQLFragments(fragments));
        } else {
          var valueKeys = options.updateOnDuplicate.map(function (attr) {
            return "".concat(_this.quoteIdentifier(attr), "=VALUES(").concat(_this.quoteIdentifier(attr), ")");
          });

          if (_.isEmpty(valueKeys) && options.upsertKeys) {
            valueKeys.push.apply(valueKeys, _toConsumableArray(options.upsertKeys.map(function (attr) {
              return "".concat(_this.quoteIdentifier(attr), "=").concat(_this.quoteIdentifier(attr));
            })));
          }

          if (_.isEmpty(valueKeys)) {
            throw new Error("No update values found for ON DUPLICATE KEY UPDATE clause, and no identifier fields could be found to use instead.");
          }

          onDuplicateKeyUpdate += "".concat(this._dialect.supports.inserts.updateOnDuplicate, " ").concat(valueKeys.join(","));
        }
      }

      var replacements = {
        ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : "",
        onConflictDoNothing: options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : "",
        attributes: fields.join(","),
        output: outputFragment,
        values: values.join(","),
        tmpTable: tmpTable
      };
      valueQuery = "".concat(tmpTable, "INSERT").concat(replacements.ignoreDuplicates, " INTO ").concat(quotedTable, " (").concat(replacements.attributes, ")").concat(replacements.output, " VALUES (").concat(replacements.values, ")").concat(onDuplicateKeyUpdate).concat(replacements.onConflictDoNothing).concat(valueQuery);
      emptyQuery = "".concat(tmpTable, "INSERT").concat(replacements.ignoreDuplicates, " INTO ").concat(quotedTable).concat(replacements.output).concat(onDuplicateKeyUpdate).concat(replacements.onConflictDoNothing).concat(emptyQuery);

      if (this._dialect.supports.EXCEPTION && options.exception) {
        var dropFunction = "DROP FUNCTION IF EXISTS pg_temp.testfunc()";

        if (returningModelAttributes.length === 0) {
          returningModelAttributes.push("*");
        }

        var delimiter = "$func_".concat(uuidv4().replace(/-/g, ""), "$");
        var selectQuery = "SELECT (testfunc.response).".concat(returningModelAttributes.join(", (testfunc.response)."), ", testfunc.sequelize_caught_exception FROM pg_temp.testfunc();");
        options.exception = "WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;";
        valueQuery = "CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response ".concat(quotedTable, ", OUT sequelize_caught_exception text) RETURNS RECORD AS ").concat(delimiter, " BEGIN ").concat(valueQuery, " RETURNING * INTO response; EXCEPTION ").concat(options.exception, " END ").concat(delimiter, " LANGUAGE plpgsql; ").concat(selectQuery, " ").concat(dropFunction);
      } else {
        valueQuery += returningFragment;
        emptyQuery += returningFragment;
      }

      if (this._dialect.supports.returnIntoValues && options.returning) {
        this.populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, bind.length, returnAttributes, options);
      }

      query = "".concat(replacements.attributes.length ? valueQuery : emptyQuery).concat(returnAttributes.join(","), ";");

      if (this._dialect.supports.finalTable) {
        query = "SELECT * FROM FINAL TABLE(".concat(replacements.attributes.length ? valueQuery : emptyQuery, ");");
      }

      if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {
        query = "SET IDENTITY_INSERT ".concat(quotedTable, " ON; ").concat(query, " SET IDENTITY_INSERT ").concat(quotedTable, " OFF;");
      }

      var result = {
        query: query
      };

      if (options.bindParam !== false) {
        result.bind = bind;
      }

      return result;
    }
  }, {
    key: "bulkInsertQuery",
    value: function bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {
      var _this2 = this;

      options = options || {};
      fieldMappedAttributes = fieldMappedAttributes || {};
      var tuples = [];
      var serials = {};
      var allAttributes = [];
      var onDuplicateKeyUpdate = "";
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = fieldValueHashes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var fieldValueHash = _step2.value;

          _.forOwn(fieldValueHash, function (value, key) {
            if (!allAttributes.includes(key)) {
              allAttributes.push(key);
            }

            if (fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true) {
              serials[key] = true;
            }
          });
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        var _loop = function _loop() {
          var fieldValueHash = _step3.value;
          var values = allAttributes.map(function (key) {
            if (_this2._dialect.supports.bulkDefault && serials[key] === true) {
              return fieldValueHash[key] != null ? fieldValueHash[key] : "DEFAULT";
            }

            return _this2.escape(fieldValueHash[key], fieldMappedAttributes[key], {
              context: "INSERT"
            });
          });
          tuples.push("(".concat(values.join(","), ")"));
        };

        for (var _iterator3 = fieldValueHashes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {
        if (this._dialect.supports.inserts.updateOnDuplicate == " ON CONFLICT DO UPDATE SET") {
          var conflictKeys = options.upsertKeys.map(function (attr) {
            return _this2.quoteIdentifier(attr);
          });
          var updateKeys = options.updateOnDuplicate.map(function (attr) {
            return "".concat(_this2.quoteIdentifier(attr), "=EXCLUDED.").concat(_this2.quoteIdentifier(attr));
          });
          var whereClause = false;

          if (options.conflictWhere) {
            if (!this._dialect.supports.inserts.onConflictWhere) {
              throw new Error("conflictWhere not supported for dialect ".concat(this._dialect.name));
            }

            whereClause = this.whereQuery(options.conflictWhere, options);
          }

          onDuplicateKeyUpdate = ["ON CONFLICT", "(", conflictKeys.join(","), ")", whereClause, "DO UPDATE SET", updateKeys.join(",")];
        } else {
          if (options.conflictWhere) {
            throw new Error("conflictWhere not supported for dialect ".concat(this._dialect.name));
          }

          var valueKeys = options.updateOnDuplicate.map(function (attr) {
            return "".concat(_this2.quoteIdentifier(attr), "=VALUES(").concat(_this2.quoteIdentifier(attr), ")");
          });
          onDuplicateKeyUpdate = "".concat(this._dialect.supports.inserts.updateOnDuplicate, " ").concat(valueKeys.join(","));
        }
      }

      var ignoreDuplicates = options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : "";
      var attributes = allAttributes.map(function (attr) {
        return _this2.quoteIdentifier(attr);
      }).join(",");
      var onConflictDoNothing = options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : "";
      var returning = "";

      if (this._dialect.supports.returnValues && options.returning) {
        var returnValues = this.generateReturnValues(fieldMappedAttributes, options);
        returning += returnValues.returningFragment;
      }

      return Utils.joinSQLFragments(["INSERT", ignoreDuplicates, "INTO", this.quoteTable(tableName), "(".concat(attributes, ")"), "VALUES", tuples.join(","), onDuplicateKeyUpdate, onConflictDoNothing, returning, ";"]);
    }
  }, {
    key: "updateQuery",
    value: function updateQuery(tableName, attrValueHash, where, options, attributes) {
      options = options || {};

      _.defaults(options, this.options);

      attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);
      var values = [];
      var bind = [];
      var modelAttributeMap = {};
      var outputFragment = "";
      var tmpTable = "";
      var suffix = "";

      if (_.get(this, ["sequelize", "options", "dialectOptions", "prependSearchPath"]) || options.searchPath) {
        options.bindParam = false;
      }

      var bindParam = options.bindParam === void 0 ? this.bindParam(bind) : options.bindParam;

      if (this._dialect.supports["LIMIT ON UPDATE"] && options.limit) {
        if (!["mssql", "db2", "oracle"].includes(this.dialect)) {
          suffix = " LIMIT ".concat(this.escape(options.limit), " ");
        } else if (this.dialect === "oracle") {
          if (where && (where.length && where.length > 0 || Object.keys(where).length > 0)) {
            suffix += " AND ";
          } else {
            suffix += " WHERE ";
          }

          suffix += "rownum <= ".concat(this.escape(options.limit), " ");
        }
      }

      if (this._dialect.supports.returnValues && options.returning) {
        var returnValues = this.generateReturnValues(attributes, options);
        suffix += returnValues.returningFragment;
        tmpTable = returnValues.tmpTable || "";
        outputFragment = returnValues.outputFragment || "";

        if (!this._dialect.supports.returnValues.output && options.returning) {
          options.mapToModel = true;
        }
      }

      if (attributes) {
        _.each(attributes, function (attribute, key) {
          modelAttributeMap[key] = attribute;

          if (attribute.field) {
            modelAttributeMap[attribute.field] = attribute;
          }
        });
      }

      for (var key in attrValueHash) {
        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !this._dialect.supports.autoIncrement.update) {
          continue;
        }

        var value = attrValueHash[key];

        if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
          values.push("".concat(this.quoteIdentifier(key), "=").concat(this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
            context: "UPDATE"
          })));
        } else {
          values.push("".concat(this.quoteIdentifier(key), "=").concat(this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
            context: "UPDATE"
          }, bindParam)));
        }
      }

      var whereOptions = __spreadProps(__spreadValues({}, options), {
        bindParam: bindParam
      });

      if (values.length === 0) {
        return "";
      }

      var query = "".concat(tmpTable, "UPDATE ").concat(this.quoteTable(tableName), " SET ").concat(values.join(",")).concat(outputFragment, " ").concat(this.whereQuery(where, whereOptions)).concat(suffix).trim();
      var result = {
        query: query
      };

      if (options.bindParam !== false) {
        result.bind = bind;
      }

      return result;
    }
  }, {
    key: "arithmeticQuery",
    value: function arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {
      options = options || {};

      _.defaults(options, {
        returning: true
      });

      extraAttributesToBeUpdated = Utils.removeNullValuesFromHash(extraAttributesToBeUpdated, this.options.omitNull);
      var outputFragment = "";
      var returningFragment = "";

      if (this._dialect.supports.returnValues && options.returning) {
        var returnValues = this.generateReturnValues(null, options);
        outputFragment = returnValues.outputFragment;
        returningFragment = returnValues.returningFragment;
      }

      var updateSetSqlFragments = [];

      for (var field in incrementAmountsByField) {
        var incrementAmount = incrementAmountsByField[field];
        var quotedField = this.quoteIdentifier(field);
        var escapedAmount = this.escape(incrementAmount);
        updateSetSqlFragments.push("".concat(quotedField, "=").concat(quotedField).concat(operator, " ").concat(escapedAmount));
      }

      for (var _field in extraAttributesToBeUpdated) {
        var newValue = extraAttributesToBeUpdated[_field];

        var _quotedField = this.quoteIdentifier(_field);

        var escapedValue = this.escape(newValue);
        updateSetSqlFragments.push("".concat(_quotedField, "=").concat(escapedValue));
      }

      return Utils.joinSQLFragments(["UPDATE", this.quoteTable(tableName), "SET", updateSetSqlFragments.join(","), outputFragment, this.whereQuery(where), returningFragment]);
    }
  }, {
    key: "addIndexQuery",
    value: function addIndexQuery(tableName, attributes, options, rawTablename) {
      var _this3 = this;

      options = options || {};

      if (!Array.isArray(attributes)) {
        options = attributes;
        attributes = void 0;
      } else {
        options.fields = attributes;
      }

      options.prefix = options.prefix || rawTablename || tableName;

      if (options.prefix && typeof options.prefix === "string") {
        options.prefix = options.prefix.replace(/\./g, "_");
        options.prefix = options.prefix.replace(/("|')/g, "");
      }

      var fieldsSql = options.fields.map(function (field) {
        if (field instanceof Utils.SequelizeMethod) {
          return _this3.handleSequelizeMethod(field);
        }

        if (typeof field === "string") {
          field = {
            name: field
          };
        }

        var result = "";

        if (field.attribute) {
          field.name = field.attribute;
        }

        if (!field.name) {
          throw new Error("The following index field has no name: ".concat(util.inspect(field)));
        }

        result += _this3.quoteIdentifier(field.name);

        if (_this3._dialect.supports.index.collate && field.collate) {
          result += " COLLATE ".concat(_this3.quoteIdentifier(field.collate));
        }

        if (_this3._dialect.supports.index.operator) {
          var operator = field.operator || options.operator;

          if (operator) {
            result += " ".concat(operator);
          }
        }

        if (_this3._dialect.supports.index.length && field.length) {
          result += "(".concat(field.length, ")");
        }

        if (field.order) {
          result += " ".concat(field.order);
        }

        return result;
      });

      if (!options.name) {
        options = Utils.nameIndex(options, options.prefix);
      }

      options = Model._conformIndex(options);

      if (!this._dialect.supports.index.type) {
        delete options.type;
      }

      if (options.where) {
        options.where = this.whereQuery(options.where);
      }

      if (typeof tableName === "string") {
        tableName = this.quoteIdentifiers(tableName);
      } else {
        tableName = this.quoteTable(tableName);
      }

      var concurrently = this._dialect.supports.index.concurrently && options.concurrently ? "CONCURRENTLY" : void 0;
      var ind;

      if (this._dialect.supports.indexViaAlter) {
        ind = ["ALTER TABLE", tableName, concurrently, "ADD"];
      } else {
        ind = ["CREATE"];
      }

      ind = ind.concat(options.unique ? "UNIQUE" : "", options.type, "INDEX", !this._dialect.supports.indexViaAlter ? concurrently : void 0, this.quoteIdentifiers(options.name), this._dialect.supports.index.using === 1 && options.using ? "USING ".concat(options.using) : "", !this._dialect.supports.indexViaAlter ? "ON ".concat(tableName) : void 0, this._dialect.supports.index.using === 2 && options.using ? "USING ".concat(options.using) : "", "(".concat(fieldsSql.join(", "), ")"), this._dialect.supports.index.parser && options.parser ? "WITH PARSER ".concat(options.parser) : void 0, this._dialect.supports.index.where && options.where ? options.where : void 0);
      return _.compact(ind).join(" ");
    }
  }, {
    key: "addConstraintQuery",
    value: function addConstraintQuery(tableName, options) {
      if (typeof tableName === "string") {
        tableName = this.quoteIdentifiers(tableName);
      } else {
        tableName = this.quoteTable(tableName);
      }

      return Utils.joinSQLFragments(["ALTER TABLE", tableName, "ADD", this.getConstraintSnippet(tableName, options || {}), ";"]);
    }
  }, {
    key: "getConstraintSnippet",
    value: function getConstraintSnippet(tableName, options) {
      var _this4 = this;

      var constraintSnippet, constraintName;
      var fieldsSql = options.fields.map(function (field) {
        if (typeof field === "string") {
          return _this4.quoteIdentifier(field);
        }

        if (field instanceof Utils.SequelizeMethod) {
          return _this4.handleSequelizeMethod(field);
        }

        if (field.attribute) {
          field.name = field.attribute;
        }

        if (!field.name) {
          throw new Error("The following index field has no name: ".concat(field));
        }

        return _this4.quoteIdentifier(field.name);
      });
      var fieldsSqlQuotedString = fieldsSql.join(", ");
      var fieldsSqlString = fieldsSql.join("_");

      switch (options.type.toUpperCase()) {
        case "UNIQUE":
          constraintName = this.quoteIdentifier(options.name || "".concat(tableName, "_").concat(fieldsSqlString, "_uk"));
          constraintSnippet = "CONSTRAINT ".concat(constraintName, " UNIQUE (").concat(fieldsSqlQuotedString, ")");
          break;

        case "CHECK":
          options.where = this.whereItemsQuery(options.where);
          constraintName = this.quoteIdentifier(options.name || "".concat(tableName, "_").concat(fieldsSqlString, "_ck"));
          constraintSnippet = "CONSTRAINT ".concat(constraintName, " CHECK (").concat(options.where, ")");
          break;

        case "DEFAULT":
          if (options.defaultValue === void 0) {
            throw new Error("Default value must be specified for DEFAULT CONSTRAINT");
          }

          if (this._dialect.name !== "mssql") {
            throw new Error("Default constraints are supported only for MSSQL dialect.");
          }

          constraintName = this.quoteIdentifier(options.name || "".concat(tableName, "_").concat(fieldsSqlString, "_df"));
          constraintSnippet = "CONSTRAINT ".concat(constraintName, " DEFAULT (").concat(this.escape(options.defaultValue), ") FOR ").concat(fieldsSql[0]);
          break;

        case "PRIMARY KEY":
          constraintName = this.quoteIdentifier(options.name || "".concat(tableName, "_").concat(fieldsSqlString, "_pk"));
          constraintSnippet = "CONSTRAINT ".concat(constraintName, " PRIMARY KEY (").concat(fieldsSqlQuotedString, ")");
          break;

        case "FOREIGN KEY":
          var references = options.references;

          if (!references || !references.table || !(references.field || references.fields)) {
            throw new Error("references object with table and field must be specified");
          }

          constraintName = this.quoteIdentifier(options.name || "".concat(tableName, "_").concat(fieldsSqlString, "_").concat(references.table, "_fk"));
          var quotedReferences = typeof references.field !== "undefined" ? this.quoteIdentifier(references.field) : references.fields.map(function (f) {
            return _this4.quoteIdentifier(f);
          }).join(", ");
          var referencesSnippet = "".concat(this.quoteTable(references.table), " (").concat(quotedReferences, ")");
          constraintSnippet = "CONSTRAINT ".concat(constraintName, " ");
          constraintSnippet += "FOREIGN KEY (".concat(fieldsSqlQuotedString, ") REFERENCES ").concat(referencesSnippet);

          if (options.onUpdate) {
            constraintSnippet += " ON UPDATE ".concat(options.onUpdate.toUpperCase());
          }

          if (options.onDelete) {
            constraintSnippet += " ON DELETE ".concat(options.onDelete.toUpperCase());
          }

          break;

        default:
          throw new Error("".concat(options.type, " is invalid."));
      }

      if (options.deferrable && ["UNIQUE", "PRIMARY KEY", "FOREIGN KEY"].includes(options.type.toUpperCase())) {
        constraintSnippet += " ".concat(this.deferConstraintsQuery(options));
      }

      return constraintSnippet;
    }
  }, {
    key: "removeConstraintQuery",
    value: function removeConstraintQuery(tableName, constraintName) {
      if (typeof tableName === "string") {
        tableName = this.quoteIdentifiers(tableName);
      } else {
        tableName = this.quoteTable(tableName);
      }

      return Utils.joinSQLFragments(["ALTER TABLE", tableName, "DROP CONSTRAINT", this.quoteIdentifiers(constraintName)]);
    }
  }, {
    key: "quote",
    value: function quote(collection, parent, connector) {
      var _this5 = this;

      var validOrderOptions = ["ASC", "DESC", "ASC NULLS LAST", "DESC NULLS LAST", "ASC NULLS FIRST", "DESC NULLS FIRST", "NULLS FIRST", "NULLS LAST"];
      connector = connector || ".";

      if (typeof collection === "string") {
        return this.quoteIdentifiers(collection);
      }

      if (Array.isArray(collection)) {
        collection.forEach(function (item2, index) {
          var previous = collection[index - 1];
          var previousAssociation;
          var previousModel;

          if (!previous && parent !== void 0) {
            previousModel = parent;
          } else if (previous && previous instanceof Association) {
            previousAssociation = previous;
            previousModel = previous.target;
          }

          if (previousModel && previousModel.prototype instanceof Model) {
            var model;
            var as;

            if (typeof item2 === "function" && item2.prototype instanceof Model) {
              model = item2;
            } else if (_.isPlainObject(item2) && item2.model && item2.model.prototype instanceof Model) {
              model = item2.model;
              as = item2.as;
            }

            if (model) {
              if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {
                item2 = new Association(previousModel, model, {
                  as: model.name
                });
              } else {
                item2 = previousModel.getAssociationForAlias(model, as);

                if (!item2) {
                  item2 = previousModel.getAssociationForAlias(model, model.name);
                }
              }

              if (!(item2 instanceof Association)) {
                throw new Error(util.format("Unable to find a valid association for model, '%s'", model.name));
              }
            }
          }

          if (typeof item2 === "string") {
            var orderIndex = validOrderOptions.indexOf(item2.toUpperCase());

            if (index > 0 && orderIndex !== -1) {
              item2 = _this5.sequelize.literal(" ".concat(validOrderOptions[orderIndex]));
            } else if (previousModel && previousModel.prototype instanceof Model) {
              if (previousModel.associations !== void 0 && previousModel.associations[item2]) {
                item2 = previousModel.associations[item2];
              } else if (previousModel.rawAttributes !== void 0 && previousModel.rawAttributes[item2] && item2 !== previousModel.rawAttributes[item2].field) {
                item2 = previousModel.rawAttributes[item2].field;
              } else if (item2.includes(".") && previousModel.rawAttributes !== void 0) {
                var itemSplit = item2.split(".");

                if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {
                  var identifier = _this5.quoteIdentifiers("".concat(previousModel.name, ".").concat(previousModel.rawAttributes[itemSplit[0]].field));

                  var path = itemSplit.slice(1);
                  item2 = _this5.jsonPathExtractionQuery(identifier, path);
                  item2 = _this5.sequelize.literal(item2);
                }
              }
            }
          }

          collection[index] = item2;
        }, this);
        var collectionLength = collection.length;
        var tableNames = [];
        var item;
        var i = 0;

        for (i = 0; i < collectionLength - 1; i++) {
          item = collection[i];

          if (typeof item === "string" || item._modelAttribute || item instanceof Utils.SequelizeMethod) {
            break;
          } else if (item instanceof Association) {
            tableNames[i] = item.as;
          }
        }

        var sql = "";

        if (i > 0) {
          sql += "".concat(this.quoteIdentifier(tableNames.join(connector)), ".");
        } else if (typeof collection[0] === "string" && parent) {
          sql += "".concat(this.quoteIdentifier(parent.name), ".");
        }

        collection.slice(i).forEach(function (collectionItem) {
          sql += _this5.quote(collectionItem, parent, connector);
        }, this);
        return sql;
      }

      if (collection._modelAttribute) {
        return "".concat(this.quoteTable(collection.Model.name), ".").concat(this.quoteIdentifier(collection.fieldName));
      }

      if (collection instanceof Utils.SequelizeMethod) {
        return this.handleSequelizeMethod(collection);
      }

      if (_.isPlainObject(collection) && collection.raw) {
        throw new Error('The `{raw: "..."}` syntax is no longer supported.  Use `sequelize.literal` instead.');
      }

      throw new Error("Unknown structure passed to order / group: ".concat(util.inspect(collection)));
    }
  }, {
    key: "_initQuoteIdentifier",
    value: function _initQuoteIdentifier() {
      this._quoteIdentifier = this.quoteIdentifier;

      this.quoteIdentifier = function (identifier, force) {
        if (identifier === "*") return identifier;
        return this._quoteIdentifier(identifier, force);
      };
    }
  }, {
    key: "quoteIdentifier",
    value: function quoteIdentifier(identifier, force) {
      throw new Error("quoteIdentifier for Dialect \"".concat(this.dialect, "\" is not implemented"));
    }
  }, {
    key: "quoteIdentifiers",
    value: function quoteIdentifiers(identifiers) {
      if (identifiers.includes(".")) {
        identifiers = identifiers.split(".");
        var head = identifiers.slice(0, identifiers.length - 1).join("->");
        var tail = identifiers[identifiers.length - 1];
        return "".concat(this.quoteIdentifier(head), ".").concat(this.quoteIdentifier(tail));
      }

      return this.quoteIdentifier(identifiers);
    }
  }, {
    key: "quoteAttribute",
    value: function quoteAttribute(attribute, model) {
      if (model && attribute in model.rawAttributes) {
        return this.quoteIdentifier(attribute);
      }

      return this.quoteIdentifiers(attribute);
    }
  }, {
    key: "getAliasToken",
    value: function getAliasToken() {
      return "AS";
    }
  }, {
    key: "quoteTable",
    value: function quoteTable(param, alias) {
      var table = "";

      if (alias === true) {
        alias = param.as || param.name || param;
      }

      if (_.isObject(param)) {
        if (this._dialect.supports.schemas) {
          if (param.schema) {
            table += "".concat(this.quoteIdentifier(param.schema), ".");
          }

          table += this.quoteIdentifier(param.tableName);
        } else {
          if (param.schema) {
            table += param.schema + (param.delimiter || ".");
          }

          table += param.tableName;
          table = this.quoteIdentifier(table);
        }
      } else {
        table = this.quoteIdentifier(param);
      }

      if (alias) {
        table += " ".concat(this.getAliasToken(), " ").concat(this.quoteIdentifier(alias));
      }

      return table;
    }
  }, {
    key: "escape",
    value: function escape(value, field, options) {
      var _this6 = this;

      options = options || {};

      if (value !== null && value !== void 0) {
        if (value instanceof Utils.SequelizeMethod) {
          return this.handleSequelizeMethod(value);
        }

        if (field && field.type) {
          this.validate(value, field, options);

          if (field.type.stringify) {
            var simpleEscape = function simpleEscape(escVal) {
              return SqlString.escape(escVal, _this6.options.timezone, _this6.dialect);
            };

            value = field.type.stringify(value, {
              escape: simpleEscape,
              field: field,
              timezone: this.options.timezone,
              operation: options.operation
            });

            if (field.type.escape === false) {
              return value;
            }
          }
        }
      }

      return SqlString.escape(value, this.options.timezone, this.dialect);
    }
  }, {
    key: "bindParam",
    value: function bindParam(bind) {
      return function (value) {
        bind.push(value);
        return "$".concat(bind.length);
      };
    }
  }, {
    key: "format",
    value: function format(value, field, options, bindParam) {
      options = options || {};

      if (value !== null && value !== void 0) {
        if (value instanceof Utils.SequelizeMethod) {
          throw new Error("Cannot pass SequelizeMethod as a bind parameter - use escape instead");
        }

        if (field && field.type) {
          this.validate(value, field, options);

          if (field.type.bindParam) {
            return field.type.bindParam(value, {
              escape: _.identity,
              field: field,
              timezone: this.options.timezone,
              operation: options.operation,
              bindParam: bindParam
            });
          }
        }
      }

      return bindParam(value);
    }
  }, {
    key: "validate",
    value: function validate(value, field, options) {
      if (this.typeValidation && field.type.validate && value) {
        try {
          if (options.isList && Array.isArray(value)) {
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = value[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var item = _step4.value;
                field.type.validate(item, options);
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                  _iterator4["return"]();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }
          } else {
            field.type.validate(value, options);
          }
        } catch (error) {
          if (error instanceof sequelizeError.ValidationError) {
            error.errors.push(new sequelizeError.ValidationErrorItem(error.message, "Validation error", field.fieldName, value, null, "".concat(field.type.key, " validator")));
          }

          throw error;
        }
      }
    }
  }, {
    key: "isIdentifierQuoted",
    value: function isIdentifierQuoted(identifier) {
      return /^\s*(?:([`"'])(?:(?!\1).|\1{2})*\1\.?)+\s*$/i.test(identifier);
    }
  }, {
    key: "jsonPathExtractionQuery",
    value: function jsonPathExtractionQuery(column, path, isJson) {
      var paths = _.toPath(path);

      var pathStr;
      var quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);

      switch (this.dialect) {
        case "mysql":
        case "mariadb":
        case "sqlite":
          if (this.dialect === "mysql") {
            paths = paths.map(function (subPath) {
              return /\D/.test(subPath) ? Utils.addTicks(subPath, '"') : subPath;
            });
          }

          pathStr = this.escape(["$"].concat(paths).join(".").replace(/\.(\d+)(?:(?=\.)|$)/g, function (__, digit) {
            return "[".concat(digit, "]");
          }));

          if (this.dialect === "sqlite") {
            return "json_extract(".concat(quotedColumn, ",").concat(pathStr, ")");
          }

          return "json_unquote(json_extract(".concat(quotedColumn, ",").concat(pathStr, "))");

        case "postgres":
          var join = isJson ? "#>" : "#>>";
          pathStr = this.escape("{".concat(paths.join(","), "}"));
          return "(".concat(quotedColumn).concat(join).concat(pathStr, ")");

        default:
          throw new Error("Unsupported ".concat(this.dialect, " for JSON operations"));
      }
    }
  }, {
    key: "selectQuery",
    value: function selectQuery(tableName, options, model) {
      var _this7 = this;

      options = options || {};
      var limit = options.limit;
      var mainQueryItems = [];
      var subQueryItems = [];
      var subQuery = options.subQuery === void 0 ? limit && options.hasMultiAssociation : options.subQuery;
      var attributes = {
        main: options.attributes && options.attributes.slice(),
        subQuery: null
      };
      var mainTable = {
        name: tableName,
        quotedName: null,
        as: null,
        model: model
      };
      var topLevelInfo = {
        names: mainTable,
        options: options,
        subQuery: subQuery
      };
      var mainJoinQueries = [];
      var subJoinQueries = [];
      var query;

      if (this.options.minifyAliases && !options.aliasesMapping) {
        options.aliasesMapping =
        /* @__PURE__ */
        new Map();
        options.aliasesByTable = {};
        options.includeAliases =
        /* @__PURE__ */
        new Map();
      }

      if (options.tableAs) {
        mainTable.as = this.quoteIdentifier(options.tableAs);
      } else if (!Array.isArray(mainTable.name) && mainTable.model) {
        mainTable.as = this.quoteIdentifier(mainTable.model.name);
      }

      mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map(function (t) {
        return Array.isArray(t) ? _this7.quoteTable(t[0], t[1]) : _this7.quoteTable(t, true);
      }).join(", ");

      if (subQuery && attributes.main) {
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          var _loop2 = function _loop2() {
            var keyAtt = _step5.value;

            if (!attributes.main.some(function (attr) {
              return keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1];
            })) {
              attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [keyAtt, mainTable.model.rawAttributes[keyAtt].field] : keyAtt);
            }
          };

          for (var _iterator5 = mainTable.model.primaryKeyAttributes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            _loop2();
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
              _iterator5["return"]();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      }

      attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);
      attributes.main = attributes.main || (options.include ? ["".concat(mainTable.as, ".*")] : ["*"]);

      if (subQuery || options.groupedLimit) {
        attributes.subQuery = attributes.main;
        attributes.main = ["".concat(mainTable.as || mainTable.quotedName, ".*")];
      }

      if (options.include) {
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = options.include[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var include = _step6.value;

            if (include.separate) {
              continue;
            }

            var joinQueries = this.generateInclude(include, {
              externalAs: mainTable.as,
              internalAs: mainTable.as
            }, topLevelInfo);
            subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);
            mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);

            if (joinQueries.attributes.main.length > 0) {
              attributes.main = _.uniq(attributes.main.concat(joinQueries.attributes.main));
            }

            if (joinQueries.attributes.subQuery.length > 0) {
              attributes.subQuery = _.uniq(attributes.subQuery.concat(joinQueries.attributes.subQuery));
            }
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
              _iterator6["return"]();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      }

      if (subQuery) {
        subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));
        subQueryItems.push(subJoinQueries.join(""));
      } else {
        if (options.groupedLimit) {
          if (!mainTable.as) {
            mainTable.as = mainTable.quotedName;
          }

          var where = __spreadValues({}, options.where);

          var groupedLimitOrder,
              whereKey,
              _include,
              groupedTableName = mainTable.as;

          if (typeof options.groupedLimit.on === "string") {
            whereKey = options.groupedLimit.on;
          } else if (options.groupedLimit.on instanceof HasMany) {
            whereKey = options.groupedLimit.on.foreignKeyField;
          }

          if (options.groupedLimit.on instanceof BelongsToMany) {
            groupedTableName = options.groupedLimit.on.manyFromSource.as;

            var groupedLimitOptions = Model._validateIncludedElements({
              include: [{
                association: options.groupedLimit.on.manyFromSource,
                duplicating: false,
                required: true,
                where: __spreadValues(_defineProperty({}, Op.placeholder, true), options.groupedLimit.through && options.groupedLimit.through.where)
              }],
              model: model
            });

            options.hasJoin = true;
            options.hasMultiAssociation = true;
            options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);
            options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);
            _include = groupedLimitOptions.include;

            if (Array.isArray(options.order)) {
              options.order.forEach(function (order, i) {
                if (Array.isArray(order)) {
                  order = order[0];
                }

                var alias = "subquery_order_".concat(i);
                options.attributes.push([order, alias]);
                alias = _this7.sequelize.literal(_this7.quote(alias));

                if (Array.isArray(options.order[i])) {
                  options.order[i][0] = alias;
                } else {
                  options.order[i] = alias;
                }
              });
              groupedLimitOrder = options.order;
            }
          } else {
            groupedLimitOrder = options.order;

            if (!this._dialect.supports.topLevelOrderByRequired) {
              delete options.order;
            }

            where[Op.placeholder] = true;
          }

          var baseQuery = "SELECT * FROM (".concat(this.selectQuery(tableName, {
            attributes: options.attributes,
            offset: options.offset,
            limit: options.groupedLimit.limit,
            order: groupedLimitOrder,
            aliasesMapping: options.aliasesMapping,
            aliasesByTable: options.aliasesByTable,
            where: where,
            include: _include,
            model: model
          }, model).replace(/;$/, ""), ") ").concat(this.getAliasToken(), " sub");
          var placeHolder = this.whereItemQuery(Op.placeholder, true, {
            model: model
          });
          var splicePos = baseQuery.indexOf(placeHolder);
          mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, "(".concat(options.groupedLimit.values.map(function (value) {
            var groupWhere;

            if (whereKey) {
              groupWhere = _defineProperty({}, whereKey, value);
            }

            if (_include) {
              groupWhere = _defineProperty({}, options.groupedLimit.on.foreignIdentifierField, value);
            }

            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, _this7.getWhereConditions(groupWhere, groupedTableName));
          }).join(this._dialect.supports["UNION ALL"] ? " UNION ALL " : " UNION "), ")"), mainTable.as));
        } else {
          mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));
        }

        mainQueryItems.push(mainJoinQueries.join(""));
      }

      if (Object.prototype.hasOwnProperty.call(options, "where") && !options.groupedLimit) {
        options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);

        if (options.where) {
          if (subQuery) {
            subQueryItems.push(" WHERE ".concat(options.where));
          } else {
            mainQueryItems.push(" WHERE ".concat(options.where));
            mainQueryItems.forEach(function (value, key) {
              if (value.startsWith("SELECT")) {
                mainQueryItems[key] = _this7.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);
              }
            });
          }
        }
      }

      if (options.group) {
        options.group = Array.isArray(options.group) ? options.group.map(function (t) {
          return _this7.aliasGrouping(t, model, mainTable.as, options);
        }).join(", ") : this.aliasGrouping(options.group, model, mainTable.as, options);

        if (subQuery && options.group) {
          subQueryItems.push(" GROUP BY ".concat(options.group));
        } else if (options.group) {
          mainQueryItems.push(" GROUP BY ".concat(options.group));
        }
      }

      if (Object.prototype.hasOwnProperty.call(options, "having")) {
        options.having = this.getWhereConditions(options.having, tableName, model, options, false);

        if (options.having) {
          if (subQuery) {
            subQueryItems.push(" HAVING ".concat(options.having));
          } else {
            mainQueryItems.push(" HAVING ".concat(options.having));
          }
        }
      }

      if (options.order) {
        var orders = this.getQueryOrders(options, model, subQuery);

        if (orders.mainQueryOrder.length) {
          mainQueryItems.push(" ORDER BY ".concat(orders.mainQueryOrder.join(", ")));
        }

        if (orders.subQueryOrder.length) {
          subQueryItems.push(" ORDER BY ".concat(orders.subQueryOrder.join(", ")));
        }
      }

      var limitOrder = this.addLimitAndOffset(options, mainTable.model);

      if (limitOrder && !options.groupedLimit) {
        if (subQuery) {
          subQueryItems.push(limitOrder);
        } else {
          mainQueryItems.push(limitOrder);
        }
      }

      if (subQuery) {
        this._throwOnEmptyAttributes(attributes.main, {
          modelName: model && model.name,
          as: mainTable.as
        });

        query = "SELECT ".concat(attributes.main.join(", "), " FROM (").concat(subQueryItems.join(""), ") ").concat(this.getAliasToken(), " ").concat(mainTable.as).concat(mainJoinQueries.join("")).concat(mainQueryItems.join(""));
      } else {
        query = mainQueryItems.join("");
      }

      if (options.lock && this._dialect.supports.lock) {
        var lock = options.lock;

        if (_typeof(options.lock) === "object") {
          lock = options.lock.level;
        }

        if (this._dialect.supports.lockKey && ["KEY SHARE", "NO KEY UPDATE"].includes(lock)) {
          query += " FOR ".concat(lock);
        } else if (lock === "SHARE") {
          query += " ".concat(this._dialect.supports.forShare);
        } else {
          query += " FOR UPDATE";
        }

        if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {
          query += " OF ".concat(this.quoteTable(options.lock.of.name));
        }

        if (this._dialect.supports.skipLocked && options.skipLocked) {
          query += " SKIP LOCKED";
        }
      }

      return "".concat(query, ";");
    }
  }, {
    key: "aliasGrouping",
    value: function aliasGrouping(field, model, tableName, options) {
      var src = Array.isArray(field) ? field[0] : field;
      return this.quote(this._getAliasForField(tableName, src, options) || src, model);
    }
  }, {
    key: "escapeAttributes",
    value: function escapeAttributes(attributes, options, mainTableAs) {
      var _this8 = this;

      return attributes && attributes.map(function (attr) {
        var addTable = true;

        if (attr instanceof Utils.SequelizeMethod) {
          return _this8.handleSequelizeMethod(attr);
        }

        if (Array.isArray(attr)) {
          if (attr.length !== 2) {
            throw new Error("".concat(JSON.stringify(attr), " is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']"));
          }

          attr = attr.slice();

          if (attr[0] instanceof Utils.SequelizeMethod) {
            attr[0] = _this8.handleSequelizeMethod(attr[0]);
            addTable = false;
          } else if (_this8.options.attributeBehavior === "escape" || !attr[0].includes("(") && !attr[0].includes(")")) {
            attr[0] = _this8.quoteIdentifier(attr[0]);
          } else if (_this8.options.attributeBehavior !== "unsafe-legacy") {
            throw new Error("Attributes cannot include parentheses in Sequelize 6:\nIn order to fix the vulnerability CVE-2023-22578, we had to remove support for treating attributes as raw SQL if they included parentheses.\nSequelize 7 escapes all attributes, even if they include parentheses.\nFor Sequelize 6, because we're introducing this change in a minor release, we've opted for throwing an error instead of silently escaping the attribute as a way to warn you about this change.\n\nHere is what you can do to fix this error:\n- Wrap the attribute in a literal() call. This will make Sequelize treat it as raw SQL.\n- Set the \"attributeBehavior\" sequelize option to \"escape\" to make Sequelize escape the attribute, like in Sequelize v7. We highly recommend this option.\n- Set the \"attributeBehavior\" sequelize option to \"unsafe-legacy\" to make Sequelize escape the attribute, like in Sequelize v5.\n\nWe sincerely apologize for the inconvenience this may cause you. You can find more information on the following threads:\nhttps://github.com/sequelize/sequelize/security/advisories/GHSA-f598-mfpv-gmfx\nhttps://github.com/sequelize/sequelize/discussions/15694");
          }

          var alias = attr[1];

          if (_this8.options.minifyAliases) {
            alias = _this8._getMinifiedAlias(alias, mainTableAs, options);
          }

          attr = [attr[0], _this8.quoteIdentifier(alias)].join(" AS ");
        } else {
          attr = !attr.includes(Utils.TICK_CHAR) && !attr.includes('"') ? _this8.quoteAttribute(attr, options.model) : _this8.escape(attr);
        }

        if (!_.isEmpty(options.include) && (!attr.includes(".") || options.dotNotation) && addTable) {
          attr = "".concat(mainTableAs, ".").concat(attr);
        }

        return attr;
      });
    }
  }, {
    key: "generateInclude",
    value: function generateInclude(include, parentTableName, topLevelInfo) {
      var _this9 = this;

      var joinQueries = {
        mainQuery: [],
        subQuery: []
      };
      var mainChildIncludes = [];
      var subChildIncludes = [];
      var requiredMismatch = false;
      var includeAs = {
        internalAs: include.as,
        externalAs: include.as
      };
      var attributes = {
        main: [],
        subQuery: []
      };
      var joinQuery;
      topLevelInfo.options.keysEscaped = true;

      if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {
        includeAs.internalAs = "".concat(parentTableName.internalAs, "->").concat(include.as);
        includeAs.externalAs = "".concat(parentTableName.externalAs, ".").concat(include.as);
      }

      if (topLevelInfo.options.includeIgnoreAttributes !== false) {
        include.model._expandAttributes(include);

        Utils.mapFinderOptions(include, include.model);
        var includeAttributes = include.attributes.map(function (attr) {
          var attrAs = attr;
          var verbatim = false;

          if (Array.isArray(attr) && attr.length === 2) {
            if (attr[0] instanceof Utils.SequelizeMethod && (attr[0] instanceof Utils.Literal || attr[0] instanceof Utils.Cast || attr[0] instanceof Utils.Fn)) {
              verbatim = true;
            }

            attr = attr.map(function (attr2) {
              return attr2 instanceof Utils.SequelizeMethod ? _this9.handleSequelizeMethod(attr2) : attr2;
            });
            attrAs = attr[1];
            attr = attr[0];
          }

          if (attr instanceof Utils.Literal) {
            return attr.val;
          }

          if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {
            throw new Error("Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. This means the attribute will not be added to the returned instance");
          }

          var prefix;

          if (verbatim === true) {
            prefix = attr;
          } else if (/#>>|->>/.test(attr)) {
            prefix = "(".concat(_this9.quoteIdentifier(includeAs.internalAs), ".").concat(attr.replace(/\(|\)/g, ""), ")");
          } else if (/json_extract\(/.test(attr)) {
            prefix = attr.replace(/json_extract\(/i, "json_extract(".concat(_this9.quoteIdentifier(includeAs.internalAs), "."));
          } else if (/json_value\(/.test(attr)) {
            prefix = attr.replace(/json_value\(/i, "json_value(".concat(_this9.quoteIdentifier(includeAs.internalAs), "."));
          } else {
            prefix = "".concat(_this9.quoteIdentifier(includeAs.internalAs), ".").concat(_this9.quoteIdentifier(attr));
          }

          var alias = "".concat(includeAs.externalAs, ".").concat(attrAs);

          if (_this9.options.minifyAliases) {
            alias = _this9._getMinifiedAlias(alias, includeAs.internalAs, topLevelInfo.options);
          }

          return Utils.joinSQLFragments([prefix, "AS", _this9.quoteIdentifier(alias, true)]);
        });

        if (include.subQuery && topLevelInfo.subQuery) {
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = includeAttributes[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var attr = _step7.value;
              attributes.subQuery.push(attr);
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
                _iterator7["return"]();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }
        } else {
          var _iteratorNormalCompletion8 = true;
          var _didIteratorError8 = false;
          var _iteratorError8 = undefined;

          try {
            for (var _iterator8 = includeAttributes[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var _attr = _step8.value;
              attributes.main.push(_attr);
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
                _iterator8["return"]();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }
        }
      }

      if (include.through) {
        joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);
      } else {
        this._generateSubQueryFilter(include, includeAs, topLevelInfo);

        joinQuery = this.generateJoin(include, topLevelInfo);
      }

      if (joinQuery.attributes.main.length > 0) {
        attributes.main = attributes.main.concat(joinQuery.attributes.main);
      }

      if (joinQuery.attributes.subQuery.length > 0) {
        attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);
      }

      if (include.include) {
        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          for (var _iterator9 = include.include[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var childInclude = _step9.value;

            if (childInclude.separate || childInclude._pseudo) {
              continue;
            }

            var childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);

            if (include.required === false && childInclude.required === true) {
              requiredMismatch = true;
            }

            if (childInclude.subQuery && topLevelInfo.subQuery) {
              subChildIncludes.push(childJoinQueries.subQuery);
            }

            if (childJoinQueries.mainQuery) {
              mainChildIncludes.push(childJoinQueries.mainQuery);
            }

            if (childJoinQueries.attributes.main.length > 0) {
              attributes.main = attributes.main.concat(childJoinQueries.attributes.main);
            }

            if (childJoinQueries.attributes.subQuery.length > 0) {
              attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);
            }
          }
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
              _iterator9["return"]();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }
      }

      if (include.subQuery && topLevelInfo.subQuery) {
        if (requiredMismatch && subChildIncludes.length > 0) {
          joinQueries.subQuery.push(" ".concat(joinQuery.join, " ( ").concat(joinQuery.body).concat(subChildIncludes.join(""), " ) ON ").concat(joinQuery.condition));
        } else {
          joinQueries.subQuery.push(" ".concat(joinQuery.join, " ").concat(joinQuery.body, " ON ").concat(joinQuery.condition));

          if (subChildIncludes.length > 0) {
            joinQueries.subQuery.push(subChildIncludes.join(""));
          }
        }

        joinQueries.mainQuery.push(mainChildIncludes.join(""));
      } else {
        if (requiredMismatch && mainChildIncludes.length > 0) {
          joinQueries.mainQuery.push(" ".concat(joinQuery.join, " ( ").concat(joinQuery.body).concat(mainChildIncludes.join(""), " ) ON ").concat(joinQuery.condition));
        } else {
          joinQueries.mainQuery.push(" ".concat(joinQuery.join, " ").concat(joinQuery.body, " ON ").concat(joinQuery.condition));

          if (mainChildIncludes.length > 0) {
            joinQueries.mainQuery.push(mainChildIncludes.join(""));
          }
        }

        joinQueries.subQuery.push(subChildIncludes.join(""));
      }

      return {
        mainQuery: joinQueries.mainQuery.join(""),
        subQuery: joinQueries.subQuery.join(""),
        attributes: attributes
      };
    }
  }, {
    key: "_getMinifiedAlias",
    value: function _getMinifiedAlias(alias, tableName, options) {
      if (options.aliasesByTable["".concat(tableName).concat(alias)]) {
        return options.aliasesByTable["".concat(tableName).concat(alias)];
      }

      if (alias.match(/subquery_order_[0-9]/)) {
        return alias;
      }

      var minifiedAlias = "_".concat(options.aliasesMapping.size);
      options.aliasesMapping.set(minifiedAlias, alias);
      options.aliasesByTable["".concat(tableName).concat(alias)] = minifiedAlias;
      return minifiedAlias;
    }
  }, {
    key: "_getAliasForField",
    value: function _getAliasForField(tableName, field, options) {
      if (this.options.minifyAliases) {
        if (options.aliasesByTable["".concat(tableName).concat(field)]) {
          return options.aliasesByTable["".concat(tableName).concat(field)];
        }
      }

      return null;
    }
  }, {
    key: "generateJoin",
    value: function generateJoin(include, topLevelInfo) {
      var association = include.association;
      var parent = include.parent;
      var parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;
      var $parent;
      var joinWhere;
      var left = association.source;
      var attrLeft = association instanceof BelongsTo ? association.identifier : association.sourceKeyAttribute || left.primaryKeyAttribute;
      var fieldLeft = association instanceof BelongsTo ? association.identifierField : left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;
      var asLeft;
      var right = include.model;
      var tableRight = right.getTableName();
      var fieldRight = association instanceof BelongsTo ? right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field : association.identifierField;
      var asRight = include.as;

      while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {
        if (asLeft) {
          asLeft = "".concat($parent.as, "->").concat(asLeft);
        } else {
          asLeft = $parent.as;
        }
      }

      if (!asLeft) asLeft = parent.as || parent.model.name;else asRight = "".concat(asLeft, "->").concat(asRight);
      var joinOn = "".concat(this.quoteTable(asLeft), ".").concat(this.quoteIdentifier(fieldLeft));
      var subqueryAttributes = [];

      if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {
        if (parentIsTop) {
          var tableName = this.quoteTable(parent.as || parent.model.name);
          joinOn = this._getAliasForField(tableName, attrLeft, topLevelInfo.options) || "".concat(tableName, ".").concat(this.quoteIdentifier(attrLeft));

          if (topLevelInfo.subQuery) {
            var dbIdentifier = "".concat(tableName, ".").concat(this.quoteIdentifier(fieldLeft));
            subqueryAttributes.push(dbIdentifier !== joinOn ? "".concat(dbIdentifier, " AS ").concat(this.quoteIdentifier(attrLeft)) : dbIdentifier);
          }
        } else {
          var joinSource = "".concat(asLeft.replace(/->/g, "."), ".").concat(attrLeft);
          joinOn = this._getAliasForField(asLeft, joinSource, topLevelInfo.options) || this.quoteIdentifier(joinSource);
        }
      }

      joinOn += " = ".concat(this.quoteIdentifier(asRight), ".").concat(this.quoteIdentifier(fieldRight));

      if (include.on) {
        joinOn = this.whereItemsQuery(include.on, {
          prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),
          model: include.model
        });
      }

      if (include.where) {
        joinWhere = this.whereItemsQuery(include.where, {
          prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),
          model: include.model
        });

        if (joinWhere) {
          if (include.or) {
            joinOn += " OR ".concat(joinWhere);
          } else {
            joinOn += " AND ".concat(joinWhere);
          }
        }
      }

      this.aliasAs(asRight, topLevelInfo);
      return {
        join: include.required ? "INNER JOIN" : include.right && this._dialect.supports["RIGHT JOIN"] ? "RIGHT OUTER JOIN" : "LEFT OUTER JOIN",
        body: this.quoteTable(tableRight, asRight),
        condition: joinOn,
        attributes: {
          main: [],
          subQuery: subqueryAttributes
        }
      };
    }
  }, {
    key: "generateReturnValues",
    value: function generateReturnValues(modelAttributes, options) {
      var _this10 = this;

      var returnFields = [];
      var returnTypes = [];
      var outputFragment = "";
      var returningFragment = "";
      var tmpTable = "";

      if (Array.isArray(options.returning)) {
        returnFields.push.apply(returnFields, _toConsumableArray(options.returning.map(function (field) {
          return _this10.quoteIdentifier(field);
        })));
      } else if (modelAttributes) {
        _.each(modelAttributes, function (attribute) {
          if (!(attribute.type instanceof DataTypes.VIRTUAL)) {
            returnFields.push(_this10.quoteIdentifier(attribute.field));
            returnTypes.push(attribute.type);
          }
        });
      }

      if (_.isEmpty(returnFields)) {
        returnFields.push("*");
      }

      if (this._dialect.supports.returnValues.returning) {
        returningFragment = " RETURNING ".concat(returnFields.join(","));
      } else if (this._dialect.supports.returnIntoValues) {
        returningFragment = " RETURNING ".concat(returnFields.join(","), " INTO ");
      } else if (this._dialect.supports.returnValues.output) {
        outputFragment = " OUTPUT ".concat(returnFields.map(function (field) {
          return "INSERTED.".concat(field);
        }).join(","));

        if (options.hasTrigger && this._dialect.supports.tmpTableTrigger) {
          var tmpColumns = returnFields.map(function (field, i) {
            return "".concat(field, " ").concat(returnTypes[i].toSql());
          });
          tmpTable = "DECLARE @tmp TABLE (".concat(tmpColumns.join(","), "); ");
          outputFragment += " INTO @tmp";
          returningFragment = "; SELECT * FROM @tmp";
        }
      }

      return {
        outputFragment: outputFragment,
        returnFields: returnFields,
        returnTypes: returnTypes,
        returningFragment: returningFragment,
        tmpTable: tmpTable
      };
    }
  }, {
    key: "generateThroughJoin",
    value: function generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {
      var _this11 = this;

      var through = include.through;
      var throughTable = through.model.getTableName();
      var throughAs = "".concat(includeAs.internalAs, "->").concat(through.as);
      var externalThroughAs = "".concat(includeAs.externalAs, ".").concat(through.as);
      var throughAttributes = through.attributes.map(function (attr) {
        var alias = "".concat(externalThroughAs, ".").concat(Array.isArray(attr) ? attr[1] : attr);

        if (_this11.options.minifyAliases) {
          alias = _this11._getMinifiedAlias(alias, throughAs, topLevelInfo.options);
        }

        return Utils.joinSQLFragments(["".concat(_this11.quoteIdentifier(throughAs), ".").concat(_this11.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)), "AS", _this11.quoteIdentifier(alias)]);
      });
      var association = include.association;
      var parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;
      var tableSource = parentTableName;
      var identSource = association.identifierField;
      var tableTarget = includeAs.internalAs;
      var identTarget = association.foreignIdentifierField;
      var attrTarget = association.targetKeyField;
      var joinType = include.required ? "INNER JOIN" : include.right && this._dialect.supports["RIGHT JOIN"] ? "RIGHT OUTER JOIN" : "LEFT OUTER JOIN";
      var joinBody;
      var joinCondition;
      var attributes = {
        main: [],
        subQuery: []
      };
      var attrSource = association.sourceKey;
      var sourceJoinOn;
      var targetJoinOn;
      var throughWhere;
      var targetWhere;

      if (topLevelInfo.options.includeIgnoreAttributes !== false) {
        var _iteratorNormalCompletion10 = true;
        var _didIteratorError10 = false;
        var _iteratorError10 = undefined;

        try {
          for (var _iterator10 = throughAttributes[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
            var attr = _step10.value;
            attributes.main.push(attr);
          }
        } catch (err) {
          _didIteratorError10 = true;
          _iteratorError10 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
              _iterator10["return"]();
            }
          } finally {
            if (_didIteratorError10) {
              throw _iteratorError10;
            }
          }
        }
      }

      if (!topLevelInfo.subQuery) {
        attrSource = association.sourceKeyField;
      }

      if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {
        attrSource = association.sourceKeyField;
      }

      if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {
        var joinSource = this._getAliasForField(tableSource, "".concat(tableSource, ".").concat(attrSource), topLevelInfo.options) || "".concat(tableSource, ".").concat(attrSource);
        sourceJoinOn = "".concat(this.quoteIdentifier(joinSource), " = ");
      } else {
        var aliasedSource = this._getAliasForField(tableSource, attrSource, topLevelInfo.options) || attrSource;
        sourceJoinOn = "".concat(this.quoteTable(tableSource), ".").concat(this.quoteIdentifier(aliasedSource), " = ");
      }

      sourceJoinOn += "".concat(this.quoteIdentifier(throughAs), ".").concat(this.quoteIdentifier(identSource));
      targetJoinOn = "".concat(this.quoteIdentifier(tableTarget), ".").concat(this.quoteIdentifier(attrTarget), " = ");
      targetJoinOn += "".concat(this.quoteIdentifier(throughAs), ".").concat(this.quoteIdentifier(identTarget));

      if (through.where) {
        throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);
      }

      this.aliasAs(includeAs.internalAs, topLevelInfo);
      joinBody = "( ".concat(this.quoteTable(throughTable, throughAs), " INNER JOIN ").concat(this.quoteTable(include.model.getTableName(), includeAs.internalAs), " ON ").concat(targetJoinOn);

      if (throughWhere) {
        joinBody += " AND ".concat(throughWhere);
      }

      joinBody += ")";
      joinCondition = sourceJoinOn;

      if (include.where || include.through.where) {
        if (include.where) {
          targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);

          if (targetWhere) {
            joinCondition += " AND ".concat(targetWhere);
          }
        }
      }

      this._generateSubQueryFilter(include, includeAs, topLevelInfo);

      return {
        join: joinType,
        body: joinBody,
        condition: joinCondition,
        attributes: attributes
      };
    }
  }, {
    key: "aliasAs",
    value: function aliasAs(as, topLevelInfo) {
      if (this.options.minifyAliases && as.length >= 64) {
        var alias = "%".concat(topLevelInfo.options.includeAliases.size);
        topLevelInfo.options.includeAliases.set(alias, as);
      }
    }
  }, {
    key: "_generateSubQueryFilter",
    value: function _generateSubQueryFilter(include, includeAs, topLevelInfo) {
      if (!topLevelInfo.subQuery || !include.subQueryFilter) {
        return;
      }

      if (!topLevelInfo.options.where) {
        topLevelInfo.options.where = {};
      }

      var parent = include;
      var child = include;

      var nestedIncludes = this._getRequiredClosure(include).include;

      var query;

      while (parent = parent.parent) {
        if (parent.parent && !parent.required) {
          return;
        }

        if (parent.subQueryFilter) {
          return;
        }

        nestedIncludes = [__spreadProps(__spreadValues({}, child), {
          include: nestedIncludes,
          attributes: []
        })];
        child = parent;
      }

      var topInclude = nestedIncludes[0];
      var topParent = topInclude.parent;
      var topAssociation = topInclude.association;
      topInclude.association = void 0;

      if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {
        query = this.selectQuery(topInclude.through.model.getTableName(), {
          attributes: [topInclude.through.model.primaryKeyField],
          include: Model._validateIncludedElements({
            model: topInclude.through.model,
            include: [{
              association: topAssociation.toTarget,
              required: true,
              where: topInclude.where,
              include: topInclude.include
            }]
          }).include,
          model: topInclude.through.model,
          where: _defineProperty({}, Op.and, [this.sequelize.literal(["".concat(this.quoteTable(topParent.model.name), ".").concat(this.quoteIdentifier(topParent.model.primaryKeyField)), "".concat(this.quoteIdentifier(topInclude.through.model.name), ".").concat(this.quoteIdentifier(topAssociation.identifierField))].join(" = ")), topInclude.through.where]),
          limit: 1,
          includeIgnoreAttributes: false
        }, topInclude.through.model);
      } else {
        var isBelongsTo = topAssociation.associationType === "BelongsTo";
        var sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;
        var targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;
        var join = ["".concat(this.quoteIdentifier(topInclude.as), ".").concat(this.quoteIdentifier(targetField)), "".concat(this.quoteTable(topParent.as || topParent.model.name), ".").concat(this.quoteIdentifier(sourceField))].join(" = ");
        query = this.selectQuery(topInclude.model.getTableName(), {
          attributes: [targetField],
          include: Model._validateIncludedElements(topInclude).include,
          model: topInclude.model,
          where: _defineProperty({}, Op.and, [topInclude.where, _defineProperty({}, Op.join, this.sequelize.literal(join))]),
          limit: 1,
          tableAs: topInclude.as,
          includeIgnoreAttributes: false
        }, topInclude.model);
      }

      if (!topLevelInfo.options.where[Op.and]) {
        topLevelInfo.options.where[Op.and] = [];
      }

      topLevelInfo.options.where["__".concat(includeAs.internalAs)] = this.sequelize.literal(["(", query.replace(/;$/, ""), ")", "IS NOT NULL"].join(" "));
    }
  }, {
    key: "_getRequiredClosure",
    value: function _getRequiredClosure(include) {
      var _this12 = this;

      var copy = __spreadProps(__spreadValues({}, include), {
        attributes: [],
        include: []
      });

      if (Array.isArray(include.include)) {
        copy.include = include.include.filter(function (i) {
          return i.required;
        }).map(function (inc) {
          return _this12._getRequiredClosure(inc);
        });
      }

      return copy;
    }
  }, {
    key: "getQueryOrders",
    value: function getQueryOrders(options, model, subQuery) {
      var _this13 = this;

      var mainQueryOrder = [];
      var subQueryOrder = [];

      if (Array.isArray(options.order)) {
        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          var _loop3 = function _loop3() {
            var order = _step11.value;

            if (!Array.isArray(order)) {
              order = [order];
            }

            if (subQuery && Array.isArray(order) && order[0] && !(order[0] instanceof Association) && !(typeof order[0] === "function" && order[0].prototype instanceof Model) && !(typeof order[0].model === "function" && order[0].model.prototype instanceof Model) && !(typeof order[0] === "string" && model && model.associations !== void 0 && model.associations[order[0]])) {
              var field = model.rawAttributes[order[0]] ? model.rawAttributes[order[0]].field : order[0];

              var subQueryAlias = _this13._getAliasForField(_this13.quoteIdentifier(model.name), field, options);

              var parent = null;
              var orderToQuote = [];

              if (subQueryAlias === null) {
                orderToQuote = order;
                parent = model;
              } else {
                orderToQuote = [subQueryAlias, order.length > 1 ? order[1] : "ASC"];
                parent = null;
              }

              subQueryOrder.push(_this13.quote(orderToQuote, parent, "->"));
            }

            if (options.attributes && model) {
              var aliasedAttribute = options.attributes.find(function (attr) {
                return Array.isArray(attr) && attr[1] && (attr[0] === order[0] || attr[1] === order[0]);
              });

              if (aliasedAttribute) {
                var modelName = _this13.quoteIdentifier(model.name);

                var alias = _this13._getAliasForField(modelName, aliasedAttribute[1], options);

                order[0] = new Utils.Col(alias || aliasedAttribute[1]);
              }
            }

            mainQueryOrder.push(_this13.quote(order, model, "->"));
          };

          for (var _iterator11 = options.order[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            _loop3();
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
              _iterator11["return"]();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }
      } else if (options.order instanceof Utils.SequelizeMethod) {
        var sql = this.quote(options.order, model, "->");

        if (subQuery) {
          subQueryOrder.push(sql);
        }

        mainQueryOrder.push(sql);
      } else {
        throw new Error("Order must be type of array or instance of a valid sequelize method.");
      }

      return {
        mainQueryOrder: mainQueryOrder,
        subQueryOrder: subQueryOrder
      };
    }
  }, {
    key: "_throwOnEmptyAttributes",
    value: function _throwOnEmptyAttributes(attributes) {
      var extraInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (attributes.length > 0) return;
      var asPart = extraInfo.as && "as ".concat(extraInfo.as) || "";
      var namePart = extraInfo.modelName && "for model '".concat(extraInfo.modelName, "'") || "";
      var message = "Attempted a SELECT query ".concat(namePart, " ").concat(asPart, " without selecting any columns");
      throw new sequelizeError.QueryError(message.replace(/ +/g, " "));
    }
  }, {
    key: "selectFromTableFragment",
    value: function selectFromTableFragment(options, model, attributes, tables, mainTableAs) {
      var _this14 = this;

      this._throwOnEmptyAttributes(attributes, {
        modelName: model && model.name,
        as: mainTableAs
      });

      var fragment = "SELECT ".concat(attributes.join(", "), " FROM ").concat(tables);

      if (mainTableAs) {
        fragment += " ".concat(this.getAliasToken(), " ").concat(mainTableAs);
      }

      if (options.indexHints && this._dialect.supports.indexHints) {
        var _iteratorNormalCompletion12 = true;
        var _didIteratorError12 = false;
        var _iteratorError12 = undefined;

        try {
          for (var _iterator12 = options.indexHints[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
            var hint = _step12.value;

            if (IndexHints[hint.type]) {
              fragment += " ".concat(IndexHints[hint.type], " INDEX (").concat(hint.values.map(function (indexName) {
                return _this14.quoteIdentifiers(indexName);
              }).join(","), ")");
            }
          }
        } catch (err) {
          _didIteratorError12 = true;
          _iteratorError12 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
              _iterator12["return"]();
            }
          } finally {
            if (_didIteratorError12) {
              throw _iteratorError12;
            }
          }
        }
      }

      return fragment;
    }
  }, {
    key: "addLimitAndOffset",
    value: function addLimitAndOffset(options) {
      var fragment = "";

      if (options.offset != null && options.limit == null) {
        fragment += " LIMIT " + this.escape(options.offset) + ", " + 1e13;
      } else if (options.limit != null) {
        if (options.offset != null) {
          fragment += " LIMIT " + this.escape(options.offset) + ", " + this.escape(options.limit);
        } else {
          fragment += " LIMIT " + this.escape(options.limit);
        }
      }

      return fragment;
    }
  }, {
    key: "handleSequelizeMethod",
    value: function handleSequelizeMethod(smth, tableName, factory, options, prepend) {
      var _this15 = this;

      var result;

      if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {
        smth.comparator = this.OperatorMap[smth.comparator];
      }

      if (smth instanceof Utils.Where) {
        var value = smth.logic;
        var key;

        if (smth.attribute instanceof Utils.SequelizeMethod) {
          key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);
        } else {
          key = "".concat(this.quoteTable(smth.attribute.Model.name), ".").concat(this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName));
        }

        if (value && value instanceof Utils.SequelizeMethod) {
          value = this.getWhereConditions(value, tableName, factory, options, prepend);

          if (value === "NULL") {
            if (smth.comparator === "=") {
              smth.comparator = "IS";
            }

            if (smth.comparator === "!=") {
              smth.comparator = "IS NOT";
            }
          }

          return [key, value].join(" ".concat(smth.comparator, " "));
        }

        if (_.isPlainObject(value)) {
          return this.whereItemQuery(smth.attribute, value, {
            model: factory
          });
        }

        if ([this.OperatorMap[Op.between], this.OperatorMap[Op.notBetween]].includes(smth.comparator)) {
          value = "".concat(this.escape(value[0]), " AND ").concat(this.escape(value[1]));
        } else if (typeof value === "boolean") {
          value = this.booleanValue(value);
        } else {
          value = this.escape(value);
        }

        if (value === "NULL") {
          if (smth.comparator === "=") {
            smth.comparator = "IS";
          }

          if (smth.comparator === "!=") {
            smth.comparator = "IS NOT";
          }
        }

        return [key, value].join(" ".concat(smth.comparator, " "));
      }

      if (smth instanceof Utils.Literal) {
        return smth.val;
      }

      if (smth instanceof Utils.Cast) {
        if (smth.val instanceof Utils.SequelizeMethod) {
          result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);
        } else if (_.isPlainObject(smth.val)) {
          result = this.whereItemsQuery(smth.val);
        } else {
          result = this.escape(smth.val);
        }

        return "CAST(".concat(result, " AS ").concat(smth.type.toUpperCase(), ")");
      }

      if (smth instanceof Utils.Fn) {
        return "".concat(smth.fn, "(").concat(smth.args.map(function (arg) {
          if (arg instanceof Utils.SequelizeMethod) {
            return _this15.handleSequelizeMethod(arg, tableName, factory, options, prepend);
          }

          if (_.isPlainObject(arg)) {
            return _this15.whereItemsQuery(arg);
          }

          return _this15.escape(typeof arg === "string" ? arg.replace(/\$/g, "$$$") : arg);
        }).join(", "), ")");
      }

      if (smth instanceof Utils.Col) {
        if (Array.isArray(smth.col) && !factory) {
          throw new Error("Cannot call Sequelize.col() with array outside of order / group clause");
        }

        if (smth.col.startsWith("*")) {
          return "*";
        }

        return this.quote(smth.col, factory);
      }

      return smth.toString(this, factory);
    }
  }, {
    key: "whereQuery",
    value: function whereQuery(where, options) {
      var query = this.whereItemsQuery(where, options);

      if (query && query.length) {
        return "WHERE ".concat(query);
      }

      return "";
    }
  }, {
    key: "whereItemsQuery",
    value: function whereItemsQuery(where, options, binding) {
      var _this16 = this;

      if (where === null || where === void 0 || Utils.getComplexSize(where) === 0) {
        return "";
      }

      if (typeof where === "string") {
        throw new Error("Support for `{where: 'raw query'}` has been removed.");
      }

      var items = [];
      binding = binding || "AND";
      if (binding[0] !== " ") binding = " ".concat(binding, " ");

      if (_.isPlainObject(where)) {
        Utils.getComplexKeys(where).forEach(function (prop) {
          var item = where[prop];
          items.push(_this16.whereItemQuery(prop, item, options));
        });
      } else {
        items.push(this.whereItemQuery(void 0, where, options));
      }

      return items.length && items.filter(function (item) {
        return item && item.length;
      }).join(binding) || "";
    }
  }, {
    key: "whereItemQuery",
    value: function whereItemQuery(key, value) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (value === void 0) {
        throw new Error("WHERE parameter \"".concat(key, "\" has invalid \"undefined\" value"));
      }

      if (typeof key === "string" && key.includes(".") && options.model) {
        var keyParts = key.split(".");

        if (options.model.rawAttributes[keyParts[0]] && options.model.rawAttributes[keyParts[0]].type instanceof DataTypes.JSON) {
          var tmp = {};
          var field2 = options.model.rawAttributes[keyParts[0]];

          _.set(tmp, keyParts.slice(1), value);

          return this.whereItemQuery(field2.field || keyParts[0], tmp, __spreadValues({
            field: field2
          }, options));
        }
      }

      var field = this._findField(key, options);

      var fieldType = field && field.type || options.type;

      var isPlainObject = _.isPlainObject(value);

      var isArray = !isPlainObject && Array.isArray(value);
      key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;

      if (isPlainObject) {
        value = this._replaceAliases(value);
      }

      var valueKeys = isPlainObject && Utils.getComplexKeys(value);

      if (key === void 0) {
        if (typeof value === "string") {
          return value;
        }

        if (isPlainObject && valueKeys.length === 1) {
          return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);
        }
      }

      if (value === null) {
        var opValue2 = options.bindParam ? "NULL" : this.escape(value, field);
        return this._joinKeyValue(key, opValue2, this.OperatorMap[Op.is], options.prefix);
      }

      if (!value) {
        var _opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);

        return this._joinKeyValue(key, _opValue, this.OperatorMap[Op.eq], options.prefix);
      }

      if (value instanceof Utils.SequelizeMethod && !(key !== void 0 && value instanceof Utils.Fn)) {
        return this.handleSequelizeMethod(value);
      }

      if (key === void 0 && isArray) {
        if (Utils.canTreatArrayAsAnd(value)) {
          key = Op.and;
        } else {
          throw new Error("Support for literal replacements in the `where` object has been removed.");
        }
      }

      if (key === Op.or || key === Op.and || key === Op.not) {
        return this._whereGroupBind(key, value, options);
      }

      if (value[Op.or]) {
        return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);
      }

      if (value[Op.and]) {
        return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);
      }

      if (isArray && fieldType instanceof DataTypes.ARRAY) {
        var _opValue2 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);

        return this._joinKeyValue(key, _opValue2, this.OperatorMap[Op.eq], options.prefix);
      }

      if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {
        return this._whereJSON(key, value, options);
      }

      if (isPlainObject && valueKeys.length > 1) {
        return this._whereBind(this.OperatorMap[Op.and], key, value, options);
      }

      if (isArray) {
        return this._whereParseSingleValueObject(key, field, Op["in"], value, options);
      }

      if (isPlainObject) {
        if (this.OperatorMap[valueKeys[0]]) {
          return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);
        }

        return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);
      }

      if (key === Op.placeholder) {
        var _opValue3 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);

        return this._joinKeyValue(this.OperatorMap[key], _opValue3, this.OperatorMap[Op.eq], options.prefix);
      }

      var opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);
    }
  }, {
    key: "_findField",
    value: function _findField(key, options) {
      if (options.field) {
        return options.field;
      }

      if (options.model && options.model.rawAttributes && options.model.rawAttributes[key]) {
        return options.model.rawAttributes[key];
      }

      if (options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]) {
        return options.model.fieldRawAttributesMap[key];
      }
    }
  }, {
    key: "_whereGroupBind",
    value: function _whereGroupBind(key, value, options) {
      var _this17 = this;

      var binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];
      var outerBinding = key === Op.not ? "NOT " : "";

      if (Array.isArray(value)) {
        value = value.map(function (item) {
          var itemQuery = _this17.whereItemsQuery(item, options, _this17.OperatorMap[Op.and]);

          if (itemQuery && itemQuery.length && (Array.isArray(item) || _.isPlainObject(item)) && Utils.getComplexSize(item) > 1) {
            itemQuery = "(".concat(itemQuery, ")");
          }

          return itemQuery;
        }).filter(function (item) {
          return item && item.length;
        });
        value = value.length && value.join(binding);
      } else {
        value = this.whereItemsQuery(value, options, binding);
      }

      if ((key === Op.or || key === Op.not) && !value) {
        return "0 = 1";
      }

      return value ? "".concat(outerBinding, "(").concat(value, ")") : void 0;
    }
  }, {
    key: "_whereBind",
    value: function _whereBind(binding, key, value, options) {
      var _this18 = this;

      if (_.isPlainObject(value)) {
        value = Utils.getComplexKeys(value).map(function (prop) {
          var item = value[prop];
          return _this18.whereItemQuery(key, _defineProperty({}, prop, item), options);
        });
      } else {
        value = value.map(function (item) {
          return _this18.whereItemQuery(key, item, options);
        });
      }

      value = value.filter(function (item) {
        return item && item.length;
      });
      return value.length ? "(".concat(value.join(binding), ")") : void 0;
    }
  }, {
    key: "_whereJSON",
    value: function _whereJSON(key, value, options) {
      var _this19 = this;

      var items = [];
      var baseKey = this.quoteIdentifier(key);

      if (options.prefix) {
        if (options.prefix instanceof Utils.Literal) {
          baseKey = "".concat(this.handleSequelizeMethod(options.prefix), ".").concat(baseKey);
        } else {
          baseKey = "".concat(this.quoteTable(options.prefix), ".").concat(baseKey);
        }
      }

      Utils.getOperators(value).forEach(function (op) {
        var where = _defineProperty({}, op, value[op]);

        items.push(_this19.whereItemQuery(key, where, __spreadProps(__spreadValues({}, options), {
          json: false
        })));
      });

      _.forOwn(value, function (item, prop) {
        _this19._traverseJSON(items, baseKey, prop, item, [prop]);
      });

      var result = items.join(this.OperatorMap[Op.and]);
      return items.length > 1 ? "(".concat(result, ")") : result;
    }
  }, {
    key: "_traverseJSON",
    value: function _traverseJSON(items, baseKey, prop, item, path) {
      var _this20 = this;

      var cast;

      if (path[path.length - 1].includes("::")) {
        var tmp = path[path.length - 1].split("::");
        cast = tmp[1];
        path[path.length - 1] = tmp[0];
      }

      var pathKey = this.jsonPathExtractionQuery(baseKey, path);

      if (_.isPlainObject(item)) {
        Utils.getOperators(item).forEach(function (op) {
          var value = _this20._toJSONValue(item[op]);

          var isJson = false;

          if (typeof value === "string" && op === Op.contains) {
            try {
              JSON.stringify(value);
              isJson = true;
            } catch (e) {}
          }

          pathKey = _this20.jsonPathExtractionQuery(baseKey, path, isJson);
          items.push(_this20.whereItemQuery(_this20._castKey(pathKey, value, cast), _defineProperty({}, op, value)));
        });

        _.forOwn(item, function (value, itemProp) {
          _this20._traverseJSON(items, baseKey, itemProp, value, path.concat([itemProp]));
        });

        return;
      }

      item = this._toJSONValue(item);
      items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), _defineProperty({}, Op.eq, item)));
    }
  }, {
    key: "_toJSONValue",
    value: function _toJSONValue(value) {
      return value;
    }
  }, {
    key: "_castKey",
    value: function _castKey(key, value, cast, json) {
      cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);

      if (cast) {
        return new Utils.Literal(this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast, json)));
      }

      return new Utils.Literal(key);
    }
  }, {
    key: "_getJsonCast",
    value: function _getJsonCast(value) {
      if (typeof value === "number") {
        return "double precision";
      }

      if (value instanceof Date) {
        return "timestamptz";
      }

      if (typeof value === "boolean") {
        return "boolean";
      }

      return;
    }
  }, {
    key: "_joinKeyValue",
    value: function _joinKeyValue(key, value, comparator, prefix) {
      if (!key) {
        return value;
      }

      if (comparator === void 0) {
        throw new Error("".concat(key, " and ").concat(value, " has no comparator"));
      }

      key = this._getSafeKey(key, prefix);
      return [key, value].join(" ".concat(comparator, " "));
    }
  }, {
    key: "_getSafeKey",
    value: function _getSafeKey(key, prefix) {
      var _this21 = this;

      if (key instanceof Utils.SequelizeMethod) {
        key = this.handleSequelizeMethod(key);
        return this._prefixKey(this.handleSequelizeMethod(key), prefix);
      }

      if (Utils.isColString(key)) {
        key = key.substr(1, key.length - 2).split(".");

        if (key.length > 2) {
          key = [key.slice(0, -1).join("->"), key[key.length - 1]];
        }

        return key.map(function (identifier) {
          return _this21.quoteIdentifier(identifier);
        }).join(".");
      }

      return this._prefixKey(this.quoteIdentifier(key), prefix);
    }
  }, {
    key: "_prefixKey",
    value: function _prefixKey(key, prefix) {
      if (prefix) {
        if (prefix instanceof Utils.Literal) {
          return [this.handleSequelizeMethod(prefix), key].join(".");
        }

        return [this.quoteTable(prefix), key].join(".");
      }

      return key;
    }
  }, {
    key: "_whereParseSingleValueObject",
    value: function _whereParseSingleValueObject(key, field, prop, value, options) {
      var _this22 = this;

      if (prop === Op.not) {
        if (Array.isArray(value)) {
          prop = Op.notIn;
        } else if (value !== null && value !== true && value !== false) {
          prop = Op.ne;
        }
      }

      var comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];

      switch (prop) {
        case Op["in"]:
        case Op.notIn:
          if (value instanceof Utils.Literal) {
            return this._joinKeyValue(key, value.val, comparator, options.prefix);
          }

          if (value.length) {
            return this._joinKeyValue(key, "(".concat(value.map(function (item) {
              return _this22.escape(item, field);
            }).join(", "), ")"), comparator, options.prefix);
          }

          if (comparator === this.OperatorMap[Op["in"]]) {
            return this._joinKeyValue(key, "(NULL)", comparator, options.prefix);
          }

          return "";

        case Op.any:
        case Op.all:
          comparator = "".concat(this.OperatorMap[Op.eq], " ").concat(comparator);

          if (value[Op.values]) {
            return this._joinKeyValue(key, "(VALUES ".concat(value[Op.values].map(function (item) {
              return "(".concat(_this22.escape(item), ")");
            }).join(", "), ")"), comparator, options.prefix);
          }

          return this._joinKeyValue(key, "(".concat(this.escape(value, field), ")"), comparator, options.prefix);

        case Op.between:
        case Op.notBetween:
          return this._joinKeyValue(key, "".concat(this.escape(value[0], field), " AND ").concat(this.escape(value[1], field)), comparator, options.prefix);

        case Op.raw:
          throw new Error("The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.");

        case Op.col:
          comparator = this.OperatorMap[Op.eq];
          value = value.split(".");

          if (value.length > 2) {
            value = [value.slice(0, -1).join("->"), value[value.length - 1]];
          }

          return this._joinKeyValue(key, value.map(function (identifier) {
            return _this22.quoteIdentifier(identifier);
          }).join("."), comparator, options.prefix);

        case Op.startsWith:
        case Op.endsWith:
        case Op.substring:
          comparator = this.OperatorMap[Op.like];

          if (value instanceof Utils.Literal) {
            value = value.val;
          }

          var pattern = "".concat(value, "%");
          if (prop === Op.endsWith) pattern = "%".concat(value);
          if (prop === Op.substring) pattern = "%".concat(value, "%");
          return this._joinKeyValue(key, this.escape(pattern), comparator, options.prefix);
      }

      var escapeOptions = {
        acceptStrings: comparator.includes(this.OperatorMap[Op.like])
      };

      if (_.isPlainObject(value)) {
        if (value[Op.col]) {
          return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);
        }

        if (value[Op.any]) {
          escapeOptions.isList = true;
          return this._joinKeyValue(key, "(".concat(this.escape(value[Op.any], field, escapeOptions), ")"), "".concat(comparator, " ").concat(this.OperatorMap[Op.any]), options.prefix);
        }

        if (value[Op.all]) {
          escapeOptions.isList = true;
          return this._joinKeyValue(key, "(".concat(this.escape(value[Op.all], field, escapeOptions), ")"), "".concat(comparator, " ").concat(this.OperatorMap[Op.all]), options.prefix);
        }
      }

      if (value === null && comparator === this.OperatorMap[Op.eq]) {
        return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);
      }

      if (value === null && comparator === this.OperatorMap[Op.ne]) {
        return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);
      }

      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);
    }
  }, {
    key: "getWhereConditions",
    value: function getWhereConditions(smth, tableName, factory, options, prepend) {
      var where = {};

      if (Array.isArray(tableName)) {
        tableName = tableName[0];

        if (Array.isArray(tableName)) {
          tableName = tableName[1];
        }
      }

      options = options || {};

      if (prepend === void 0) {
        prepend = true;
      }

      if (smth && smth instanceof Utils.SequelizeMethod) {
        return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);
      }

      if (_.isPlainObject(smth)) {
        return this.whereItemsQuery(smth, {
          model: factory,
          prefix: prepend && tableName,
          type: options.type
        });
      }

      if (typeof smth === "number" || typeof smth === "bigint") {
        var primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];

        if (primaryKeys.length > 0) {
          primaryKeys = primaryKeys[0];
        } else {
          primaryKeys = "id";
        }

        where[primaryKeys] = smth;
        return this.whereItemsQuery(where, {
          model: factory,
          prefix: prepend && tableName
        });
      }

      if (typeof smth === "string") {
        return this.whereItemsQuery(smth, {
          model: factory,
          prefix: prepend && tableName
        });
      }

      if (Buffer.isBuffer(smth)) {
        return this.escape(smth);
      }

      if (Array.isArray(smth)) {
        if (smth.length === 0 || smth.length > 0 && smth[0].length === 0) return "1=1";

        if (Utils.canTreatArrayAsAnd(smth)) {
          var _smth = _defineProperty({}, Op.and, smth);

          return this.getWhereConditions(_smth, tableName, factory, options, prepend);
        }

        throw new Error("Support for literal replacements in the `where` object has been removed.");
      }

      if (smth == null) {
        return this.whereItemsQuery(smth, {
          model: factory,
          prefix: prepend && tableName
        });
      }

      throw new Error("Unsupported where option value: ".concat(util.inspect(smth), ". Please refer to the Sequelize documentation to learn more about which values are accepted as part of the where option."));
    }
  }, {
    key: "parseConditionObject",
    value: function parseConditionObject(conditions, path) {
      var _this23 = this;

      path = path || [];
      return _.reduce(conditions, function (result, value, key) {
        if (_.isObject(value)) {
          return result.concat(_this23.parseConditionObject(value, path.concat(key)));
        }

        result.push({
          path: path.concat(key),
          value: value
        });
        return result;
      }, []);
    }
  }, {
    key: "booleanValue",
    value: function booleanValue(value) {
      return value;
    }
  }, {
    key: "authTestQuery",
    value: function authTestQuery() {
      return "SELECT 1+1 AS result";
    }
  }]);

  return QueryGenerator;
}();

Object.assign(QueryGenerator.prototype, require("./query-generator/operators"));
Object.assign(QueryGenerator.prototype, require("./query-generator/transaction"));
module.exports = QueryGenerator;