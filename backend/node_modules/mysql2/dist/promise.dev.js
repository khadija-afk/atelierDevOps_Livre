'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var core = require('./index.js');

var EventEmitter = require('events').EventEmitter;

var parserCache = require('./lib/parsers/parser_cache.js');

function makeDoneCb(resolve, reject, localErr) {
  return function (err, rows, fields) {
    if (err) {
      localErr.message = err.message;
      localErr.code = err.code;
      localErr.errno = err.errno;
      localErr.sql = err.sql;
      localErr.sqlState = err.sqlState;
      localErr.sqlMessage = err.sqlMessage;
      reject(localErr);
    } else {
      resolve([rows, fields]);
    }
  };
}

function inheritEvents(source, target, events) {
  var listeners = {};
  target.on('newListener', function (eventName) {
    if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {
      source.on(eventName, listeners[eventName] = function () {
        var args = [].slice.call(arguments);
        args.unshift(eventName);
        target.emit.apply(target, args);
      });
    }
  }).on('removeListener', function (eventName) {
    if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {
      source.removeListener(eventName, listeners[eventName]);
      delete listeners[eventName];
    }
  });
}

var PromisePreparedStatementInfo =
/*#__PURE__*/
function () {
  function PromisePreparedStatementInfo(statement, promiseImpl) {
    _classCallCheck(this, PromisePreparedStatementInfo);

    this.statement = statement;
    this.Promise = promiseImpl;
  }

  _createClass(PromisePreparedStatementInfo, [{
    key: "execute",
    value: function execute(parameters) {
      var s = this.statement;
      var localErr = new Error();
      return new this.Promise(function (resolve, reject) {
        var done = makeDoneCb(resolve, reject, localErr);

        if (parameters) {
          s.execute(parameters, done);
        } else {
          s.execute(done);
        }
      });
    }
  }, {
    key: "close",
    value: function close() {
      var _this = this;

      return new this.Promise(function (resolve) {
        _this.statement.close();

        resolve();
      });
    }
  }]);

  return PromisePreparedStatementInfo;
}();

var PromiseConnection =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(PromiseConnection, _EventEmitter);

  function PromiseConnection(connection, promiseImpl) {
    var _this2;

    _classCallCheck(this, PromiseConnection);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(PromiseConnection).call(this));
    _this2.connection = connection;
    _this2.Promise = promiseImpl || Promise;
    inheritEvents(connection, _assertThisInitialized(_this2), ['error', 'drain', 'connect', 'end', 'enqueue']);
    return _this2;
  }

  _createClass(PromiseConnection, [{
    key: "release",
    value: function release() {
      this.connection.release();
    }
  }, {
    key: "query",
    value: function query(_query, params) {
      var c = this.connection;
      var localErr = new Error();

      if (typeof params === 'function') {
        throw new Error('Callback function is not available with promise clients.');
      }

      return new this.Promise(function (resolve, reject) {
        var done = makeDoneCb(resolve, reject, localErr);

        if (params !== undefined) {
          c.query(_query, params, done);
        } else {
          c.query(_query, done);
        }
      });
    }
  }, {
    key: "execute",
    value: function execute(query, params) {
      var c = this.connection;
      var localErr = new Error();

      if (typeof params === 'function') {
        throw new Error('Callback function is not available with promise clients.');
      }

      return new this.Promise(function (resolve, reject) {
        var done = makeDoneCb(resolve, reject, localErr);

        if (params !== undefined) {
          c.execute(query, params, done);
        } else {
          c.execute(query, done);
        }
      });
    }
  }, {
    key: "end",
    value: function end() {
      var _this3 = this;

      return new this.Promise(function (resolve) {
        _this3.connection.end(resolve);
      });
    }
  }, {
    key: "beginTransaction",
    value: function beginTransaction() {
      var c = this.connection;
      var localErr = new Error();
      return new this.Promise(function (resolve, reject) {
        var done = makeDoneCb(resolve, reject, localErr);
        c.beginTransaction(done);
      });
    }
  }, {
    key: "commit",
    value: function commit() {
      var c = this.connection;
      var localErr = new Error();
      return new this.Promise(function (resolve, reject) {
        var done = makeDoneCb(resolve, reject, localErr);
        c.commit(done);
      });
    }
  }, {
    key: "rollback",
    value: function rollback() {
      var c = this.connection;
      var localErr = new Error();
      return new this.Promise(function (resolve, reject) {
        var done = makeDoneCb(resolve, reject, localErr);
        c.rollback(done);
      });
    }
  }, {
    key: "ping",
    value: function ping() {
      var c = this.connection;
      var localErr = new Error();
      return new this.Promise(function (resolve, reject) {
        c.ping(function (err) {
          if (err) {
            localErr.message = err.message;
            localErr.code = err.code;
            localErr.errno = err.errno;
            localErr.sqlState = err.sqlState;
            localErr.sqlMessage = err.sqlMessage;
            reject(localErr);
          } else {
            resolve(true);
          }
        });
      });
    }
  }, {
    key: "connect",
    value: function connect() {
      var c = this.connection;
      var localErr = new Error();
      return new this.Promise(function (resolve, reject) {
        c.connect(function (err, param) {
          if (err) {
            localErr.message = err.message;
            localErr.code = err.code;
            localErr.errno = err.errno;
            localErr.sqlState = err.sqlState;
            localErr.sqlMessage = err.sqlMessage;
            reject(localErr);
          } else {
            resolve(param);
          }
        });
      });
    }
  }, {
    key: "prepare",
    value: function prepare(options) {
      var c = this.connection;
      var promiseImpl = this.Promise;
      var localErr = new Error();
      return new this.Promise(function (resolve, reject) {
        c.prepare(options, function (err, statement) {
          if (err) {
            localErr.message = err.message;
            localErr.code = err.code;
            localErr.errno = err.errno;
            localErr.sqlState = err.sqlState;
            localErr.sqlMessage = err.sqlMessage;
            reject(localErr);
          } else {
            var wrappedStatement = new PromisePreparedStatementInfo(statement, promiseImpl);
            resolve(wrappedStatement);
          }
        });
      });
    }
  }, {
    key: "changeUser",
    value: function changeUser(options) {
      var c = this.connection;
      var localErr = new Error();
      return new this.Promise(function (resolve, reject) {
        c.changeUser(options, function (err) {
          if (err) {
            localErr.message = err.message;
            localErr.code = err.code;
            localErr.errno = err.errno;
            localErr.sqlState = err.sqlState;
            localErr.sqlMessage = err.sqlMessage;
            reject(localErr);
          } else {
            resolve();
          }
        });
      });
    }
  }, {
    key: "config",
    get: function get() {
      return this.connection.config;
    }
  }, {
    key: "threadId",
    get: function get() {
      return this.connection.threadId;
    }
  }]);

  return PromiseConnection;
}(EventEmitter);

function createConnection(opts) {
  var coreConnection = core.createConnection(opts);
  var createConnectionErr = new Error();
  var thePromise = opts.Promise || Promise;

  if (!thePromise) {
    throw new Error('no Promise implementation available.' + 'Use promise-enabled node version or pass userland Promise' + " implementation as parameter, for example: { Promise: require('bluebird') }");
  }

  return new thePromise(function (resolve, reject) {
    coreConnection.once('connect', function () {
      resolve(new PromiseConnection(coreConnection, thePromise));
    });
    coreConnection.once('error', function (err) {
      createConnectionErr.message = err.message;
      createConnectionErr.code = err.code;
      createConnectionErr.errno = err.errno;
      createConnectionErr.sqlState = err.sqlState;
      reject(createConnectionErr);
    });
  });
} // note: the callback of "changeUser" is not called on success
// hence there is no possibility to call "resolve"
// patching PromiseConnection
// create facade functions for prototype functions on "Connection" that are not yet
// implemented with PromiseConnection
// proxy synchronous functions only


(function (functionsToWrap) {
  for (var i = 0; functionsToWrap && i < functionsToWrap.length; i++) {
    var func = functionsToWrap[i];

    if (typeof core.Connection.prototype[func] === 'function' && PromiseConnection.prototype[func] === undefined) {
      PromiseConnection.prototype[func] = function factory(funcName) {
        return function () {
          return core.Connection.prototype[funcName].apply(this.connection, arguments);
        };
      }(func);
    }
  }
})([// synchronous functions
'close', 'createBinlogStream', 'destroy', 'escape', 'escapeId', 'format', 'pause', 'pipe', 'resume', 'unprepare']);

var PromisePoolConnection =
/*#__PURE__*/
function (_PromiseConnection) {
  _inherits(PromisePoolConnection, _PromiseConnection);

  function PromisePoolConnection(connection, promiseImpl) {
    _classCallCheck(this, PromisePoolConnection);

    return _possibleConstructorReturn(this, _getPrototypeOf(PromisePoolConnection).call(this, connection, promiseImpl));
  }

  _createClass(PromisePoolConnection, [{
    key: "destroy",
    value: function destroy() {
      return core.PoolConnection.prototype.destroy.apply(this.connection, arguments);
    }
  }]);

  return PromisePoolConnection;
}(PromiseConnection);

var PromisePool =
/*#__PURE__*/
function (_EventEmitter2) {
  _inherits(PromisePool, _EventEmitter2);

  function PromisePool(pool, thePromise) {
    var _this4;

    _classCallCheck(this, PromisePool);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(PromisePool).call(this));
    _this4.pool = pool;
    _this4.Promise = thePromise || Promise;
    inheritEvents(pool, _assertThisInitialized(_this4), ['acquire', 'connection', 'enqueue', 'release']);
    return _this4;
  }

  _createClass(PromisePool, [{
    key: "getConnection",
    value: function getConnection() {
      var _this5 = this;

      var corePool = this.pool;
      return new this.Promise(function (resolve, reject) {
        corePool.getConnection(function (err, coreConnection) {
          if (err) {
            reject(err);
          } else {
            resolve(new PromisePoolConnection(coreConnection, _this5.Promise));
          }
        });
      });
    }
  }, {
    key: "releaseConnection",
    value: function releaseConnection(connection) {
      if (connection instanceof PromisePoolConnection) connection.release();
    }
  }, {
    key: "query",
    value: function query(sql, args) {
      var corePool = this.pool;
      var localErr = new Error();

      if (typeof args === 'function') {
        throw new Error('Callback function is not available with promise clients.');
      }

      return new this.Promise(function (resolve, reject) {
        var done = makeDoneCb(resolve, reject, localErr);

        if (args !== undefined) {
          corePool.query(sql, args, done);
        } else {
          corePool.query(sql, done);
        }
      });
    }
  }, {
    key: "execute",
    value: function execute(sql, args) {
      var corePool = this.pool;
      var localErr = new Error();

      if (typeof args === 'function') {
        throw new Error('Callback function is not available with promise clients.');
      }

      return new this.Promise(function (resolve, reject) {
        var done = makeDoneCb(resolve, reject, localErr);

        if (args) {
          corePool.execute(sql, args, done);
        } else {
          corePool.execute(sql, done);
        }
      });
    }
  }, {
    key: "end",
    value: function end() {
      var corePool = this.pool;
      var localErr = new Error();
      return new this.Promise(function (resolve, reject) {
        corePool.end(function (err) {
          if (err) {
            localErr.message = err.message;
            localErr.code = err.code;
            localErr.errno = err.errno;
            localErr.sqlState = err.sqlState;
            localErr.sqlMessage = err.sqlMessage;
            reject(localErr);
          } else {
            resolve();
          }
        });
      });
    }
  }]);

  return PromisePool;
}(EventEmitter);

function createPool(opts) {
  var corePool = core.createPool(opts);
  var thePromise = opts.Promise || Promise;

  if (!thePromise) {
    throw new Error('no Promise implementation available.' + 'Use promise-enabled node version or pass userland Promise' + " implementation as parameter, for example: { Promise: require('bluebird') }");
  }

  return new PromisePool(corePool, thePromise);
}

(function (functionsToWrap) {
  for (var i = 0; functionsToWrap && i < functionsToWrap.length; i++) {
    var func = functionsToWrap[i];

    if (typeof core.Pool.prototype[func] === 'function' && PromisePool.prototype[func] === undefined) {
      PromisePool.prototype[func] = function factory(funcName) {
        return function () {
          return core.Pool.prototype[funcName].apply(this.pool, arguments);
        };
      }(func);
    }
  }
})([// synchronous functions
'escape', 'escapeId', 'format']);

var PromisePoolCluster =
/*#__PURE__*/
function (_EventEmitter3) {
  _inherits(PromisePoolCluster, _EventEmitter3);

  function PromisePoolCluster(poolCluster, thePromise) {
    var _this6;

    _classCallCheck(this, PromisePoolCluster);

    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(PromisePoolCluster).call(this));
    _this6.poolCluster = poolCluster;
    _this6.Promise = thePromise || Promise;
    inheritEvents(poolCluster, _assertThisInitialized(_this6), ['warn', 'remove']);
    return _this6;
  }

  _createClass(PromisePoolCluster, [{
    key: "getConnection",
    value: function getConnection() {
      var _this7 = this;

      var corePoolCluster = this.poolCluster;
      return new this.Promise(function (resolve, reject) {
        corePoolCluster.getConnection(function (err, coreConnection) {
          if (err) {
            reject(err);
          } else {
            resolve(new PromisePoolConnection(coreConnection, _this7.Promise));
          }
        });
      });
    }
  }, {
    key: "query",
    value: function query(sql, args) {
      var corePoolCluster = this.poolCluster;
      var localErr = new Error();

      if (typeof args === 'function') {
        throw new Error('Callback function is not available with promise clients.');
      }

      return new this.Promise(function (resolve, reject) {
        var done = makeDoneCb(resolve, reject, localErr);
        corePoolCluster.query(sql, args, done);
      });
    }
  }, {
    key: "execute",
    value: function execute(sql, args) {
      var corePoolCluster = this.poolCluster;
      var localErr = new Error();

      if (typeof args === 'function') {
        throw new Error('Callback function is not available with promise clients.');
      }

      return new this.Promise(function (resolve, reject) {
        var done = makeDoneCb(resolve, reject, localErr);
        corePoolCluster.execute(sql, args, done);
      });
    }
  }, {
    key: "of",
    value: function of(pattern, selector) {
      return new PromisePoolCluster(this.poolCluster.of(pattern, selector), this.Promise);
    }
  }, {
    key: "end",
    value: function end() {
      var corePoolCluster = this.poolCluster;
      var localErr = new Error();
      return new this.Promise(function (resolve, reject) {
        corePoolCluster.end(function (err) {
          if (err) {
            localErr.message = err.message;
            localErr.code = err.code;
            localErr.errno = err.errno;
            localErr.sqlState = err.sqlState;
            localErr.sqlMessage = err.sqlMessage;
            reject(localErr);
          } else {
            resolve();
          }
        });
      });
    }
  }]);

  return PromisePoolCluster;
}(EventEmitter);
/**
 * proxy poolCluster synchronous functions
 */


(function (functionsToWrap) {
  for (var i = 0; functionsToWrap && i < functionsToWrap.length; i++) {
    var func = functionsToWrap[i];

    if (typeof core.PoolCluster.prototype[func] === 'function' && PromisePoolCluster.prototype[func] === undefined) {
      PromisePoolCluster.prototype[func] = function factory(funcName) {
        return function () {
          return core.PoolCluster.prototype[funcName].apply(this.poolCluster, arguments);
        };
      }(func);
    }
  }
})(['add']);

function createPoolCluster(opts) {
  var corePoolCluster = core.createPoolCluster(opts);
  var thePromise = opts && opts.Promise || Promise;

  if (!thePromise) {
    throw new Error('no Promise implementation available.' + 'Use promise-enabled node version or pass userland Promise' + " implementation as parameter, for example: { Promise: require('bluebird') }");
  }

  return new PromisePoolCluster(corePoolCluster, thePromise);
}

exports.createConnection = createConnection;
exports.createPool = createPool;
exports.createPoolCluster = createPoolCluster;
exports.escape = core.escape;
exports.escapeId = core.escapeId;
exports.format = core.format;
exports.raw = core.raw;
exports.PromisePool = PromisePool;
exports.PromiseConnection = PromiseConnection;
exports.PromisePoolConnection = PromisePoolConnection;

exports.__defineGetter__('Types', function () {
  return require('./lib/constants/types.js');
});

exports.__defineGetter__('Charsets', function () {
  return require('./lib/constants/charsets.js');
});

exports.__defineGetter__('CharsetToEncoding', function () {
  return require('./lib/constants/charset_encodings.js');
});

exports.setMaxParserCache = function (max) {
  parserCache.setMaxCache(max);
};

exports.clearParserCache = function () {
  parserCache.clearCache();
};