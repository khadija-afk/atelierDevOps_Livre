'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Packet = require('../packets/packet');

var StringParser = require('../parsers/string');

var CharsetToEncoding = require('../constants/charset_encodings.js');

var fields = ['catalog', 'schema', 'table', 'orgTable', 'name', 'orgName']; // creating JS string is relatively expensive (compared to
// reading few bytes from buffer) because all string properties
// except for name are unlikely to be used we postpone
// string conversion until property access
//
// TODO: watch for integration benchmarks (one with real network buffer)
// there could be bad side effect as keeping reference to a buffer makes it
// sit in the memory longer (usually until final .query() callback)
// Latest v8 perform much better in regard to bufferer -> string conversion,
// at some point of time this optimisation might become unnecessary
// see https://github.com/sidorares/node-mysql2/pull/137
//

var ColumnDefinition =
/*#__PURE__*/
function () {
  function ColumnDefinition(packet, clientEncoding) {
    _classCallCheck(this, ColumnDefinition);

    this._buf = packet.buffer;
    this._clientEncoding = clientEncoding;
    this._catalogLength = packet.readLengthCodedNumber();
    this._catalogStart = packet.offset;
    packet.offset += this._catalogLength;
    this._schemaLength = packet.readLengthCodedNumber();
    this._schemaStart = packet.offset;
    packet.offset += this._schemaLength;
    this._tableLength = packet.readLengthCodedNumber();
    this._tableStart = packet.offset;
    packet.offset += this._tableLength;
    this._orgTableLength = packet.readLengthCodedNumber();
    this._orgTableStart = packet.offset;
    packet.offset += this._orgTableLength; // name is always used, don't make it lazy

    var _nameLength = packet.readLengthCodedNumber();

    var _nameStart = packet.offset;
    packet.offset += _nameLength;
    this._orgNameLength = packet.readLengthCodedNumber();
    this._orgNameStart = packet.offset;
    packet.offset += this._orgNameLength;
    packet.skip(1); //  length of the following fields (always 0x0c)

    this.characterSet = packet.readInt16();
    this.encoding = CharsetToEncoding[this.characterSet];
    this.name = StringParser.decode(this._buf, this.encoding === 'binary' ? this._clientEncoding : this.encoding, _nameStart, _nameStart + _nameLength);
    this.columnLength = packet.readInt32();
    this.columnType = packet.readInt8();
    this.type = this.columnType;
    this.flags = packet.readInt16();
    this.decimals = packet.readInt8();
  }

  _createClass(ColumnDefinition, [{
    key: "inspect",
    value: function inspect() {
      return {
        catalog: this.catalog,
        schema: this.schema,
        name: this.name,
        orgName: this.orgName,
        table: this.table,
        orgTable: this.orgTable,
        characterSet: this.characterSet,
        encoding: this.encoding,
        columnLength: this.columnLength,
        type: this.columnType,
        flags: this.flags,
        decimals: this.decimals
      };
    }
  }, {
    key: Symbol["for"]('nodejs.util.inspect.custom'),
    value: function value(depth, inspectOptions, inspect) {
      var Types = require('../constants/types.js');

      var typeNames = [];

      for (var t in Types) {
        typeNames[Types[t]] = t;
      }

      var fiedFlags = require('../constants/field_flags.js');

      var flagNames = []; // TODO: respect inspectOptions.showHidden
      //const inspectFlags = inspectOptions.showHidden ? this.flags : this.flags & ~fiedFlags.PRI_KEY;

      var inspectFlags = this.flags;

      for (var f in fiedFlags) {
        if (inspectFlags & fiedFlags[f]) {
          if (f === 'PRI_KEY') {
            flagNames.push('PRIMARY KEY');
          } else if (f === 'NOT_NULL') {
            flagNames.push('NOT NULL');
          } else if (f === 'BINARY') {// ignore flag for now
          } else if (f === 'MULTIPLE_KEY') {// not sure if that should be part of inspection.
            // in the schema usually this is part of index definition
            // example: UNIQUE KEY `my_uniq_id` (`id_box_elements`,`id_router`)
            // note that only first column has MULTIPLE_KEY flag set in this case
            // so there is no good way of knowing that this is part of index just
            // by looking at indifidual field flags
          } else if (f === 'NO_DEFAULT_VALUE') {// almost the same as NOT_NULL?
          } else if (f === 'BLOB') {// included in the type
          } else if (f === 'UNSIGNED') {// this should be first after type
          } else if (f === 'TIMESTAMP') {// timestamp flag is redundant for inspection - already included in type
          } else if (f === 'ON_UPDATE_NOW') {
            flagNames.push('ON UPDATE CURRENT_TIMESTAMP');
          } else {
            flagNames.push(f);
          }
        }
      }

      if (depth > 1) {
        return inspect(_objectSpread({}, this.inspect(), {
          typeName: typeNames[this.columnType],
          flags: flagNames
        }));
      }

      var isUnsigned = this.flags & fiedFlags.UNSIGNED;
      var typeName = typeNames[this.columnType];

      if (typeName === 'BLOB') {
        // TODO: check for non-utf8mb4 encoding
        if (this.columnLength === 4294967295) {
          typeName = 'LONGTEXT';
        } else if (this.columnLength === 67108860) {
          typeName = 'MEDIUMTEXT';
        } else if (this.columnLength === 262140) {
          typeName = 'TEXT';
        } else if (this.columnLength === 1020) {
          // 255*4
          typeName = 'TINYTEXT';
        } else {
          typeName = "BLOB(".concat(this.columnLength, ")");
        }
      } else if (typeName === 'VAR_STRING') {
        // TODO: check for non-utf8mb4 encoding
        typeName = "VARCHAR(".concat(Math.ceil(this.columnLength / 4), ")");
      } else if (typeName === 'TINY') {
        if (this.columnLength === 3 && isUnsigned || this.columnLength === 4 && !isUnsigned) {
          typeName = 'TINYINT';
        } else {
          typeName = "TINYINT(".concat(this.columnLength, ")");
        }
      } else if (typeName === 'LONGLONG') {
        if (this.columnLength === 20) {
          typeName = 'BIGINT';
        } else {
          typeName = "BIGINT(".concat(this.columnLength, ")");
        }
      } else if (typeName === 'SHORT') {
        if (isUnsigned && this.columnLength === 5) {
          typeName = 'SMALLINT';
        } else if (!isUnsigned && this.columnLength === 6) {
          typeName = 'SMALLINT';
        } else {
          typeName = "SMALLINT(".concat(this.columnLength, ")");
        }
      } else if (typeName === 'LONG') {
        if (isUnsigned && this.columnLength === 10) {
          typeName = 'INT';
        } else if (!isUnsigned && this.columnLength === 11) {
          typeName = 'INT';
        } else {
          typeName = "INT(".concat(this.columnLength, ")");
        }
      } else if (typeName === 'INT24') {
        if (isUnsigned && this.columnLength === 8) {
          typeName = 'MEDIUMINT';
        } else if (!isUnsigned && this.columnLength === 9) {
          typeName = 'MEDIUMINT';
        } else {
          typeName = "MEDIUMINT(".concat(this.columnLength, ")");
        }
      } else if (typeName === 'DOUBLE') {
        // DOUBLE without modifiers is reported as DOUBLE(22, 31)
        if (this.columnLength === 22 && this.decimals === 31) {
          typeName = 'DOUBLE';
        } else {
          typeName = "DOUBLE(".concat(this.columnLength, ",").concat(this.decimals, ")");
        }
      } else if (typeName === 'FLOAT') {
        // FLOAT without modifiers is reported as FLOAT(12, 31)
        if (this.columnLength === 12 && this.decimals === 31) {
          typeName = 'FLOAT';
        } else {
          typeName = "FLOAT(".concat(this.columnLength, ",").concat(this.decimals, ")");
        }
      } else if (typeName === 'NEWDECIMAL') {
        if (this.columnLength === 11 && this.decimals === 0) {
          typeName = 'DECIMAL';
        } else if (this.decimals === 0) {
          // not sure why, but DECIMAL(13) is reported as DECIMAL(14, 0)
          // and DECIMAL(13, 9) is reported as NEWDECIMAL(15, 9)
          if (isUnsigned) {
            typeName = "DECIMAL(".concat(this.columnLength, ")");
          } else {
            typeName = "DECIMAL(".concat(this.columnLength - 1, ")");
          }
        } else {
          typeName = "DECIMAL(".concat(this.columnLength - 2, ",").concat(this.decimals, ")");
        }
      } else {
        typeName = "".concat(typeNames[this.columnType], "(").concat(this.columnLength, ")");
      }

      if (isUnsigned) {
        typeName += ' UNSIGNED';
      } // TODO respect colors option


      return "`".concat(this.name, "` ").concat([typeName].concat(flagNames).join(' '));
    }
  }, {
    key: "db",
    // node-mysql compatibility: alias "db" to "schema"
    get: function get() {
      return this.schema;
    }
  }], [{
    key: "toPacket",
    value: function toPacket(column, sequenceId) {
      var length = 17; // = 4 padding + 1 + 12 for the rest

      fields.forEach(function (field) {
        length += Packet.lengthCodedStringLength(column[field], CharsetToEncoding[column.characterSet]);
      });
      var buffer = Buffer.allocUnsafe(length);
      var packet = new Packet(sequenceId, buffer, 0, length);

      function writeField(name) {
        packet.writeLengthCodedString(column[name], CharsetToEncoding[column.characterSet]);
      }

      packet.offset = 4;
      fields.forEach(writeField);
      packet.writeInt8(0x0c);
      packet.writeInt16(column.characterSet);
      packet.writeInt32(column.columnLength);
      packet.writeInt8(column.columnType);
      packet.writeInt16(column.flags);
      packet.writeInt8(column.decimals);
      packet.writeInt16(0); // filler

      return packet;
    }
  }]);

  return ColumnDefinition;
}();

var addString = function addString(name) {
  Object.defineProperty(ColumnDefinition.prototype, name, {
    get: function get() {
      var start = this["_".concat(name, "Start")];
      var end = start + this["_".concat(name, "Length")];
      var val = StringParser.decode(this._buf, this.encoding === 'binary' ? this._clientEncoding : this.encoding, start, end);
      Object.defineProperty(this, name, {
        value: val,
        writable: false,
        configurable: false,
        enumerable: false
      });
      return val;
    }
  });
};

addString('catalog');
addString('schema');
addString('table');
addString('orgTable');
addString('orgName');
module.exports = ColumnDefinition;