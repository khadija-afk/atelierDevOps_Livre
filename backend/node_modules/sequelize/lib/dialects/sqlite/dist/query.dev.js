"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _ = require("lodash");

var Utils = require("../../utils");

var AbstractQuery = require("../abstract/query");

var QueryTypes = require("../../query-types");

var sequelizeErrors = require("../../errors");

var parserStore = require("../parserStore")("sqlite");

var _require = require("../../utils/logger"),
    logger = _require.logger;

var debug = logger.debugContext("sql:sqlite");

function stringifyIfBigint(value) {
  if (typeof value === "bigint") {
    return value.toString();
  }

  return value;
}

var Query =
/*#__PURE__*/
function (_AbstractQuery) {
  _inherits(Query, _AbstractQuery);

  function Query() {
    _classCallCheck(this, Query);

    return _possibleConstructorReturn(this, _getPrototypeOf(Query).apply(this, arguments));
  }

  _createClass(Query, [{
    key: "getInsertIdField",
    value: function getInsertIdField() {
      return "lastID";
    }
  }, {
    key: "_collectModels",
    value: function _collectModels(include, prefix) {
      var ret = {};

      if (include) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = include[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _include = _step.value;
            var key = void 0;

            if (!prefix) {
              key = _include.as;
            } else {
              key = "".concat(prefix, ".").concat(_include.as);
            }

            ret[key] = _include.model;

            if (_include.include) {
              _.merge(ret, this._collectModels(_include.include, key));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return ret;
    }
  }, {
    key: "_handleQueryResponse",
    value: function _handleQueryResponse(metaData, columnTypes, err, results, errStack) {
      var _this = this;

      if (err) {
        err.sql = this.sql;
        throw this.formatError(err, errStack);
      }

      var result = this.instance;

      if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {
        this.handleInsertQuery(results, metaData);

        if (!this.instance) {
          if (metaData.constructor.name === "Statement" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {
            var startId = metaData[this.getInsertIdField()] - metaData.changes + 1;
            result = [];

            for (var i = startId; i < startId + metaData.changes; i++) {
              result.push(_defineProperty({}, this.model.rawAttributes[this.model.primaryKeyAttribute].field, i));
            }
          } else {
            result = metaData[this.getInsertIdField()];
          }
        }
      }

      if (this.isShowTablesQuery()) {
        return results.map(function (row) {
          return row.name;
        });
      }

      if (this.isShowConstraintsQuery()) {
        result = results;

        if (results && results[0] && results[0].sql) {
          result = this.parseConstraintsFromSql(results[0].sql);
        }

        return result;
      }

      if (this.isSelectQuery()) {
        if (this.options.raw) {
          return this.handleSelectQuery(results);
        }

        var prefixes = this._collectModels(this.options.include);

        results = results.map(function (result2) {
          return _.mapValues(result2, function (value, name) {
            var model;

            if (name.includes(".")) {
              var lastind = name.lastIndexOf(".");
              model = prefixes[name.substr(0, lastind)];
              name = name.substr(lastind + 1);
            } else {
              model = _this.options.model;
            }

            var tableName = model.getTableName().toString().replace(/`/g, "");
            var tableTypes = columnTypes[tableName] || {};

            if (tableTypes && !(name in tableTypes)) {
              _.forOwn(model.rawAttributes, function (attribute, key) {
                if (name === key && attribute.field) {
                  name = attribute.field;
                  return false;
                }
              });
            }

            return Object.prototype.hasOwnProperty.call(tableTypes, name) ? _this.applyParsers(tableTypes[name], value) : value;
          });
        });
        return this.handleSelectQuery(results);
      }

      if (this.isShowOrDescribeQuery()) {
        return results;
      }

      if (this.sql.includes("PRAGMA INDEX_LIST")) {
        return this.handleShowIndexesQuery(results);
      }

      if (this.sql.includes("PRAGMA INDEX_INFO")) {
        return results;
      }

      if (this.sql.includes("PRAGMA TABLE_INFO")) {
        result = {};
        var defaultValue;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = results[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _result = _step2.value;

            if (_result.dflt_value === null) {
              defaultValue = void 0;
            } else if (_result.dflt_value === "NULL") {
              defaultValue = null;
            } else {
              defaultValue = _result.dflt_value;
            }

            result[_result.name] = {
              type: _result.type,
              allowNull: _result.notnull === 0,
              defaultValue: defaultValue,
              primaryKey: _result.pk !== 0
            };

            if (result[_result.name].type === "TINYINT(1)") {
              result[_result.name].defaultValue = {
                "0": false,
                "1": true
              }[result[_result.name].defaultValue];
            }

            if (typeof result[_result.name].defaultValue === "string") {
              result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, "");
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        return result;
      }

      if (this.sql.includes("PRAGMA foreign_keys;")) {
        return results[0];
      }

      if (this.sql.includes("PRAGMA foreign_keys")) {
        return results;
      }

      if (this.sql.includes("PRAGMA foreign_key_list")) {
        return results;
      }

      if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {
        return metaData.changes;
      }

      if (this.options.type === QueryTypes.VERSION) {
        return results[0].version;
      }

      if (this.options.type === QueryTypes.RAW) {
        return [results, metaData];
      }

      if (this.isUpsertQuery()) {
        return [result, null];
      }

      if (this.isUpdateQuery() || this.isInsertQuery()) {
        return [result, metaData.changes];
      }

      return result;
    }
  }, {
    key: "run",
    value: function run(sql, parameters) {
      var _this2 = this;

      var conn, method, complete;
      return regeneratorRuntime.async(function run$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              conn = this.connection;
              this.sql = sql;
              method = this.getDatabaseMethod();
              complete = this._logQuery(sql, debug, parameters);
              return _context2.abrupt("return", new Promise(function (resolve, reject) {
                return conn.serialize(function _callee() {
                  var columnTypes, errForStack, executeSql, tableNames;
                  return regeneratorRuntime.async(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          columnTypes = {};
                          errForStack = new Error();

                          executeSql = function executeSql() {
                            if (sql.startsWith("-- ")) {
                              return resolve();
                            }

                            var query = _this2;

                            function afterExecute(executionError, results) {
                              try {
                                complete();
                                resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));
                                return;
                              } catch (error) {
                                reject(error);
                              }
                            }

                            if (!parameters) parameters = [];

                            if (_.isPlainObject(parameters)) {
                              var newParameters = Object.create(null);

                              for (var _i = 0, _Object$keys = Object.keys(parameters); _i < _Object$keys.length; _i++) {
                                var key = _Object$keys[_i];
                                newParameters["".concat(key)] = stringifyIfBigint(parameters[key]);
                              }

                              parameters = newParameters;
                            } else {
                              parameters = parameters.map(stringifyIfBigint);
                            }

                            conn[method](sql, parameters, afterExecute);
                            return null;
                          };

                          if (!(_this2.getDatabaseMethod() === "all")) {
                            _context.next = 11;
                            break;
                          }

                          tableNames = [];

                          if (_this2.options && _this2.options.tableNames) {
                            tableNames = _this2.options.tableNames;
                          } else if (/FROM `(.*?)`/i.exec(_this2.sql)) {
                            tableNames.push(/FROM `(.*?)`/i.exec(_this2.sql)[1]);
                          }

                          tableNames = tableNames.filter(function (tableName) {
                            return !(tableName in columnTypes) && tableName !== "sqlite_master";
                          });

                          if (tableNames.length) {
                            _context.next = 9;
                            break;
                          }

                          return _context.abrupt("return", executeSql());

                        case 9:
                          _context.next = 11;
                          return regeneratorRuntime.awrap(Promise.all(tableNames.map(function (tableName) {
                            return new Promise(function (resolve2) {
                              tableName = tableName.replace(/`/g, "");
                              columnTypes[tableName] = {};
                              conn.all("PRAGMA table_info(`".concat(tableName, "`)"), function (err, results) {
                                if (!err) {
                                  var _iteratorNormalCompletion3 = true;
                                  var _didIteratorError3 = false;
                                  var _iteratorError3 = undefined;

                                  try {
                                    for (var _iterator3 = results[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                      var result = _step3.value;
                                      columnTypes[tableName][result.name] = result.type;
                                    }
                                  } catch (err) {
                                    _didIteratorError3 = true;
                                    _iteratorError3 = err;
                                  } finally {
                                    try {
                                      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                                        _iterator3["return"]();
                                      }
                                    } finally {
                                      if (_didIteratorError3) {
                                        throw _iteratorError3;
                                      }
                                    }
                                  }
                                }

                                resolve2();
                              });
                            });
                          })));

                        case 11:
                          return _context.abrupt("return", executeSql());

                        case 12:
                        case "end":
                          return _context.stop();
                      }
                    }
                  });
                });
              }));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "parseConstraintsFromSql",
    value: function parseConstraintsFromSql(sql) {
      var constraints = sql.split("CONSTRAINT ");
      var referenceTableName, referenceTableKeys, updateAction, deleteAction;
      constraints.splice(0, 1);
      constraints = constraints.map(function (constraintSql) {
        if (constraintSql.includes("REFERENCES")) {
          updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);
          deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);

          if (updateAction) {
            updateAction = updateAction[1];
          }

          if (deleteAction) {
            deleteAction = deleteAction[1];
          }

          var referencesRegex = /REFERENCES.+\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)/;
          var referenceConditions = constraintSql.match(referencesRegex)[0].split(" ");
          referenceTableName = Utils.removeTicks(referenceConditions[1]);
          var columnNames = referenceConditions[2];
          columnNames = columnNames.replace(/\(|\)/g, "").split(", ");
          referenceTableKeys = columnNames.map(function (column) {
            return Utils.removeTicks(column);
          });
        }

        var constraintCondition = constraintSql.match(/\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)/)[0];
        constraintSql = constraintSql.replace(/\(.+\)/, "");
        var constraint = constraintSql.split(" ");

        if (["PRIMARY", "FOREIGN"].includes(constraint[1])) {
          constraint[1] += " KEY";
        }

        return {
          constraintName: Utils.removeTicks(constraint[0]),
          constraintType: constraint[1],
          updateAction: updateAction,
          deleteAction: deleteAction,
          sql: sql.replace(/"/g, "`"),
          constraintCondition: constraintCondition,
          referenceTableName: referenceTableName,
          referenceTableKeys: referenceTableKeys
        };
      });
      return constraints;
    }
  }, {
    key: "applyParsers",
    value: function applyParsers(type, value) {
      if (type.includes("(")) {
        type = type.substr(0, type.indexOf("("));
      }

      type = type.replace("UNSIGNED", "").replace("ZEROFILL", "");
      type = type.trim().toUpperCase();
      var parse = parserStore.get(type);

      if (value !== null && parse) {
        return parse(value, {
          timezone: this.sequelize.options.timezone
        });
      }

      return value;
    }
  }, {
    key: "formatError",
    value: function formatError(err, errStack) {
      switch (err.code) {
        case "SQLITE_CONSTRAINT_UNIQUE":
        case "SQLITE_CONSTRAINT_PRIMARYKEY":
        case "SQLITE_CONSTRAINT_TRIGGER":
        case "SQLITE_CONSTRAINT_FOREIGNKEY":
        case "SQLITE_CONSTRAINT":
          {
            if (err.message.includes("FOREIGN KEY constraint failed")) {
              return new sequelizeErrors.ForeignKeyConstraintError({
                parent: err,
                stack: errStack
              });
            }

            var fields = [];
            var match = err.message.match(/columns (.*?) are/);

            if (match !== null && match.length >= 2) {
              fields = match[1].split(", ");
            } else {
              match = err.message.match(/UNIQUE constraint failed: (.*)/);

              if (match !== null && match.length >= 2) {
                fields = match[1].split(", ").map(function (columnWithTable) {
                  return columnWithTable.split(".")[1];
                });
              }
            }

            var errors = [];
            var message = "Validation error";
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = fields[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var field = _step4.value;
                errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), "unique violation", field, this.instance && this.instance[field], this.instance, "not_unique"));
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                  _iterator4["return"]();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            if (this.model) {
              _.forOwn(this.model.uniqueKeys, function (constraint) {
                if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {
                  message = constraint.msg;
                  return false;
                }
              });
            }

            return new sequelizeErrors.UniqueConstraintError({
              message: message,
              errors: errors,
              parent: err,
              fields: fields,
              stack: errStack
            });
          }

        case "SQLITE_BUSY":
          return new sequelizeErrors.TimeoutError(err, {
            stack: errStack
          });

        default:
          return new sequelizeErrors.DatabaseError(err, {
            stack: errStack
          });
      }
    }
  }, {
    key: "handleShowIndexesQuery",
    value: function handleShowIndexesQuery(data) {
      var _this3 = this;

      return regeneratorRuntime.async(function handleShowIndexesQuery$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", Promise.all(data.reverse().map(function _callee2(item) {
                var columns, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, column;

                return regeneratorRuntime.async(function _callee2$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        item.fields = [];
                        item.primary = false;
                        item.unique = !!item.unique;
                        item.constraintName = item.name;
                        _context3.next = 6;
                        return regeneratorRuntime.awrap(_this3.run("PRAGMA INDEX_INFO(`".concat(item.name, "`)")));

                      case 6:
                        columns = _context3.sent;
                        _iteratorNormalCompletion5 = true;
                        _didIteratorError5 = false;
                        _iteratorError5 = undefined;
                        _context3.prev = 10;

                        for (_iterator5 = columns[Symbol.iterator](); !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                          column = _step5.value;
                          item.fields[column.seqno] = {
                            attribute: column.name,
                            length: void 0,
                            order: void 0
                          };
                        }

                        _context3.next = 18;
                        break;

                      case 14:
                        _context3.prev = 14;
                        _context3.t0 = _context3["catch"](10);
                        _didIteratorError5 = true;
                        _iteratorError5 = _context3.t0;

                      case 18:
                        _context3.prev = 18;
                        _context3.prev = 19;

                        if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                          _iterator5["return"]();
                        }

                      case 21:
                        _context3.prev = 21;

                        if (!_didIteratorError5) {
                          _context3.next = 24;
                          break;
                        }

                        throw _iteratorError5;

                      case 24:
                        return _context3.finish(21);

                      case 25:
                        return _context3.finish(18);

                      case 26:
                        return _context3.abrupt("return", item);

                      case 27:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, null, null, [[10, 14, 18, 26], [19,, 21, 25]]);
              })));

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      });
    }
  }, {
    key: "getDatabaseMethod",
    value: function getDatabaseMethod() {
      if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes("CREATE TEMPORARY TABLE".toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {
        return "run";
      }

      return "all";
    }
  }], [{
    key: "formatBindParameters",
    value: function formatBindParameters(sql, values, dialect) {
      var bindParam;

      if (Array.isArray(values)) {
        bindParam = {};
        values.forEach(function (v, i) {
          bindParam["$".concat(i + 1)] = v;
        });
        sql = AbstractQuery.formatBindParameters(sql, values, dialect, {
          skipValueReplace: true
        })[0];
      } else {
        bindParam = {};

        if (_typeof(values) === "object") {
          for (var _i2 = 0, _Object$keys2 = Object.keys(values); _i2 < _Object$keys2.length; _i2++) {
            var k = _Object$keys2[_i2];
            bindParam["$".concat(k)] = values[k];
          }
        }

        sql = AbstractQuery.formatBindParameters(sql, values, dialect, {
          skipValueReplace: true
        })[0];
      }

      return [sql, bindParam];
    }
  }]);

  return Query;
}(AbstractQuery);

module.exports = Query;
module.exports.Query = Query;
module.exports["default"] = Query;