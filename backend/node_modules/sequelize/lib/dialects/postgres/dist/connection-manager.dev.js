"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _ = require("lodash");

var AbstractConnectionManager = require("../abstract/connection-manager");

var _require = require("../../utils/logger"),
    logger = _require.logger;

var debug = logger.debugContext("connection:pg");

var sequelizeErrors = require("../../errors");

var semver = require("semver");

var dataTypes = require("../../data-types");

var momentTz = require("moment-timezone");

var _require2 = require("util"),
    promisify = _require2.promisify;

var ConnectionManager =
/*#__PURE__*/
function (_AbstractConnectionMa) {
  _inherits(ConnectionManager, _AbstractConnectionMa);

  function ConnectionManager(dialect, sequelize) {
    var _this;

    _classCallCheck(this, ConnectionManager);

    sequelize.config.port = sequelize.config.port || 5432;
    _this = _possibleConstructorReturn(this, _getPrototypeOf(ConnectionManager).call(this, dialect, sequelize));

    var pgLib = _this._loadDialectModule("pg");

    _this.lib = _this.sequelize.config["native"] ? pgLib["native"] : pgLib;

    _this._clearDynamicOIDs();

    _this._clearTypeParser();

    _this.refreshTypeParser(dataTypes.postgres);

    return _this;
  }

  _createClass(ConnectionManager, [{
    key: "_refreshTypeParser",
    value: function _refreshTypeParser(dataType) {
      var _this2 = this;

      var arrayParserBuilder = function arrayParserBuilder(parser2) {
        return function (value) {
          return _this2.lib.types.arrayParser.create(value, parser2).parse();
        };
      };

      var rangeParserBuilder = function rangeParserBuilder(parser2) {
        return function (value) {
          return dataType.parse(value, {
            parser: parser2
          });
        };
      };

      if (dataType.key.toLowerCase() === "range") {
        for (var name in this.nameOidMap) {
          var entry = this.nameOidMap[name];
          if (!entry.rangeOid) continue;
          var rangeParser = rangeParserBuilder(this.getTypeParser(entry.oid));
          var arrayRangeParser = arrayParserBuilder(rangeParser);
          this.oidParserMap.set(entry.rangeOid, rangeParser);
          if (!entry.arrayRangeOid) continue;
          this.oidParserMap.set(entry.arrayRangeOid, arrayRangeParser);
        }

        return;
      }

      var parser = function parser(value) {
        return dataType.parse(value);
      };

      var arrayParser = arrayParserBuilder(parser);

      if (dataType.key.toLowerCase() === "enum") {
        this.enumOids.oids.forEach(function (oid) {
          _this2.oidParserMap.set(oid, parser);
        });
        this.enumOids.arrayOids.forEach(function (arrayOid) {
          _this2.oidParserMap.set(arrayOid, arrayParser);
        });
        return;
      }

      dataType.types.postgres.forEach(function (name) {
        if (!_this2.nameOidMap[name]) return;

        _this2.oidParserMap.set(_this2.nameOidMap[name].oid, parser);

        if (!_this2.nameOidMap[name].arrayOid) return;

        _this2.oidParserMap.set(_this2.nameOidMap[name].arrayOid, arrayParser);
      });
    }
  }, {
    key: "_clearTypeParser",
    value: function _clearTypeParser() {
      this.oidParserMap =
      /* @__PURE__ */
      new Map();
    }
  }, {
    key: "getTypeParser",
    value: function getTypeParser(oid) {
      var _this$lib$types;

      if (this.oidParserMap.get(oid)) return this.oidParserMap.get(oid);

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return (_this$lib$types = this.lib.types).getTypeParser.apply(_this$lib$types, [oid].concat(args));
    }
  }, {
    key: "connect",
    value: function connect(config) {
      var _this3 = this;

      var connectionConfig, connection, query, clientMinMessages, isZone;
      return regeneratorRuntime.async(function connect$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              config.user = config.username;
              connectionConfig = _.pick(config, ["user", "password", "host", "database", "port"]);
              connectionConfig.types = {
                getTypeParser: ConnectionManager.prototype.getTypeParser.bind(this)
              };

              if (config.dialectOptions) {
                _.merge(connectionConfig, _.pick(config.dialectOptions, ["application_name", "ssl", "client_encoding", "binary", "keepAlive", "statement_timeout", "query_timeout", "connectionTimeoutMillis", "idle_in_transaction_session_timeout", "lock_timeout", "options", "stream"]));
              }

              _context.next = 6;
              return regeneratorRuntime.awrap(new Promise(function (resolve, reject) {
                var responded = false;
                var connection2 = new _this3.lib.Client(connectionConfig);

                var parameterHandler = function parameterHandler(message) {
                  switch (message.parameterName) {
                    case "server_version":
                      if (_this3.sequelize.options.databaseVersion === 0) {
                        var version = semver.coerce(message.parameterValue).version;
                        _this3.sequelize.options.databaseVersion = semver.valid(version) ? version : _this3.dialect.defaultVersion;
                      }

                      break;

                    case "standard_conforming_strings":
                      connection2["standard_conforming_strings"] = message.parameterValue;
                      break;
                  }
                };

                var endHandler = function endHandler() {
                  debug("connection timeout");

                  if (!responded) {
                    reject(new sequelizeErrors.ConnectionTimedOutError(new Error("Connection timed out")));
                  }
                };

                connection2.once("end", endHandler);

                if (!_this3.sequelize.config["native"]) {
                  connection2.connection.on("parameterStatus", parameterHandler);
                }

                connection2.connect(function (err) {
                  responded = true;

                  if (!_this3.sequelize.config["native"]) {
                    connection2.connection.removeListener("parameterStatus", parameterHandler);
                  }

                  if (err) {
                    if (err.code) {
                      switch (err.code) {
                        case "ECONNREFUSED":
                          reject(new sequelizeErrors.ConnectionRefusedError(err));
                          break;

                        case "ENOTFOUND":
                          reject(new sequelizeErrors.HostNotFoundError(err));
                          break;

                        case "EHOSTUNREACH":
                          reject(new sequelizeErrors.HostNotReachableError(err));
                          break;

                        case "EINVAL":
                          reject(new sequelizeErrors.InvalidConnectionError(err));
                          break;

                        default:
                          reject(new sequelizeErrors.ConnectionError(err));
                          break;
                      }
                    } else {
                      reject(new sequelizeErrors.ConnectionError(err));
                    }
                  } else {
                    debug("connection acquired");
                    connection2.removeListener("end", endHandler);
                    resolve(connection2);
                  }
                });
              }));

            case 6:
              connection = _context.sent;
              connection.on("error", function (error) {
                connection._invalid = true;
                debug("connection error ".concat(error.code || error.message));

                _this3.pool.destroy(connection);
              });
              query = "";

              if (this.sequelize.options.standardConformingStrings !== false && connection["standard_conforming_strings"] !== "on") {
                query += "SET standard_conforming_strings=on;";
              }

              if (this.sequelize.options.clientMinMessages !== void 0) {
                console.warn('Usage of "options.clientMinMessages" is deprecated and will be removed in v7.');
                console.warn('Please use the sequelize option "dialectOptions.clientMinMessages" instead.');
              }

              if (!(config.dialectOptions && config.dialectOptions.clientMinMessages && config.dialectOptions.clientMinMessages.toLowerCase() === "ignore" || this.sequelize.options.clientMinMessages === false)) {
                clientMinMessages = config.dialectOptions && config.dialectOptions.clientMinMessages || this.sequelize.options.clientMinMessages || "warning";
                query += "SET client_min_messages TO ".concat(clientMinMessages, ";");
              }

              if (!this.sequelize.config.keepDefaultTimezone) {
                isZone = !!momentTz.tz.zone(this.sequelize.options.timezone);

                if (isZone) {
                  query += "SET TIME ZONE '".concat(this.sequelize.options.timezone, "';");
                } else {
                  query += "SET TIME ZONE INTERVAL '".concat(this.sequelize.options.timezone, "' HOUR TO MINUTE;");
                }
              }

              if (!query) {
                _context.next = 16;
                break;
              }

              _context.next = 16;
              return regeneratorRuntime.awrap(connection.query(query));

            case 16:
              if (!(Object.keys(this.nameOidMap).length === 0 && this.enumOids.oids.length === 0 && this.enumOids.arrayOids.length === 0)) {
                _context.next = 19;
                break;
              }

              _context.next = 19;
              return regeneratorRuntime.awrap(this._refreshDynamicOIDs(connection));

            case 19:
              return _context.abrupt("return", connection);

            case 20:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "disconnect",
    value: function disconnect(connection) {
      return regeneratorRuntime.async(function disconnect$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!connection._ending) {
                _context2.next = 3;
                break;
              }

              debug("connection tried to disconnect but was already at ENDING state");
              return _context2.abrupt("return");

            case 3:
              _context2.next = 5;
              return regeneratorRuntime.awrap(promisify(function (callback) {
                return connection.end(callback);
              })());

            case 5:
              return _context2.abrupt("return", _context2.sent);

            case 6:
            case "end":
              return _context2.stop();
          }
        }
      });
    }
  }, {
    key: "validate",
    value: function validate(connection) {
      return !connection._invalid && !connection._ending;
    }
  }, {
    key: "_refreshDynamicOIDs",
    value: function _refreshDynamicOIDs(connection) {
      var databaseVersion, supportedVersion, results, result, newNameOidMap, newEnumOids, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, row;

      return regeneratorRuntime.async(function _refreshDynamicOIDs$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              databaseVersion = this.sequelize.options.databaseVersion;
              supportedVersion = "8.3.0";

              if (!((databaseVersion && semver.gte(databaseVersion, supportedVersion)) === false)) {
                _context3.next = 4;
                break;
              }

              return _context3.abrupt("return");

            case 4:
              _context3.next = 6;
              return regeneratorRuntime.awrap((connection || this.sequelize).query("WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));"));

            case 6:
              results = _context3.sent;
              result = Array.isArray(results) ? results.pop() : results;

              if (Array.isArray(result)) {
                if (result[0].command === "SET") {
                  result = result.pop();
                }
              }

              newNameOidMap = {};
              newEnumOids = {
                oids: [],
                arrayOids: []
              };
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context3.prev = 14;
              _iterator = result.rows[Symbol.iterator]();

            case 16:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context3.next = 28;
                break;
              }

              row = _step.value;

              if (!(row.typtype === "e")) {
                _context3.next = 22;
                break;
              }

              newEnumOids.oids.push(row.oid);
              if (row.typarray) newEnumOids.arrayOids.push(row.typarray);
              return _context3.abrupt("continue", 25);

            case 22:
              newNameOidMap[row.typname] = {
                oid: row.oid
              };
              if (row.typarray) newNameOidMap[row.typname].arrayOid = row.typarray;

              if (row.rngtypid) {
                newNameOidMap[row.typname].rangeOid = row.rngtypid;
                if (row.rngtyparray) newNameOidMap[row.typname].arrayRangeOid = row.rngtyparray;
              }

            case 25:
              _iteratorNormalCompletion = true;
              _context3.next = 16;
              break;

            case 28:
              _context3.next = 34;
              break;

            case 30:
              _context3.prev = 30;
              _context3.t0 = _context3["catch"](14);
              _didIteratorError = true;
              _iteratorError = _context3.t0;

            case 34:
              _context3.prev = 34;
              _context3.prev = 35;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 37:
              _context3.prev = 37;

              if (!_didIteratorError) {
                _context3.next = 40;
                break;
              }

              throw _iteratorError;

            case 40:
              return _context3.finish(37);

            case 41:
              return _context3.finish(34);

            case 42:
              this.nameOidMap = newNameOidMap;
              this.enumOids = newEnumOids;
              this.refreshTypeParser(dataTypes.postgres);

            case 45:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this, [[14, 30, 34, 42], [35,, 37, 41]]);
    }
  }, {
    key: "_clearDynamicOIDs",
    value: function _clearDynamicOIDs() {
      this.nameOidMap = {};
      this.enumOids = {
        oids: [],
        arrayOids: []
      };
    }
  }]);

  return ConnectionManager;
}(AbstractConnectionManager);

module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports["default"] = ConnectionManager;