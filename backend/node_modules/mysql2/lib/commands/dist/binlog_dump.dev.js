'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Command = require('./command');

var Packets = require('../packets');

var eventParsers = [];

var BinlogEventHeader = function BinlogEventHeader(packet) {
  _classCallCheck(this, BinlogEventHeader);

  this.timestamp = packet.readInt32();
  this.eventType = packet.readInt8();
  this.serverId = packet.readInt32();
  this.eventSize = packet.readInt32();
  this.logPos = packet.readInt32();
  this.flags = packet.readInt16();
};

var BinlogDump =
/*#__PURE__*/
function (_Command) {
  _inherits(BinlogDump, _Command);

  function BinlogDump(opts) {
    var _this;

    _classCallCheck(this, BinlogDump);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BinlogDump).call(this)); // this.onResult = callback;

    _this.opts = opts;
    return _this;
  }

  _createClass(BinlogDump, [{
    key: "start",
    value: function start(packet, connection) {
      var newPacket = new Packets.BinlogDump(this.opts);
      connection.writePacket(newPacket.toPacket(1));
      return BinlogDump.prototype.binlogData;
    }
  }, {
    key: "binlogData",
    value: function binlogData(packet) {
      // ok - continue consuming events
      // error - error
      // eof - end of binlog
      if (packet.isEOF()) {
        this.emit('eof');
        return null;
      } // binlog event header


      packet.readInt8();
      var header = new BinlogEventHeader(packet);
      var EventParser = eventParsers[header.eventType];
      var event;

      if (EventParser) {
        event = new EventParser(packet);
      } else {
        event = {
          name: 'UNKNOWN'
        };
      }

      event.header = header;
      this.emit('event', event);
      return BinlogDump.prototype.binlogData;
    }
  }]);

  return BinlogDump;
}(Command);

var RotateEvent = function RotateEvent(packet) {
  _classCallCheck(this, RotateEvent);

  this.pposition = packet.readInt32(); // TODO: read uint64 here

  packet.readInt32(); // positionDword2

  this.nextBinlog = packet.readString();
  this.name = 'RotateEvent';
};

var FormatDescriptionEvent = function FormatDescriptionEvent(packet) {
  _classCallCheck(this, FormatDescriptionEvent);

  this.binlogVersion = packet.readInt16();
  this.serverVersion = packet.readString(50).replace(/\u0000.*/, ''); // eslint-disable-line no-control-regex

  this.createTimestamp = packet.readInt32();
  this.eventHeaderLength = packet.readInt8(); // should be 19

  this.eventsLength = packet.readBuffer();
  this.name = 'FormatDescriptionEvent';
};

var QueryEvent = function QueryEvent(packet) {
  _classCallCheck(this, QueryEvent);

  var parseStatusVars = require('../packets/binlog_query_statusvars.js');

  this.slaveProxyId = packet.readInt32();
  this.executionTime = packet.readInt32();
  var schemaLength = packet.readInt8();
  this.errorCode = packet.readInt16();
  var statusVarsLength = packet.readInt16();
  var statusVars = packet.readBuffer(statusVarsLength);
  this.schema = packet.readString(schemaLength);
  packet.readInt8(); // should be zero

  this.statusVars = parseStatusVars(statusVars);
  this.query = packet.readString();
  this.name = 'QueryEvent';
};

var XidEvent = function XidEvent(packet) {
  _classCallCheck(this, XidEvent);

  this.binlogVersion = packet.readInt16();
  this.xid = packet.readInt64();
  this.name = 'XidEvent';
};

eventParsers[2] = QueryEvent;
eventParsers[4] = RotateEvent;
eventParsers[15] = FormatDescriptionEvent;
eventParsers[16] = XidEvent;
module.exports = BinlogDump;