"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return a;
};

var __markAsModule = function __markAsModule(target) {
  return __defProp(target, "__esModule", {
    value: true
  });
};

var __export = function __export(target, all) {
  __markAsModule(target);

  for (var name in all) {
    __defProp(target, name, {
      get: all[name],
      enumerable: true
    });
  }
};

__export(exports, {
  OracleQueryGenerator: function OracleQueryGenerator() {
    return _OracleQueryGenerator;
  }
});

var Utils = require("../../utils");

var DataTypes = require("../../data-types");

var AbstractQueryGenerator = require("../abstract/query-generator");

var _ = require("lodash");

var util = require("util");

var Transaction = require("../../transaction");

var ORACLE_RESERVED_WORDS = ["ACCESS", "ADD", "ALL", "ALTER", "AND", "ANY", "ARRAYLEN", "AS", "ASC", "AUDIT", "BETWEEN", "BY", "CHAR", "CHECK", "CLUSTER", "COLUMN", "COMMENT", "COMPRESS", "CONNECT", "CREATE", "CURRENT", "DATE", "DECIMAL", "DEFAULT", "DELETE", "DESC", "DISTINCT", "DROP", "ELSE", "EXCLUSIVE", "EXISTS", "FILE", "FLOAT", "FOR", "FROM", "GRANT", "GROUP", "HAVING", "IDENTIFIED", "IMMEDIATE", "IN", "INCREMENT", "INDEX", "INITIAL", "INSERT", "INTEGER", "INTERSECT", "INTO", "IS", "LEVEL", "LIKE", "LOCK", "LONG", "MAXEXTENTS", "MINUS", "MODE", "MODIFY", "NOAUDIT", "NOCOMPRESS", "NOT", "NOTFOUND", "NOWAIT", "NULL", "NUMBER", "OF", "OFFLINE", "ON", "ONLINE", "OPTION", "OR", "ORDER", "PCTFREE", "PRIOR", "PRIVILEGES", "PUBLIC", "RAW", "RENAME", "RESOURCE", "REVOKE", "ROW", "ROWID", "ROWLABEL", "ROWNUM", "ROWS", "SELECT", "SESSION", "SET", "SHARE", "SIZE", "SMALLINT", "SQLBUF", "START", "SUCCESSFUL", "SYNONYM", "SYSDATE", "TABLE", "THEN", "TO", "TRIGGER", "UID", "UNION", "UNIQUE", "UPDATE", "USER", "VALIDATE", "VALUES", "VARCHAR", "VARCHAR2", "VIEW", "WHENEVER", "WHERE", "WITH"];
var JSON_FUNCTION_REGEX = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
var JSON_OPERATOR_REGEX = /^\s*(->>?|@>|<@|\?[|&]?|\|{2}|#-)/i;
var TOKEN_CAPTURE_REGEX = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;

var _OracleQueryGenerator =
/*#__PURE__*/
function (_AbstractQueryGenerat) {
  _inherits(_OracleQueryGenerator, _AbstractQueryGenerat);

  function _OracleQueryGenerator(options) {
    _classCallCheck(this, _OracleQueryGenerator);

    return _possibleConstructorReturn(this, _getPrototypeOf(_OracleQueryGenerator).call(this, options));
  }

  _createClass(_OracleQueryGenerator, [{
    key: "getCatalogName",
    value: function getCatalogName(value) {
      if (value) {
        if (this.options.quoteIdentifiers === false) {
          var quotedValue = this.quoteIdentifier(value);

          if (quotedValue === value) {
            value = value.toUpperCase();
          }
        }
      }

      return value;
    }
  }, {
    key: "getSchemaNameAndTableName",
    value: function getSchemaNameAndTableName(table) {
      var tableName = this.getCatalogName(table.tableName || table);
      var schemaName = this.getCatalogName(table.schema);
      return [tableName, schemaName];
    }
  }, {
    key: "createSchema",
    value: function createSchema(schema) {
      var quotedSchema = this.quoteIdentifier(schema);
      return ["DECLARE", "USER_FOUND BOOLEAN := FALSE;", "BEGIN", " BEGIN", "   EXECUTE IMMEDIATE ", this.escape("CREATE USER ".concat(quotedSchema, " IDENTIFIED BY 12345 DEFAULT TABLESPACE USERS")), ";", "   EXCEPTION WHEN OTHERS THEN", "     IF SQLCODE != -1920 THEN", "       RAISE;", "     ELSE", "       USER_FOUND := TRUE;", "     END IF;", " END;", " IF NOT USER_FOUND THEN", "    EXECUTE IMMEDIATE ", this.escape("GRANT \"CONNECT\" TO ".concat(quotedSchema)), ";", "    EXECUTE IMMEDIATE ", this.escape("GRANT CREATE TABLE TO ".concat(quotedSchema)), ";", "    EXECUTE IMMEDIATE ", this.escape("GRANT CREATE VIEW TO ".concat(quotedSchema)), ";", "    EXECUTE IMMEDIATE ", this.escape("GRANT CREATE ANY TRIGGER TO ".concat(quotedSchema)), ";", "    EXECUTE IMMEDIATE ", this.escape("GRANT CREATE ANY PROCEDURE TO ".concat(quotedSchema)), ";", "    EXECUTE IMMEDIATE ", this.escape("GRANT CREATE SEQUENCE TO ".concat(quotedSchema)), ";", "    EXECUTE IMMEDIATE ", this.escape("GRANT CREATE SYNONYM TO ".concat(quotedSchema)), ";", "    EXECUTE IMMEDIATE ", this.escape("ALTER USER ".concat(quotedSchema, " QUOTA UNLIMITED ON USERS")), ";", " END IF;", "END;"].join(" ");
    }
  }, {
    key: "showSchemasQuery",
    value: function showSchemasQuery() {
      return "SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE COMMON = ('NO') AND USERNAME != user";
    }
  }, {
    key: "dropSchema",
    value: function dropSchema(schema) {
      return ["BEGIN", "EXECUTE IMMEDIATE ", this.escape("DROP USER ".concat(this.quoteTable(schema), " CASCADE")), ";", "EXCEPTION WHEN OTHERS THEN", "  IF SQLCODE != -1918 THEN", "    RAISE;", "  END IF;", "END;"].join(" ");
    }
  }, {
    key: "versionQuery",
    value: function versionQuery() {
      return "SELECT VERSION_FULL FROM PRODUCT_COMPONENT_VERSION WHERE PRODUCT LIKE 'Oracle%'";
    }
  }, {
    key: "createTableQuery",
    value: function createTableQuery(tableName, attributes, options) {
      var _this = this;

      var primaryKeys = [],
          foreignKeys = Object.create(null),
          attrStr = [],
          checkStr = [];
      var values = {
        table: this.quoteTable(tableName)
      };

      for (var attr in attributes) {
        if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;
        var dataType = attributes[attr];
        attr = this.quoteIdentifier(attr);

        if (dataType.includes("PRIMARY KEY")) {
          primaryKeys.push(attr);

          if (dataType.includes("REFERENCES")) {
            var match = dataType.match(/^(.+) (REFERENCES.*)$/);
            attrStr.push("".concat(attr, " ").concat(match[1].replace(/PRIMARY KEY/, "")));
            foreignKeys[attr] = match[2];
          } else {
            attrStr.push("".concat(attr, " ").concat(dataType.replace(/PRIMARY KEY/, "").trim()));
          }
        } else if (dataType.includes("REFERENCES")) {
          var _match = dataType.match(/^(.+) (REFERENCES.*)$/);

          attrStr.push("".concat(attr, " ").concat(_match[1]));
          foreignKeys[attr] = _match[2];
        } else {
          attrStr.push("".concat(attr, " ").concat(dataType));
        }
      }

      values["attributes"] = attrStr.join(", ");
      var pkString = primaryKeys.map(function (pk) {
        return _this.quoteIdentifier(pk);
      }).join(", ");

      if (pkString.length > 0) {
        values.attributes += ",PRIMARY KEY (".concat(pkString, ")");
      }

      for (var fkey in foreignKeys) {
        if (!Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) continue;

        if (foreignKeys[fkey].indexOf("ON DELETE NO ACTION") > -1) {
          foreignKeys[fkey] = foreignKeys[fkey].replace("ON DELETE NO ACTION", "");
        }

        values.attributes += ",FOREIGN KEY (".concat(this.quoteIdentifier(fkey), ") ").concat(foreignKeys[fkey]);
      }

      if (checkStr.length > 0) {
        values.attributes += ", ".concat(checkStr.join(", "));
      }

      if (options && options.indexes && options.indexes.length > 0) {
        var idxToDelete = [];
        options.indexes.forEach(function (index, idx) {
          if ("unique" in index && (index.unique === true || index.unique.length > 0 && index.unique !== false)) {
            var fields = index.fields.map(function (field) {
              if (typeof field === "string") {
                return field;
              }

              return field.attribute;
            });
            var canContinue = true;

            if (options.uniqueKeys) {
              var keys = Object.keys(options.uniqueKeys);

              for (var fieldIdx = 0; fieldIdx < keys.length; fieldIdx++) {
                var currUnique = options.uniqueKeys[keys[fieldIdx]];

                if (currUnique.fields.length === fields.length) {
                  for (var i = 0; i < currUnique.fields.length; i++) {
                    var field = currUnique.fields[i];

                    if (_.includes(fields, field)) {
                      canContinue = false;
                    } else {
                      canContinue = true;
                      break;
                    }
                  }
                }
              }

              if (canContinue) {
                var indexName = "name" in index ? index.name : "";
                var constraintToAdd = {
                  name: indexName,
                  fields: fields
                };

                if (!("uniqueKeys" in options)) {
                  options.uniqueKeys = {};
                }

                options.uniqueKeys[indexName] = constraintToAdd;
                idxToDelete.push(idx);
              } else {
                idxToDelete.push(idx);
              }
            }
          }
        });
        idxToDelete.forEach(function (idx) {
          options.indexes.splice(idx, 1);
        });
      }

      if (options && !!options.uniqueKeys) {
        _.each(options.uniqueKeys, function (columns, indexName) {
          var canBeUniq = false;
          primaryKeys.forEach(function (primaryKey) {
            primaryKey = primaryKey.replace(/"/g, "");

            if (!_.includes(columns.fields, primaryKey)) {
              canBeUniq = true;
            }
          });
          columns.fields.forEach(function (field) {
            var currField = "";

            if (!_.isString(field)) {
              currField = field.attribute.replace(/[.,"\s]/g, "");
            } else {
              currField = field.replace(/[.,"\s]/g, "");
            }

            if (currField in attributes) {
              if (attributes[currField].toUpperCase().indexOf("UNIQUE") > -1 && canBeUniq) {
                var attrToReplace = attributes[currField].replace("UNIQUE", "");
                values.attributes = values.attributes.replace(attributes[currField], attrToReplace);
              }
            }
          });

          if (canBeUniq) {
            var index = options.uniqueKeys[columns.name];
            delete options.uniqueKeys[columns.name];
            indexName = indexName.replace(/[.,\s]/g, "");
            columns.name = indexName;
            options.uniqueKeys[indexName] = index;

            if (indexName.length === 0) {
              values.attributes += ",UNIQUE (".concat(columns.fields.map(function (field) {
                return _this.quoteIdentifier(field);
              }).join(", "), ")");
            } else {
              values.attributes += ", CONSTRAINT ".concat(_this.quoteIdentifier(indexName), " UNIQUE (").concat(columns.fields.map(function (field) {
                return _this.quoteIdentifier(field);
              }).join(", "), ")");
            }
          }
        });
      }

      var query = Utils.joinSQLFragments(["CREATE TABLE", values.table, "(".concat(values.attributes, ")")]);
      return Utils.joinSQLFragments(["BEGIN", "EXECUTE IMMEDIATE", "".concat(this.escape(query), ";"), "EXCEPTION WHEN OTHERS THEN", "IF SQLCODE != -955 THEN", "RAISE;", "END IF;", "END;"]);
    }
  }, {
    key: "tableExistsQuery",
    value: function tableExistsQuery(table) {
      var _this$getSchemaNameAn = this.getSchemaNameAndTableName(table),
          _this$getSchemaNameAn2 = _slicedToArray(_this$getSchemaNameAn, 2),
          tableName = _this$getSchemaNameAn2[0],
          schemaName = _this$getSchemaNameAn2[1];

      return "SELECT TABLE_NAME FROM ALL_TABLES WHERE TABLE_NAME = ".concat(this.escape(tableName), " AND OWNER = ").concat(table.schema ? this.escape(schemaName) : "USER");
    }
  }, {
    key: "describeTableQuery",
    value: function describeTableQuery(tableName, schema) {
      var currTableName = this.getCatalogName(tableName.tableName || tableName);
      schema = this.getCatalogName(schema);
      return ["SELECT atc.COLUMN_NAME, atc.DATA_TYPE, atc.DATA_LENGTH, atc.CHAR_LENGTH, atc.DEFAULT_LENGTH, atc.NULLABLE, ucc.constraint_type ", "FROM all_tab_columns atc ", "LEFT OUTER JOIN ", "(SELECT acc.column_name, acc.table_name, ac.constraint_type FROM all_cons_columns acc INNER JOIN all_constraints ac ON acc.constraint_name = ac.constraint_name) ucc ", "ON (atc.table_name = ucc.table_name AND atc.COLUMN_NAME = ucc.COLUMN_NAME) ", schema ? "WHERE (atc.OWNER = ".concat(this.escape(schema), ") ") : "WHERE atc.OWNER = USER ", "AND (atc.TABLE_NAME = ".concat(this.escape(currTableName), ")"), "ORDER BY atc.COLUMN_NAME, CONSTRAINT_TYPE DESC"].join("");
    }
  }, {
    key: "renameTableQuery",
    value: function renameTableQuery(before, after) {
      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(before), "RENAME TO", this.quoteTable(after)]);
    }
  }, {
    key: "showConstraintsQuery",
    value: function showConstraintsQuery(table) {
      var tableName = this.getCatalogName(table.tableName || table);
      return "SELECT CONSTRAINT_NAME constraint_name FROM user_cons_columns WHERE table_name = ".concat(this.escape(tableName));
    }
  }, {
    key: "showTablesQuery",
    value: function showTablesQuery() {
      return "SELECT owner as table_schema, table_name, 0 as lvl FROM all_tables where OWNER IN(SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE ORACLE_MAINTAINED = 'N')";
    }
  }, {
    key: "dropTableQuery",
    value: function dropTableQuery(tableName) {
      return Utils.joinSQLFragments(["BEGIN ", "EXECUTE IMMEDIATE 'DROP TABLE", this.quoteTable(tableName), "CASCADE CONSTRAINTS PURGE';", "EXCEPTION WHEN OTHERS THEN", " IF SQLCODE != -942 THEN", "   RAISE;", " END IF;", "END;"]);
    }
  }, {
    key: "addIndexQuery",
    value: function addIndexQuery(tableName, attributes, options, rawTablename) {
      if (typeof tableName !== "string" && attributes.name) {
        attributes.name = "".concat(tableName.schema, ".").concat(attributes.name);
      }

      return _get(_getPrototypeOf(_OracleQueryGenerator.prototype), "addIndexQuery", this).call(this, tableName, attributes, options, rawTablename);
    }
  }, {
    key: "addConstraintQuery",
    value: function addConstraintQuery(tableName, options) {
      options = options || {};

      if (options.onUpdate) {
        delete options.onUpdate;
      }

      if (options.onDelete && options.onDelete.toUpperCase() === "NO ACTION") {
        delete options.onDelete;
      }

      var constraintSnippet = this.getConstraintSnippet(tableName, options);
      tableName = this.quoteTable(tableName);
      return "ALTER TABLE ".concat(tableName, " ADD ").concat(constraintSnippet, ";");
    }
  }, {
    key: "addColumnQuery",
    value: function addColumnQuery(table, key, dataType) {
      dataType.field = key;
      var attribute = Utils.joinSQLFragments([this.quoteIdentifier(key), this.attributeToSQL(dataType, {
        attributeName: key,
        context: "addColumn"
      })]);
      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(table), "ADD", attribute]);
    }
  }, {
    key: "removeColumnQuery",
    value: function removeColumnQuery(tableName, attributeName) {
      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(tableName), "DROP COLUMN", this.quoteIdentifier(attributeName), ";"]);
    }
  }, {
    key: "_alterForeignKeyConstraint",
    value: function _alterForeignKeyConstraint(definition, table, attributeName) {
      var _this$getSchemaNameAn3 = this.getSchemaNameAndTableName(table),
          _this$getSchemaNameAn4 = _slicedToArray(_this$getSchemaNameAn3, 2),
          tableName = _this$getSchemaNameAn4[0],
          schemaName = _this$getSchemaNameAn4[1];

      var attributeNameConstant = this.escape(this.getCatalogName(attributeName));
      var schemaNameConstant = table.schema ? this.escape(this.getCatalogName(schemaName)) : "USER";
      var tableNameConstant = this.escape(this.getCatalogName(tableName));
      var getConsNameQuery = ["SELECT constraint_name INTO cons_name", "FROM (", "  SELECT DISTINCT cc.owner, cc.table_name, cc.constraint_name, cc.column_name AS cons_columns", "  FROM all_cons_columns cc, all_constraints c", "  WHERE cc.owner = c.owner", "  AND cc.table_name = c.table_name", "  AND cc.constraint_name = c.constraint_name", "  AND c.constraint_type = 'R'", "  GROUP BY cc.owner, cc.table_name, cc.constraint_name, cc.column_name", ")", "WHERE owner =", schemaNameConstant, "AND table_name =", tableNameConstant, "AND cons_columns =", attributeNameConstant, ";"].join(" ");
      var secondQuery = Utils.joinSQLFragments(["ALTER TABLE ".concat(this.quoteIdentifier(tableName)), "ADD FOREIGN KEY", "(".concat(this.quoteIdentifier(attributeName), ")"), definition.replace(/.+?(?=REFERENCES)/, "")]);
      return ["BEGIN", getConsNameQuery, "EXCEPTION", "WHEN NO_DATA_FOUND THEN", " CONS_NAME := NULL;", "END;", "IF CONS_NAME IS NOT NULL THEN", " EXECUTE IMMEDIATE 'ALTER TABLE ".concat(this.quoteTable(table), " DROP CONSTRAINT \"'||CONS_NAME||'\"';"), "END IF;", "EXECUTE IMMEDIATE ".concat(this.escape(secondQuery), ";")].join(" ");
    }
  }, {
    key: "_modifyQuery",
    value: function _modifyQuery(definition, table, attributeName) {
      var query = Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(table), "MODIFY", this.quoteIdentifier(attributeName), definition]);
      var secondQuery = query.replace("NOT NULL", "").replace("NULL", "");
      return ["BEGIN", "EXECUTE IMMEDIATE ".concat(this.escape(query), ";"), "EXCEPTION", "WHEN OTHERS THEN", " IF SQLCODE = -1442 OR SQLCODE = -1451 THEN", "   EXECUTE IMMEDIATE ".concat(this.escape(secondQuery), ";"), " ELSE", "   RAISE;", " END IF;", "END;"].join(" ");
    }
  }, {
    key: "changeColumnQuery",
    value: function changeColumnQuery(table, attributes) {
      var sql = ["DECLARE", "CONS_NAME VARCHAR2(200);", "BEGIN"];

      for (var attributeName in attributes) {
        if (!Object.prototype.hasOwnProperty.call(attributes, attributeName)) continue;
        var definition = attributes[attributeName];

        if (definition.match(/REFERENCES/)) {
          sql.push(this._alterForeignKeyConstraint(definition, table, attributeName));
        } else {
          sql.push(this._modifyQuery(definition, table, attributeName));
        }
      }

      sql.push("END;");
      return sql.join(" ");
    }
  }, {
    key: "renameColumnQuery",
    value: function renameColumnQuery(tableName, attrBefore, attributes) {
      var newName = Object.keys(attributes)[0];
      return "ALTER TABLE ".concat(this.quoteTable(tableName), " RENAME COLUMN ").concat(this.quoteIdentifier(attrBefore), " TO ").concat(this.quoteIdentifier(newName));
    }
  }, {
    key: "populateInsertQueryReturnIntoBinds",
    value: function populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, inbindLength, returnAttributes, options) {
      var _this2 = this;

      var oracledb = this.sequelize.connectionManager.lib;
      var outBindAttributes = Object.create(null);
      var outbind = [];
      var outbindParam = this.bindParam(outbind, inbindLength);
      returningModelAttributes.forEach(function (element, index) {
        if (element.startsWith('"')) {
          element = element.substring(1, element.length - 1);
        }

        outBindAttributes[element] = Object.assign(returnTypes[index]._getBindDef(oracledb), {
          dir: oracledb.BIND_OUT
        });
        var returnAttribute = "".concat(_this2.format(void 0, void 0, {
          context: "INSERT"
        }, outbindParam));
        returnAttributes.push(returnAttribute);
      });
      options.outBindAttributes = outBindAttributes;
    }
  }, {
    key: "upsertQuery",
    value: function upsertQuery(tableName, insertValues, updateValues, where, model, options) {
      var rawAttributes = model.rawAttributes;
      var updateQuery = this.updateQuery(tableName, updateValues, where, options, rawAttributes);
      options.bind = updateQuery.bind;
      var insertQuery = this.insertQuery(tableName, insertValues, rawAttributes, options);
      var sql = ["DECLARE ", "BEGIN ", updateQuery.query ? [updateQuery.query, "; ", " IF ( SQL%ROWCOUNT = 0 ) THEN ", insertQuery.query, " :isUpdate := 0; ", "ELSE ", " :isUpdate := 1; ", " END IF; "].join("") : [insertQuery.query, " :isUpdate := 0; ", "EXCEPTION WHEN OTHERS THEN", " IF SQLCODE != -1 THEN", "   RAISE;", " END IF;"].join(""), "END;"];
      var query = sql.join("");
      var result = {
        query: query
      };

      if (options.bindParam !== false) {
        result.bind = updateQuery.bind || insertQuery.bind;
      }

      return result;
    }
  }, {
    key: "bulkInsertQuery",
    value: function bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {
      var _this3 = this;

      options = options || {};
      options.executeMany = true;
      fieldMappedAttributes = fieldMappedAttributes || {};
      var tuples = [];
      var allColumns = {};
      var inBindBindDefMap = {};
      var outBindBindDefMap = {};
      var oracledb = this.sequelize.connectionManager.lib;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = fieldValueHashes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var fieldValueHash = _step2.value;

          _.forOwn(fieldValueHash, function (value, key) {
            allColumns[key] = fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true && value === null;
          });
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var inBindPosition;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        var _loop = function _loop() {
          var fieldValueHash = _step3.value;
          var tuple = [];
          var inbindParam = options.bindParam === void 0 ? _this3.bindParam(tuple) : options.bindParam;
          var tempBindPositions = Object.keys(allColumns).map(function (key) {
            if (allColumns[key] === true) {
              if (fieldValueHash[key] !== null) {
                throw Error("For an auto-increment column either all row must be null or non-null, a mix of null and non-null is not allowed!");
              }

              return "DEFAULT";
            }

            return _this3.format(fieldValueHash[key], fieldMappedAttributes[key], {
              context: "INSERT"
            }, inbindParam);
          });

          if (!inBindPosition) {
            inBindPosition = tempBindPositions;
          }

          tuples.push(tuple);
        };

        for (var _iterator3 = fieldValueHashes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var returnColumn = [];
      var returnColumnBindPositions = [];
      var insertColumns = [];

      for (var _i2 = 0, _Object$keys = Object.keys(allColumns); _i2 < _Object$keys.length; _i2++) {
        var key = _Object$keys[_i2];

        if (fieldMappedAttributes[key]) {
          var bindDef = fieldMappedAttributes[key].type._getBindDef(oracledb);

          if (allColumns[key]) {
            bindDef.dir = oracledb.BIND_OUT;
            outBindBindDefMap[key] = bindDef;
            returnColumn.push(this.quoteIdentifier(key));
            returnColumnBindPositions.push(":".concat(tuples[0].length + returnColumn.length));
          } else {
            bindDef.dir = oracledb.BIND_IN;
            inBindBindDefMap[key] = bindDef;
          }
        }

        insertColumns.push(this.quoteIdentifier(key));
      }

      var query = Utils.joinSQLFragments(["INSERT", "INTO", this.quoteTable(tableName), "(".concat(insertColumns.join(","), ")"), "VALUES", "(".concat(inBindPosition, ")")]);

      if (returnColumn.length > 0) {
        options.outBindAttributes = outBindBindDefMap;
        query = Utils.joinSQLFragments([query, "RETURNING", "".concat(returnColumn.join(",")), "INTO", "".concat(returnColumnBindPositions)]);
      }

      var result = {
        query: query
      };
      result.bind = tuples;
      options.inbindAttributes = inBindBindDefMap;
      return result;
    }
  }, {
    key: "truncateTableQuery",
    value: function truncateTableQuery(tableName) {
      return "TRUNCATE TABLE ".concat(this.quoteTable(tableName));
    }
  }, {
    key: "deleteQuery",
    value: function deleteQuery(tableName, where, options, model) {
      options = options || {};
      var table = tableName;
      where = this.getWhereConditions(where, null, model, options);
      var queryTmpl;

      if (options.limit) {
        var whereTmpl = where ? " AND ".concat(where) : "";
        queryTmpl = "DELETE FROM ".concat(this.quoteTable(table), " WHERE rowid IN (SELECT rowid FROM ").concat(this.quoteTable(table), " WHERE rownum <= ").concat(this.escape(options.limit)).concat(whereTmpl, ")");
      } else {
        var _whereTmpl = where ? " WHERE ".concat(where) : "";

        queryTmpl = "DELETE FROM ".concat(this.quoteTable(table)).concat(_whereTmpl);
      }

      return queryTmpl;
    }
  }, {
    key: "showIndexesQuery",
    value: function showIndexesQuery(table) {
      var _this$getSchemaNameAn5 = this.getSchemaNameAndTableName(table),
          _this$getSchemaNameAn6 = _slicedToArray(_this$getSchemaNameAn5, 2),
          tableName = _this$getSchemaNameAn6[0],
          owner = _this$getSchemaNameAn6[1];

      var sql = ["SELECT i.index_name,i.table_name, i.column_name, u.uniqueness, i.descend, c.constraint_type ", "FROM all_ind_columns i ", "INNER JOIN all_indexes u ", "ON (u.table_name = i.table_name AND u.index_name = i.index_name) ", "LEFT OUTER JOIN all_constraints c ", "ON (c.table_name = i.table_name AND c.index_name = i.index_name) ", "WHERE i.table_name = ".concat(this.escape(tableName)), " AND u.table_owner = ", owner ? this.escape(owner) : "USER", " ORDER BY index_name, column_position"];
      return sql.join("");
    }
  }, {
    key: "removeIndexQuery",
    value: function removeIndexQuery(tableName, indexNameOrAttributes) {
      var indexName = indexNameOrAttributes;

      if (typeof indexName !== "string") {
        indexName = Utils.underscore("".concat(tableName, "_").concat(indexNameOrAttributes.join("_")));
      }

      return "DROP INDEX ".concat(this.quoteIdentifier(indexName));
    }
  }, {
    key: "attributeToSQL",
    value: function attributeToSQL(attribute, options) {
      var _this4 = this;

      if (!_.isPlainObject(attribute)) {
        attribute = {
          type: attribute
        };
      }

      attribute.onUpdate = "";

      if (attribute.references) {
        if (attribute.Model && attribute.Model.tableName === attribute.references.model) {
          this.sequelize.log("Oracle does not support self referencial constraints, we will remove it but we recommend restructuring your query");
          attribute.onDelete = "";
        }
      }

      var template;
      template = attribute.type.toSql ? attribute.type.toSql() : "";

      if (attribute.type instanceof DataTypes.JSON) {
        template += " CHECK (".concat(this.quoteIdentifier(options.attributeName), " IS JSON)");
        return template;
      }

      if (Utils.defaultValueSchemable(attribute.defaultValue)) {
        template += " DEFAULT ".concat(this.escape(attribute.defaultValue));
      }

      if (attribute.allowNull === false) {
        template += " NOT NULL";
      }

      if (attribute.type instanceof DataTypes.ENUM) {
        if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;
        template += " CHECK (".concat(this.quoteIdentifier(options.attributeName), " IN(").concat(_.map(attribute.values, function (value) {
          return _this4.escape(value);
        }).join(", "), "))");
        return template;
      }

      if (attribute.type instanceof DataTypes.BOOLEAN) {
        template += " CHECK (".concat(this.quoteIdentifier(options.attributeName), " IN('1', '0'))");
        return template;
      }

      if (attribute.autoIncrement) {
        template = " NUMBER(*,0) GENERATED BY DEFAULT ON NULL AS IDENTITY";
      } else if (attribute.type && attribute.type.key === DataTypes.DOUBLE.key) {
        template = attribute.type.toSql();
      } else if (attribute.type) {
        var unsignedTemplate = "";

        if (attribute.type._unsigned) {
          attribute.type._unsigned = false;
          unsignedTemplate += " check(".concat(this.quoteIdentifier(options.attributeName), " >= 0)");
        }

        template = attribute.type.toString();

        if (attribute.type && attribute.type !== "TEXT" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {
          template += " DEFAULT ".concat(this.escape(attribute.defaultValue));
        }

        if (!attribute.autoIncrement) {
          if (attribute.allowNull === false) {
            template += " NOT NULL";
          } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {
            template += " NULL";
          }
        }

        template += unsignedTemplate;
      } else {
        template = "";
      }

      if (attribute.unique === true && !attribute.primaryKey) {
        template += " UNIQUE";
      }

      if (attribute.primaryKey) {
        template += " PRIMARY KEY";
      }

      if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {
        template += " REFERENCES ".concat(this.quoteTable(attribute.references.model));

        if (attribute.references.key) {
          template += " (".concat(this.quoteIdentifier(attribute.references.key), ")");
        } else {
          template += " (".concat(this.quoteIdentifier("id"), ")");
        }

        if (attribute.onDelete && attribute.onDelete.toUpperCase() !== "NO ACTION") {
          template += " ON DELETE ".concat(attribute.onDelete.toUpperCase());
        }
      }

      return template;
    }
  }, {
    key: "attributesToSQL",
    value: function attributesToSQL(attributes, options) {
      var result = {};

      for (var key in attributes) {
        var attribute = attributes[key];
        var attributeName = attribute.field || key;
        result[attributeName] = this.attributeToSQL(attribute, __spreadValues({
          attributeName: attributeName
        }, options));
      }

      return result;
    }
  }, {
    key: "createTrigger",
    value: function createTrigger() {
      throwMethodUndefined("createTrigger");
    }
  }, {
    key: "dropTrigger",
    value: function dropTrigger() {
      throwMethodUndefined("dropTrigger");
    }
  }, {
    key: "renameTrigger",
    value: function renameTrigger() {
      throwMethodUndefined("renameTrigger");
    }
  }, {
    key: "createFunction",
    value: function createFunction() {
      throwMethodUndefined("createFunction");
    }
  }, {
    key: "dropFunction",
    value: function dropFunction() {
      throwMethodUndefined("dropFunction");
    }
  }, {
    key: "renameFunction",
    value: function renameFunction() {
      throwMethodUndefined("renameFunction");
    }
  }, {
    key: "getConstraintsOnColumn",
    value: function getConstraintsOnColumn(table, column) {
      var _this$getSchemaNameAn7 = this.getSchemaNameAndTableName(table),
          _this$getSchemaNameAn8 = _slicedToArray(_this$getSchemaNameAn7, 2),
          tableName = _this$getSchemaNameAn8[0],
          schemaName = _this$getSchemaNameAn8[1];

      column = this.getCatalogName(column);
      var sql = ["SELECT CONSTRAINT_NAME FROM user_cons_columns WHERE TABLE_NAME = ", this.escape(tableName), " and OWNER = ", table.schema ? this.escape(schemaName) : "USER", " and COLUMN_NAME = ", this.escape(column), " AND POSITION IS NOT NULL ORDER BY POSITION"].join("");
      return sql;
    }
  }, {
    key: "getForeignKeysQuery",
    value: function getForeignKeysQuery(table) {
      var _this$getSchemaNameAn9 = this.getSchemaNameAndTableName(table),
          _this$getSchemaNameAn10 = _slicedToArray(_this$getSchemaNameAn9, 2),
          tableName = _this$getSchemaNameAn10[0],
          schemaName = _this$getSchemaNameAn10[1];

      var sql = ['SELECT DISTINCT  a.table_name "tableName", a.constraint_name "constraintName", a.owner "owner",  a.column_name "columnName",', ' b.table_name "referencedTableName", b.column_name "referencedColumnName"', " FROM all_cons_columns a", " JOIN all_constraints c ON a.owner = c.owner AND a.constraint_name = c.constraint_name", " JOIN all_cons_columns b ON c.owner = b.owner AND c.r_constraint_name = b.constraint_name", " WHERE c.constraint_type  = 'R'", " AND a.table_name = ", this.escape(tableName), " AND a.owner = ", table.schema ? this.escape(schemaName) : "USER", " ORDER BY a.table_name, a.constraint_name"].join("");
      return sql;
    }
  }, {
    key: "dropForeignKeyQuery",
    value: function dropForeignKeyQuery(tableName, foreignKey) {
      return this.dropConstraintQuery(tableName, foreignKey);
    }
  }, {
    key: "getPrimaryKeyConstraintQuery",
    value: function getPrimaryKeyConstraintQuery(table) {
      var _this$getSchemaNameAn11 = this.getSchemaNameAndTableName(table),
          _this$getSchemaNameAn12 = _slicedToArray(_this$getSchemaNameAn11, 2),
          tableName = _this$getSchemaNameAn12[0],
          schemaName = _this$getSchemaNameAn12[1];

      var sql = ["SELECT cols.column_name, atc.identity_column ", "FROM all_constraints cons, all_cons_columns cols ", "INNER JOIN all_tab_columns atc ON(atc.table_name = cols.table_name AND atc.COLUMN_NAME = cols.COLUMN_NAME )", "WHERE cols.table_name = ", this.escape(tableName), "AND cols.owner = ", table.schema ? this.escape(schemaName) : "USER ", "AND cons.constraint_type = 'P' ", "AND cons.constraint_name = cols.constraint_name ", "AND cons.owner = cols.owner ", "ORDER BY cols.table_name, cols.position"].join("");
      return sql;
    }
  }, {
    key: "dropConstraintQuery",
    value: function dropConstraintQuery(tableName, constraintName) {
      return "ALTER TABLE ".concat(this.quoteTable(tableName), " DROP CONSTRAINT ").concat(constraintName);
    }
  }, {
    key: "setIsolationLevelQuery",
    value: function setIsolationLevelQuery(value, options) {
      if (options.parent) {
        return;
      }

      switch (value) {
        case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:
        case Transaction.ISOLATION_LEVELS.READ_COMMITTED:
          return "SET TRANSACTION ISOLATION LEVEL READ COMMITTED;";

        case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:
          return "SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;";

        default:
          throw new Error("isolation level \"".concat(value, "\" is not supported"));
      }
    }
  }, {
    key: "getAliasToken",
    value: function getAliasToken() {
      return "";
    }
  }, {
    key: "startTransactionQuery",
    value: function startTransactionQuery(transaction) {
      if (transaction.parent) {
        return "SAVEPOINT ".concat(this.quoteIdentifier(transaction.name));
      }

      return "BEGIN TRANSACTION";
    }
  }, {
    key: "commitTransactionQuery",
    value: function commitTransactionQuery(transaction) {
      if (transaction.parent) {
        return;
      }

      return "COMMIT TRANSACTION";
    }
  }, {
    key: "rollbackTransactionQuery",
    value: function rollbackTransactionQuery(transaction) {
      if (transaction.parent) {
        return "ROLLBACK TO SAVEPOINT ".concat(this.quoteIdentifier(transaction.name));
      }

      return "ROLLBACK TRANSACTION";
    }
  }, {
    key: "handleSequelizeMethod",
    value: function handleSequelizeMethod(smth, tableName, factory, options, prepend) {
      var _this5 = this;

      var str;

      if (smth instanceof Utils.Json) {
        if (smth.conditions) {
          var conditions = this.parseConditionObject(smth.conditions).map(function (condition) {
            return "".concat(_this5.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path)), " = '").concat(condition.value, "'");
          });
          return conditions.join(" AND ");
        }

        if (smth.path) {
          if (this._checkValidJsonStatement(smth.path)) {
            str = smth.path;
          } else {
            var paths = _.toPath(smth.path);

            var column = paths.shift();
            str = this.jsonPathExtractionQuery(column, paths);
          }

          if (smth.value) {
            str += util.format(" = %s", this.escape(smth.value));
          }

          return str;
        }
      }

      if (smth instanceof Utils.Cast) {
        if (smth.val instanceof Utils.SequelizeMethod) {
          str = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);

          if (smth.type === "boolean") {
            str = "(CASE WHEN ".concat(str, "='true' THEN 1 ELSE 0 END)");
            return "CAST(".concat(str, " AS NUMBER)");
          }

          if (smth.type === "timestamptz" && /json_value\(/.test(str)) {
            str = str.slice(0, -1);
            return "".concat(str, " RETURNING TIMESTAMP WITH TIME ZONE)");
          }
        }
      }

      return _get(_getPrototypeOf(_OracleQueryGenerator.prototype), "handleSequelizeMethod", this).call(this, smth, tableName, factory, options, prepend);
    }
  }, {
    key: "_checkValidJsonStatement",
    value: function _checkValidJsonStatement(stmt) {
      if (typeof stmt !== "string") {
        return false;
      }

      var currentIndex = 0;
      var openingBrackets = 0;
      var closingBrackets = 0;
      var hasJsonFunction = false;
      var hasInvalidToken = false;

      while (currentIndex < stmt.length) {
        var string = stmt.substr(currentIndex);
        var functionMatches = JSON_FUNCTION_REGEX.exec(string);

        if (functionMatches) {
          currentIndex += functionMatches[0].indexOf("(");
          hasJsonFunction = true;
          continue;
        }

        var operatorMatches = JSON_OPERATOR_REGEX.exec(string);

        if (operatorMatches) {
          currentIndex += operatorMatches[0].length;
          hasJsonFunction = true;
          continue;
        }

        var tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);

        if (tokenMatches) {
          var capturedToken = tokenMatches[1];

          if (capturedToken === "(") {
            openingBrackets++;
          } else if (capturedToken === ")") {
            closingBrackets++;
          } else if (capturedToken === ";") {
            hasInvalidToken = true;
            break;
          }

          currentIndex += tokenMatches[0].length;
          continue;
        }

        break;
      }

      if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {
        throw new Error("Invalid json statement: ".concat(stmt));
      }

      return hasJsonFunction;
    }
  }, {
    key: "jsonPathExtractionQuery",
    value: function jsonPathExtractionQuery(column, path) {
      var paths = _.toPath(path);

      var quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);
      paths = paths.map(function (subPath) {
        return /\D/.test(subPath) ? Utils.addTicks(subPath, '"') : subPath;
      });
      var pathStr = this.escape(["$"].concat(paths).join(".").replace(/\.(\d+)(?:(?=\.)|$)/g, function (__, digit) {
        return "[".concat(digit, "]");
      }));
      return "json_value(".concat(quotedColumn, ",").concat(pathStr, ")");
    }
  }, {
    key: "addLimitAndOffset",
    value: function addLimitAndOffset(options, model) {
      var fragment = "";
      var offset = options.offset || 0,
          isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;
      var orders = {};

      if (options.order) {
        orders = this.getQueryOrders(options, model, isSubQuery);
      }

      if (options.limit || options.offset) {
        if (!orders.mainQueryOrder || !orders.mainQueryOrder.length || isSubQuery && (!orders.subQueryOrder || !orders.subQueryOrder.length)) {
          var tablePkFragment = "".concat(this.quoteTable(options.tableAs || model.name), ".").concat(this.quoteIdentifier(model.primaryKeyField));
          fragment += " ORDER BY ".concat(tablePkFragment);
        }

        if (options.offset || options.limit) {
          fragment += " OFFSET ".concat(this.escape(offset), " ROWS");
        }

        if (options.limit) {
          fragment += " FETCH NEXT ".concat(this.escape(options.limit), " ROWS ONLY");
        }
      }

      return fragment;
    }
  }, {
    key: "booleanValue",
    value: function booleanValue(value) {
      return value ? 1 : 0;
    }
  }, {
    key: "quoteIdentifier",
    value: function quoteIdentifier(identifier) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var optForceQuote = force;
      var optQuoteIdentifiers = this.options.quoteIdentifiers !== false;
      var rawIdentifier = Utils.removeTicks(identifier, '"');
      var regExp = /^(([\w][\w\d_]*))$/g;

      if (optForceQuote !== true && optQuoteIdentifiers === false && regExp.test(rawIdentifier) && !ORACLE_RESERVED_WORDS.includes(rawIdentifier.toUpperCase())) {
        return rawIdentifier;
      }

      return Utils.addTicks(rawIdentifier, '"');
    }
  }, {
    key: "bindParam",
    value: function bindParam(bind) {
      var posOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return function (value) {
        bind.push(value);
        return ":".concat(bind.length + posOffset);
      };
    }
  }, {
    key: "authTestQuery",
    value: function authTestQuery() {
      return "SELECT 1+1 AS result FROM DUAL";
    }
  }]);

  return _OracleQueryGenerator;
}(AbstractQueryGenerator);

function throwMethodUndefined(methodName) {
  throw new Error("The method \"".concat(methodName, "\" is not defined! Please add it to your sql dialect."));
}