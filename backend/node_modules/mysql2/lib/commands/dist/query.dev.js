'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var process = require('process');

var Timers = require('timers');

var Readable = require('stream').Readable;

var Command = require('./command.js');

var Packets = require('../packets/index.js');

var getTextParser = require('../parsers/text_parser.js');

var ServerStatus = require('../constants/server_status.js');

var EmptyPacket = new Packets.Packet(0, Buffer.allocUnsafe(4), 0, 4); // http://dev.mysql.com/doc/internals/en/com-query.html

var Query =
/*#__PURE__*/
function (_Command) {
  _inherits(Query, _Command);

  function Query(options, callback) {
    var _this;

    _classCallCheck(this, Query);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Query).call(this));
    _this.sql = options.sql;
    _this.values = options.values;
    _this._queryOptions = options;
    _this.namedPlaceholders = options.namedPlaceholders || false;
    _this.onResult = callback;
    _this.timeout = options.timeout;
    _this.queryTimeout = null;
    _this._fieldCount = 0;
    _this._rowParser = null;
    _this._fields = [];
    _this._rows = [];
    _this._receivedFieldsCount = 0;
    _this._resultIndex = 0;
    _this._localStream = null;

    _this._unpipeStream = function () {};

    _this._streamFactory = options.infileStreamFactory;
    _this._connection = null;
    return _this;
  }

  _createClass(Query, [{
    key: "then",
    value: function then() {
      var err = "You have tried to call .then(), .catch(), or invoked await on the result of query that is not a promise, which is a programming error. Try calling con.promise().query(), or require('mysql2/promise') instead of 'mysql2' for a promise-compatible version of the query interface. To learn how to use async/await or Promises check out documentation at https://sidorares.github.io/node-mysql2/docs#using-promise-wrapper, or the mysql2 documentation at https://sidorares.github.io/node-mysql2/docs/documentation/promise-wrapper"; // eslint-disable-next-line

      console.log(err);
      throw new Error(err);
    }
    /* eslint no-unused-vars: ["error", { "argsIgnorePattern": "^_" }] */

  }, {
    key: "start",
    value: function start(_packet, connection) {
      if (connection.config.debug) {
        // eslint-disable-next-line
        console.log('        Sending query command: %s', this.sql);
      }

      this._connection = connection;
      this.options = Object.assign({}, connection.config, this._queryOptions);

      this._setTimeout();

      var cmdPacket = new Packets.Query(this.sql, connection.config.charsetNumber);
      connection.writePacket(cmdPacket.toPacket(1));
      return Query.prototype.resultsetHeader;
    }
  }, {
    key: "done",
    value: function done() {
      var _this2 = this;

      this._unpipeStream(); // if all ready timeout, return null directly


      if (this.timeout && !this.queryTimeout) {
        return null;
      } // else clear timer


      if (this.queryTimeout) {
        Timers.clearTimeout(this.queryTimeout);
        this.queryTimeout = null;
      }

      if (this.onResult) {
        var rows, fields;

        if (this._resultIndex === 0) {
          rows = this._rows[0];
          fields = this._fields[0];
        } else {
          rows = this._rows;
          fields = this._fields;
        }

        if (fields) {
          process.nextTick(function () {
            _this2.onResult(null, rows, fields);
          });
        } else {
          process.nextTick(function () {
            _this2.onResult(null, rows);
          });
        }
      }

      return null;
    }
  }, {
    key: "doneInsert",
    value: function doneInsert(rs) {
      if (this._localStreamError) {
        if (this.onResult) {
          this.onResult(this._localStreamError, rs);
        } else {
          this.emit('error', this._localStreamError);
        }

        return null;
      }

      this._rows.push(rs);

      this._fields.push(void 0);

      this.emit('fields', void 0);
      this.emit('result', rs);

      if (rs.serverStatus & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {
        this._resultIndex++;
        return this.resultsetHeader;
      }

      return this.done();
    }
  }, {
    key: "resultsetHeader",
    value: function resultsetHeader(packet, connection) {
      var rs = new Packets.ResultSetHeader(packet, connection);
      this._fieldCount = rs.fieldCount;

      if (connection.config.debug) {
        // eslint-disable-next-line
        console.log("        Resultset header received, expecting ".concat(rs.fieldCount, " column definition packets"));
      }

      if (this._fieldCount === 0) {
        return this.doneInsert(rs);
      }

      if (this._fieldCount === null) {
        return this._streamLocalInfile(connection, rs.infileName);
      }

      this._receivedFieldsCount = 0;

      this._rows.push([]);

      this._fields.push([]);

      return this.readField;
    }
  }, {
    key: "_streamLocalInfile",
    value: function _streamLocalInfile(connection, path) {
      var _this3 = this;

      if (this._streamFactory) {
        this._localStream = this._streamFactory(path);
      } else {
        this._localStreamError = new Error("As a result of LOCAL INFILE command server wants to read ".concat(path, " file, but as of v2.0 you must provide streamFactory option returning ReadStream."));
        connection.writePacket(EmptyPacket);
        return this.infileOk;
      }

      var onConnectionError = function onConnectionError() {
        _this3._unpipeStream();
      };

      var onDrain = function onDrain() {
        _this3._localStream.resume();
      };

      var onPause = function onPause() {
        _this3._localStream.pause();
      };

      var onData = function onData(data) {
        var dataWithHeader = Buffer.allocUnsafe(data.length + 4);
        data.copy(dataWithHeader, 4);
        connection.writePacket(new Packets.Packet(0, dataWithHeader, 0, dataWithHeader.length));
      };

      var onEnd = function onEnd() {
        connection.removeListener('error', onConnectionError);
        connection.writePacket(EmptyPacket);
      };

      var onError = function onError(err) {
        _this3._localStreamError = err;
        connection.removeListener('error', onConnectionError);
        connection.writePacket(EmptyPacket);
      };

      this._unpipeStream = function () {
        connection.stream.removeListener('pause', onPause);
        connection.stream.removeListener('drain', onDrain);

        _this3._localStream.removeListener('data', onData);

        _this3._localStream.removeListener('end', onEnd);

        _this3._localStream.removeListener('error', onError);
      };

      connection.stream.on('pause', onPause);
      connection.stream.on('drain', onDrain);

      this._localStream.on('data', onData);

      this._localStream.on('end', onEnd);

      this._localStream.on('error', onError);

      connection.once('error', onConnectionError);
      return this.infileOk;
    }
  }, {
    key: "readField",
    value: function readField(packet, connection) {
      this._receivedFieldsCount++; // Often there is much more data in the column definition than in the row itself
      // If you set manually _fields[0] to array of ColumnDefinition's (from previous call)
      // you can 'cache' result of parsing. Field packets still received, but ignored in that case
      // this is the reason _receivedFieldsCount exist (otherwise we could just use current length of fields array)

      if (this._fields[this._resultIndex].length !== this._fieldCount) {
        var field = new Packets.ColumnDefinition(packet, connection.clientEncoding);

        this._fields[this._resultIndex].push(field);

        if (connection.config.debug) {
          /* eslint-disable no-console */
          console.log('        Column definition:');
          console.log("          name: ".concat(field.name));
          console.log("          type: ".concat(field.columnType));
          console.log("         flags: ".concat(field.flags));
          /* eslint-enable no-console */
        }
      } // last field received


      if (this._receivedFieldsCount === this._fieldCount) {
        var fields = this._fields[this._resultIndex];
        this.emit('fields', fields);
        this._rowParser = new (getTextParser(fields, this.options, connection.config))(fields);
        return Query.prototype.fieldsEOF;
      }

      return Query.prototype.readField;
    }
  }, {
    key: "fieldsEOF",
    value: function fieldsEOF(packet, connection) {
      // check EOF
      if (!packet.isEOF()) {
        return connection.protocolError('Expected EOF packet');
      }

      return this.row;
    }
    /* eslint no-unused-vars: ["error", { "argsIgnorePattern": "^_" }] */

  }, {
    key: "row",
    value: function row(packet, _connection) {
      if (packet.isEOF()) {
        var status = packet.eofStatusFlags();
        var moreResults = status & ServerStatus.SERVER_MORE_RESULTS_EXISTS;

        if (moreResults) {
          this._resultIndex++;
          return Query.prototype.resultsetHeader;
        }

        return this.done();
      }

      var row;

      try {
        row = this._rowParser.next(packet, this._fields[this._resultIndex], this.options);
      } catch (err) {
        this._localStreamError = err;
        return this.doneInsert(null);
      }

      if (this.onResult) {
        this._rows[this._resultIndex].push(row);
      } else {
        this.emit('result', row, this._resultIndex);
      }

      return Query.prototype.row;
    }
  }, {
    key: "infileOk",
    value: function infileOk(packet, connection) {
      var rs = new Packets.ResultSetHeader(packet, connection);
      return this.doneInsert(rs);
    }
  }, {
    key: "stream",
    value: function stream(options) {
      var _this4 = this;

      options = options || {};
      options.objectMode = true;
      var stream = new Readable(options);

      stream._read = function () {
        _this4._connection && _this4._connection.resume();
      };

      this.on('result', function (row, resultSetIndex) {
        if (!stream.push(row)) {
          _this4._connection.pause();
        }

        stream.emit('result', row, resultSetIndex); // replicate old emitter
      });
      this.on('error', function (err) {
        stream.emit('error', err); // Pass on any errors
      });
      this.on('end', function () {
        stream.push(null); // pushing null, indicating EOF
      });
      this.on('fields', function (fields) {
        stream.emit('fields', fields); // replicate old emitter
      });
      stream.on('end', function () {
        stream.emit('close');
      });
      return stream;
    }
  }, {
    key: "_setTimeout",
    value: function _setTimeout() {
      if (this.timeout) {
        var timeoutHandler = this._handleTimeoutError.bind(this);

        this.queryTimeout = Timers.setTimeout(timeoutHandler, this.timeout);
      }
    }
  }, {
    key: "_handleTimeoutError",
    value: function _handleTimeoutError() {
      if (this.queryTimeout) {
        Timers.clearTimeout(this.queryTimeout);
        this.queryTimeout = null;
      }

      var err = new Error('Query inactivity timeout');
      err.errorno = 'PROTOCOL_SEQUENCE_TIMEOUT';
      err.code = 'PROTOCOL_SEQUENCE_TIMEOUT';
      err.syscall = 'query';

      if (this.onResult) {
        this.onResult(err);
      } else {
        this.emit('error', err);
      }
    }
  }]);

  return Query;
}(Command);

Query.prototype["catch"] = Query.prototype.then;
module.exports = Query;