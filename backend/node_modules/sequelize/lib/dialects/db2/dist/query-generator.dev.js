"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return a;
};

var __spreadProps = function __spreadProps(a, b) {
  return __defProps(a, __getOwnPropDescs(b));
};

var _ = require("lodash");

var Utils = require("../../utils");

var DataTypes = require("../../data-types");

var AbstractQueryGenerator = require("../abstract/query-generator");

var randomBytes = require("crypto").randomBytes;

var Op = require("../../operators");

var throwMethodUndefined = function throwMethodUndefined(methodName) {
  throw new Error("The method \"".concat(methodName, "\" is not defined! Please add it to your sql dialect."));
};

var Db2QueryGenerator =
/*#__PURE__*/
function (_AbstractQueryGenerat) {
  _inherits(Db2QueryGenerator, _AbstractQueryGenerat);

  function Db2QueryGenerator(options) {
    var _spreadProps;

    var _this;

    _classCallCheck(this, Db2QueryGenerator);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Db2QueryGenerator).call(this, options));
    _this.OperatorMap = __spreadProps(__spreadValues({}, _this.OperatorMap), (_spreadProps = {}, _defineProperty(_spreadProps, Op.regexp, "REGEXP_LIKE"), _defineProperty(_spreadProps, Op.notRegexp, "NOT REGEXP_LIKE"), _spreadProps));
    _this.autoGenValue = 1;
    return _this;
  }

  _createClass(Db2QueryGenerator, [{
    key: "createSchema",
    value: function createSchema(schema) {
      return ["CREATE SCHEMA", this.quoteIdentifier(schema), ";"].join(" ");
    }
  }, {
    key: "dropSchema",
    value: function dropSchema(schema) {
      var query = "CALL SYSPROC.ADMIN_DROP_SCHEMA(".concat(wrapSingleQuote(schema.trim()), ", NULL, ? , ?)");
      var sql = {
        query: query
      };
      sql.bind = [{
        ParamType: "INOUT",
        Data: "ERRORSCHEMA"
      }, {
        ParamType: "INOUT",
        Data: "ERRORTABLE"
      }];
      return sql;
    }
  }, {
    key: "showSchemasQuery",
    value: function showSchemasQuery() {
      return "SELECT SCHEMANAME AS \"schema_name\" FROM SYSCAT.SCHEMATA WHERE (SCHEMANAME NOT LIKE 'SYS%') AND SCHEMANAME NOT IN ('NULLID', 'SQLJ', 'ERRORSCHEMA')";
    }
  }, {
    key: "versionQuery",
    value: function versionQuery() {
      return "select service_level as VERSION from TABLE (sysproc.env_get_inst_info()) as A";
    }
  }, {
    key: "createTableQuery",
    value: function createTableQuery(tableName, attributes, options) {
      var _this2 = this;

      var query = "CREATE TABLE <%= table %> (<%= attributes %>)",
          primaryKeys = [],
          foreignKeys = {},
          attrStr = [],
          commentTemplate = " -- <%= comment %>, TableName = <%= table %>, ColumnName = <%= column %>;";
      var commentStr = "";

      for (var attr in attributes) {
        if (Object.prototype.hasOwnProperty.call(attributes, attr)) {
          var dataType = attributes[attr];
          var match = void 0;

          if (dataType.includes("COMMENT ")) {
            var commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);

            if (commentMatch && commentMatch.length > 2) {
              var commentText = commentMatch[2].replace(/COMMENT/, "").trim();
              commentStr += _.template(commentTemplate, this._templateSettings)({
                table: this.quoteIdentifier(tableName),
                comment: this.escape(commentText),
                column: this.quoteIdentifier(attr)
              });
              dataType = commentMatch[1];
            }
          }

          if (_.includes(dataType, "PRIMARY KEY")) {
            primaryKeys.push(attr);

            if (_.includes(dataType, "REFERENCES")) {
              match = dataType.match(/^(.+) (REFERENCES.*)$/);
              attrStr.push("".concat(this.quoteIdentifier(attr), " ").concat(match[1].replace(/PRIMARY KEY/, "")));
              foreignKeys[attr] = match[2];
            } else {
              attrStr.push("".concat(this.quoteIdentifier(attr), " ").concat(dataType.replace(/PRIMARY KEY/, "")));
            }
          } else if (_.includes(dataType, "REFERENCES")) {
            match = dataType.match(/^(.+) (REFERENCES.*)$/);
            attrStr.push("".concat(this.quoteIdentifier(attr), " ").concat(match[1]));
            foreignKeys[attr] = match[2];
          } else {
            if (options && options.uniqueKeys) {
              for (var ukey in options.uniqueKeys) {
                if (options.uniqueKeys[ukey].fields.includes(attr) && !_.includes(dataType, "NOT NULL")) {
                  dataType += " NOT NULL";
                  break;
                }
              }
            }

            attrStr.push("".concat(this.quoteIdentifier(attr), " ").concat(dataType));
          }
        }
      }

      var values = {
        table: this.quoteTable(tableName),
        attributes: attrStr.join(", ")
      },
          pkString = primaryKeys.map(function (pk) {
        return _this2.quoteIdentifier(pk);
      }).join(", ");

      if (options && options.uniqueKeys) {
        _.each(options.uniqueKeys, function (columns, indexName) {
          if (columns.customIndex) {
            if (!_.isString(indexName)) {
              indexName = "uniq_".concat(tableName, "_").concat(columns.fields.join("_"));
            }

            values.attributes += ", CONSTRAINT ".concat(_this2.quoteIdentifier(indexName), " UNIQUE (").concat(columns.fields.map(function (field) {
              return _this2.quoteIdentifier(field);
            }).join(", "), ")");
          }
        });
      }

      if (pkString.length > 0) {
        values.attributes += ", PRIMARY KEY (".concat(pkString, ")");
      }

      for (var fkey in foreignKeys) {
        if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
          values.attributes += ", FOREIGN KEY (".concat(this.quoteIdentifier(fkey), ") ").concat(foreignKeys[fkey]);
        }
      }

      return "".concat(_.template(query, this._templateSettings)(values).trim(), ";").concat(commentStr);
    }
  }, {
    key: "describeTableQuery",
    value: function describeTableQuery(tableName, schema) {
      var sql = ['SELECT NAME AS "Name", TBNAME AS "Table", TBCREATOR AS "Schema",', 'TRIM(COLTYPE) AS "Type", LENGTH AS "Length", SCALE AS "Scale",', 'NULLS AS "IsNull", DEFAULT AS "Default", COLNO AS "Colno",', 'IDENTITY AS "IsIdentity", KEYSEQ AS "KeySeq", REMARKS AS "Comment"', "FROM", "SYSIBM.SYSCOLUMNS", "WHERE TBNAME =", wrapSingleQuote(tableName)].join(" ");

      if (schema) {
        sql += " AND TBCREATOR =".concat(wrapSingleQuote(schema));
      } else {
        sql += " AND TBCREATOR = USER";
      }

      return "".concat(sql, ";");
    }
  }, {
    key: "renameTableQuery",
    value: function renameTableQuery(before, after) {
      var query = "RENAME TABLE <%= before %> TO <%= after %>;";
      return _.template(query, this._templateSettings)({
        before: this.quoteTable(before),
        after: this.quoteTable(after)
      });
    }
  }, {
    key: "showTablesQuery",
    value: function showTablesQuery() {
      return "SELECT TABNAME AS \"tableName\", TRIM(TABSCHEMA) AS \"tableSchema\" FROM SYSCAT.TABLES WHERE TABSCHEMA = USER AND TYPE = 'T' ORDER BY TABSCHEMA, TABNAME";
    }
  }, {
    key: "tableExistsQuery",
    value: function tableExistsQuery(table) {
      var tableName = table.tableName || table;
      var schemaName = table.schema || this.sequelize.config.username.toUpperCase();
      return "SELECT name FROM sysibm.systables WHERE NAME = ".concat(wrapSingleQuote(tableName), " AND CREATOR = ").concat(wrapSingleQuote(schemaName));
    }
  }, {
    key: "dropTableQuery",
    value: function dropTableQuery(tableName) {
      var query = "DROP TABLE <%= table %>";
      var values = {
        table: this.quoteTable(tableName)
      };
      return "".concat(_.template(query, this._templateSettings)(values).trim(), ";");
    }
  }, {
    key: "addColumnQuery",
    value: function addColumnQuery(table, key, dataType) {
      dataType.field = key;

      var query = "ALTER TABLE <%= table %> ADD <%= attribute %>;",
          attribute = _.template("<%= key %> <%= definition %>", this._templateSettings)({
        key: this.quoteIdentifier(key),
        definition: this.attributeToSQL(dataType, {
          context: "addColumn"
        })
      });

      return _.template(query, this._templateSettings)({
        table: this.quoteTable(table),
        attribute: attribute
      });
    }
  }, {
    key: "removeColumnQuery",
    value: function removeColumnQuery(tableName, attributeName) {
      var query = "ALTER TABLE <%= tableName %> DROP COLUMN <%= attributeName %>;";
      return _.template(query, this._templateSettings)({
        tableName: this.quoteTable(tableName),
        attributeName: this.quoteIdentifier(attributeName)
      });
    }
  }, {
    key: "changeColumnQuery",
    value: function changeColumnQuery(tableName, attributes) {
      var query = "ALTER TABLE <%= tableName %> <%= query %>;";
      var attrString = [],
          constraintString = [];

      for (var attributeName in attributes) {
        var attrValue = attributes[attributeName];
        var defs = [attrValue];

        if (Array.isArray(attrValue)) {
          defs = attrValue;
        }

        for (var i = 0; i < defs.length; i++) {
          var definition = defs[i];

          if (definition.match(/REFERENCES/)) {
            constraintString.push(_.template("<%= fkName %> FOREIGN KEY (<%= attrName %>) <%= definition %>", this._templateSettings)({
              fkName: this.quoteIdentifier("".concat(attributeName, "_foreign_idx")),
              attrName: this.quoteIdentifier(attributeName),
              definition: definition.replace(/.+?(?=REFERENCES)/, "")
            }));
          } else if (_.startsWith(definition, "DROP ")) {
            attrString.push(_.template("<%= attrName %> <%= definition %>", this._templateSettings)({
              attrName: this.quoteIdentifier(attributeName),
              definition: definition
            }));
          } else {
            attrString.push(_.template("<%= attrName %> SET <%= definition %>", this._templateSettings)({
              attrName: this.quoteIdentifier(attributeName),
              definition: definition
            }));
          }
        }
      }

      var finalQuery = "";

      if (attrString.length) {
        finalQuery += "ALTER COLUMN ".concat(attrString.join(" ALTER COLUMN "));
        finalQuery += constraintString.length ? " " : "";
      }

      if (constraintString.length) {
        finalQuery += "ADD CONSTRAINT ".concat(constraintString.join(" ADD CONSTRAINT "));
      }

      return _.template(query, this._templateSettings)({
        tableName: this.quoteTable(tableName),
        query: finalQuery
      });
    }
  }, {
    key: "renameColumnQuery",
    value: function renameColumnQuery(tableName, attrBefore, attributes) {
      var query = "ALTER TABLE <%= tableName %> RENAME COLUMN <%= before %> TO <%= after %>;",
          newName = Object.keys(attributes)[0];
      return _.template(query, this._templateSettings)({
        tableName: this.quoteTable(tableName),
        before: this.quoteIdentifier(attrBefore),
        after: this.quoteIdentifier(newName)
      });
    }
  }, {
    key: "addConstraintQuery",
    value: function addConstraintQuery(tableName, options) {
      options = options || {};

      if (options.onUpdate && options.onUpdate.toUpperCase() === "CASCADE") {
        delete options.onUpdate;
      }

      var constraintSnippet = this.getConstraintSnippet(tableName, options);

      if (typeof tableName === "string") {
        tableName = this.quoteIdentifiers(tableName);
      } else {
        tableName = this.quoteTable(tableName);
      }

      return "ALTER TABLE ".concat(tableName, " ADD ").concat(constraintSnippet, ";");
    }
  }, {
    key: "bulkInsertQuery",
    value: function bulkInsertQuery(tableName, attrValueHashes, options, attributes) {
      var _this3 = this;

      options = options || {};
      attributes = attributes || {};
      var query = "INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>;";

      if (options.returning) {
        query = "SELECT * FROM FINAL TABLE( INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>);";
      }

      var emptyQuery = "INSERT INTO <%= table %>",
          tuples = [],
          allAttributes = [],
          allQueries = [];
      var outputFragment;
      var valuesForEmptyQuery = [];

      if (options.returning) {
        outputFragment = "";
      }

      _.forEach(attrValueHashes, function (attrValueHash) {
        var fields = Object.keys(attrValueHash);
        var firstAttr = attributes[fields[0]];

        if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {
          valuesForEmptyQuery.push("(".concat(_this3.autoGenValue++, ")"));
          return;
        }

        _.forOwn(attrValueHash, function (value, key) {
          if (allAttributes.indexOf(key) === -1) {
            if (value === null && attributes[key] && attributes[key].autoIncrement) return;
            allAttributes.push(key);
          }
        });
      });

      if (valuesForEmptyQuery.length > 0) {
        allQueries.push("".concat(emptyQuery, " VALUES ").concat(valuesForEmptyQuery.join(",")));
      }

      if (allAttributes.length > 0) {
        _.forEach(attrValueHashes, function (attrValueHash) {
          tuples.push("(".concat(allAttributes.map(function (key) {
            return _this3.escape(attrValueHash[key]);
          }, void 0, {
            context: "INSERT"
          }).join(","), ")"));
        });

        allQueries.push(query);
      }

      var replacements = {
        table: this.quoteTable(tableName),
        attributes: allAttributes.map(function (attr) {
          return _this3.quoteIdentifier(attr);
        }).join(","),
        tuples: tuples,
        output: outputFragment
      };

      var generatedQuery = _.template(allQueries.join(";"), this._templateSettings)(replacements);

      return generatedQuery;
    }
  }, {
    key: "updateQuery",
    value: function updateQuery(tableName, attrValueHash, where, options, attributes) {
      var sql = _get(_getPrototypeOf(Db2QueryGenerator.prototype), "updateQuery", this).call(this, tableName, attrValueHash, where, options, attributes);

      options = options || {};

      _.defaults(options, this.options);

      if (!options.limit) {
        sql.query = "SELECT * FROM FINAL TABLE (".concat(sql.query, ");");
        return sql;
      }

      attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);
      var modelAttributeMap = {};
      var values = [];
      var bind = [];
      var bindParam = options.bindParam || this.bindParam(bind);

      if (attributes) {
        _.each(attributes, function (attribute, key) {
          modelAttributeMap[key] = attribute;

          if (attribute.field) {
            modelAttributeMap[attribute.field] = attribute;
          }
        });
      }

      for (var key in attrValueHash) {
        var value = attrValueHash[key];

        if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
          values.push("".concat(this.quoteIdentifier(key), "=").concat(this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
            context: "UPDATE"
          })));
        } else {
          values.push("".concat(this.quoteIdentifier(key), "=").concat(this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
            context: "UPDATE"
          }, bindParam)));
        }
      }

      var query;

      var whereOptions = _.defaults({
        bindParam: bindParam
      }, options);

      query = "UPDATE (SELECT * FROM ".concat(this.quoteTable(tableName), " ").concat(this.whereQuery(where, whereOptions), " FETCH NEXT ").concat(this.escape(options.limit), " ROWS ONLY) SET ").concat(values.join(","));
      query = "SELECT * FROM FINAL TABLE (".concat(query, ");");
      return {
        query: query,
        bind: bind
      };
    }
  }, {
    key: "upsertQuery",
    value: function upsertQuery(tableName, insertValues, updateValues, where, model) {
      var _this4 = this;

      var targetTableAlias = this.quoteTable("".concat(tableName, "_target"));
      var sourceTableAlias = this.quoteTable("".concat(tableName, "_source"));
      var primaryKeysAttrs = [];
      var identityAttrs = [];
      var uniqueAttrs = [];
      var tableNameQuoted = this.quoteTable(tableName);

      for (var key in model.rawAttributes) {
        if (model.rawAttributes[key].primaryKey) {
          primaryKeysAttrs.push(model.rawAttributes[key].field || key);
        }

        if (model.rawAttributes[key].unique) {
          uniqueAttrs.push(model.rawAttributes[key].field || key);
        }

        if (model.rawAttributes[key].autoIncrement) {
          identityAttrs.push(model.rawAttributes[key].field || key);
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = model._indexes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var index = _step2.value;

          if (index.unique && index.fields) {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = index.fields[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var field = _step3.value;
                var fieldName = typeof field === "string" ? field : field.name || field.attribute;

                if (uniqueAttrs.indexOf(fieldName) === -1 && model.rawAttributes[fieldName]) {
                  uniqueAttrs.push(fieldName);
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                  _iterator3["return"]();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var updateKeys = Object.keys(updateValues);
      var insertKeys = Object.keys(insertValues);
      var insertKeysQuoted = insertKeys.map(function (key) {
        return _this4.quoteIdentifier(key);
      }).join(", ");
      var insertValuesEscaped = insertKeys.map(function (key) {
        return _this4.escape(insertValues[key]);
      }).join(", ");
      var sourceTableQuery = "VALUES(".concat(insertValuesEscaped, ")");
      var joinCondition;
      var clauses = where[Op.or].filter(function (clause) {
        var valid = true;

        for (var _key in clause) {
          if (!clause[_key]) {
            valid = false;
            break;
          }
        }

        return valid;
      });

      var getJoinSnippet = function getJoinSnippet(array) {
        return array.map(function (key) {
          key = _this4.quoteIdentifier(key);
          return "".concat(targetTableAlias, ".").concat(key, " = ").concat(sourceTableAlias, ".").concat(key);
        });
      };

      if (clauses.length === 0) {
        throw new Error("Primary Key or Unique key should be passed to upsert query");
      } else {
        for (var _key2 in clauses) {
          var keys = Object.keys(clauses[_key2]);

          if (primaryKeysAttrs.indexOf(keys[0]) !== -1) {
            joinCondition = getJoinSnippet(primaryKeysAttrs).join(" AND ");
            break;
          }
        }

        if (!joinCondition) {
          joinCondition = getJoinSnippet(uniqueAttrs).join(" AND ");
        }
      }

      var filteredUpdateClauses = updateKeys.filter(function (key) {
        if (identityAttrs.indexOf(key) === -1) {
          return true;
        }

        return false;
      }).map(function (key) {
        var value = _this4.escape(updateValues[key]);

        key = _this4.quoteIdentifier(key);
        return "".concat(targetTableAlias, ".").concat(key, " = ").concat(value);
      }).join(", ");
      var updateSnippet = filteredUpdateClauses.length > 0 ? "WHEN MATCHED THEN UPDATE SET ".concat(filteredUpdateClauses) : "";
      var insertSnippet = "(".concat(insertKeysQuoted, ") VALUES(").concat(insertValuesEscaped, ")");
      var query = "MERGE INTO ".concat(tableNameQuoted, " AS ").concat(targetTableAlias, " USING (").concat(sourceTableQuery, ") AS ").concat(sourceTableAlias, "(").concat(insertKeysQuoted, ") ON ").concat(joinCondition);
      query += " ".concat(updateSnippet, " WHEN NOT MATCHED THEN INSERT ").concat(insertSnippet, ";");
      return query;
    }
  }, {
    key: "truncateTableQuery",
    value: function truncateTableQuery(tableName) {
      return "TRUNCATE TABLE ".concat(this.quoteTable(tableName), " IMMEDIATE");
    }
  }, {
    key: "deleteQuery",
    value: function deleteQuery(tableName, where) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var model = arguments.length > 3 ? arguments[3] : undefined;
      var table = this.quoteTable(tableName);
      var query = "DELETE FROM <%= table %><%= where %><%= limit %>";
      where = this.getWhereConditions(where, null, model, options);
      var limit = "";

      if (options.offset > 0) {
        limit = " OFFSET ".concat(this.escape(options.offset), " ROWS");
      }

      if (options.limit) {
        limit += " FETCH NEXT ".concat(this.escape(options.limit), " ROWS ONLY");
      }

      var replacements = {
        limit: limit,
        table: table,
        where: where
      };

      if (replacements.where) {
        replacements.where = " WHERE ".concat(replacements.where);
      }

      return _.template(query, this._templateSettings)(replacements);
    }
  }, {
    key: "showIndexesQuery",
    value: function showIndexesQuery(tableName) {
      var sql = 'SELECT NAME AS "name", TBNAME AS "tableName", UNIQUERULE AS "keyType", COLNAMES, INDEXTYPE AS "type" FROM SYSIBM.SYSINDEXES WHERE TBNAME = <%= tableName %>';
      var schema = void 0;

      if (_.isObject(tableName)) {
        schema = tableName.schema;
        tableName = tableName.tableName;
      }

      if (schema) {
        sql = "".concat(sql, " AND TBCREATOR = <%= schemaName %>");
      }

      sql = "".concat(sql, " ORDER BY NAME;");
      return _.template(sql, this._templateSettings)({
        tableName: wrapSingleQuote(tableName),
        schemaName: wrapSingleQuote(schema)
      });
    }
  }, {
    key: "showConstraintsQuery",
    value: function showConstraintsQuery(tableName, constraintName) {
      var sql = "SELECT CONSTNAME AS \"constraintName\", TRIM(TABSCHEMA) AS \"schemaName\", TABNAME AS \"tableName\" FROM SYSCAT.TABCONST WHERE TABNAME = '".concat(tableName, "'");

      if (constraintName) {
        sql += " AND CONSTNAME LIKE '%".concat(constraintName, "%'");
      }

      return "".concat(sql, " ORDER BY CONSTNAME;");
    }
  }, {
    key: "removeIndexQuery",
    value: function removeIndexQuery(tableName, indexNameOrAttributes) {
      var sql = "DROP INDEX <%= indexName %>";
      var indexName = indexNameOrAttributes;

      if (typeof indexName !== "string") {
        indexName = Utils.underscore("".concat(tableName, "_").concat(indexNameOrAttributes.join("_")));
      }

      var values = {
        tableName: this.quoteIdentifiers(tableName),
        indexName: this.quoteIdentifiers(indexName)
      };
      return _.template(sql, this._templateSettings)(values);
    }
  }, {
    key: "attributeToSQL",
    value: function attributeToSQL(attribute, options) {
      var _this5 = this;

      if (!_.isPlainObject(attribute)) {
        attribute = {
          type: attribute
        };
      }

      var template;
      var changeNull = 1;

      if (attribute.type instanceof DataTypes.ENUM) {
        if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;
        template = attribute.type.toSql();
        template += " CHECK (".concat(this.quoteIdentifier(attribute.field), " IN(").concat(attribute.values.map(function (value) {
          return _this5.escape(value);
        }).join(", "), "))");
      } else {
        template = attribute.type.toString();
      }

      if (options && options.context === "changeColumn" && attribute.type) {
        template = "DATA TYPE ".concat(template);
      } else if (attribute.allowNull === false || attribute.primaryKey === true || attribute.unique) {
        template += " NOT NULL";
        changeNull = 0;
      }

      if (attribute.autoIncrement) {
        var initialValue = 1;

        if (attribute.initialAutoIncrement) {
          initialValue = attribute.initialAutoIncrement;
        }

        template += " GENERATED BY DEFAULT AS IDENTITY(START WITH ".concat(initialValue, ", INCREMENT BY 1)");
      }

      if (attribute.type !== "TEXT" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {
        template += " DEFAULT ".concat(this.escape(attribute.defaultValue));
      }

      if (attribute.unique === true) {
        template += " UNIQUE";
      }

      if (attribute.primaryKey) {
        template += " PRIMARY KEY";
      }

      if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {
        if (options && options.context === "addColumn" && options.foreignKey) {
          var attrName = this.quoteIdentifier(options.foreignKey);
          var fkName = "".concat(options.tableName, "_").concat(attrName, "_fidx");
          template += ", CONSTRAINT ".concat(fkName, " FOREIGN KEY (").concat(attrName, ")");
        }

        template += " REFERENCES ".concat(this.quoteTable(attribute.references.model));

        if (attribute.references.key) {
          template += " (".concat(this.quoteIdentifier(attribute.references.key), ")");
        } else {
          template += " (".concat(this.quoteIdentifier("id"), ")");
        }

        if (attribute.onDelete) {
          template += " ON DELETE ".concat(attribute.onDelete.toUpperCase());
        }

        if (attribute.onUpdate && attribute.onUpdate.toUpperCase() != "CASCADE") {
          template += " ON UPDATE ".concat(attribute.onUpdate.toUpperCase());
        }
      }

      if (options && options.context === "changeColumn" && changeNull === 1 && attribute.allowNull !== void 0) {
        template = [template];

        if (attribute.allowNull) {
          template.push("DROP NOT NULL");
        } else {
          template.push("NOT NULL");
        }
      }

      if (attribute.comment && typeof attribute.comment === "string") {
        template += " COMMENT ".concat(attribute.comment);
      }

      return template;
    }
  }, {
    key: "attributesToSQL",
    value: function attributesToSQL(attributes, options) {
      var result = {},
          existingConstraints = [];
      var key, attribute;

      for (key in attributes) {
        attribute = attributes[key];

        if (attribute.references) {
          if (existingConstraints.indexOf(attribute.references.model.toString()) !== -1) {
            attribute.onDelete = "";
            attribute.onUpdate = "";
          } else if (attribute.unique && attribute.unique === true) {
            attribute.onDelete = "";
            attribute.onUpdate = "";
          } else {
            existingConstraints.push(attribute.references.model.toString());
          }
        }

        if (key && !attribute.field && _typeof(attribute) === "object") attribute.field = key;
        result[attribute.field || key] = this.attributeToSQL(attribute, options);
      }

      return result;
    }
  }, {
    key: "createTrigger",
    value: function createTrigger() {
      throwMethodUndefined("createTrigger");
    }
  }, {
    key: "dropTrigger",
    value: function dropTrigger() {
      throwMethodUndefined("dropTrigger");
    }
  }, {
    key: "renameTrigger",
    value: function renameTrigger() {
      throwMethodUndefined("renameTrigger");
    }
  }, {
    key: "createFunction",
    value: function createFunction() {
      throwMethodUndefined("createFunction");
    }
  }, {
    key: "dropFunction",
    value: function dropFunction() {
      throwMethodUndefined("dropFunction");
    }
  }, {
    key: "renameFunction",
    value: function renameFunction() {
      throwMethodUndefined("renameFunction");
    }
  }, {
    key: "_getForeignKeysQuerySQL",
    value: function _getForeignKeysQuerySQL(condition) {
      return "SELECT R.CONSTNAME AS \"constraintName\", TRIM(R.TABSCHEMA) AS \"constraintSchema\", R.TABNAME AS \"tableName\", TRIM(R.TABSCHEMA) AS \"tableSchema\", LISTAGG(C.COLNAME,', ') WITHIN GROUP (ORDER BY C.COLNAME) AS \"columnName\", TRIM(R.REFTABSCHEMA) AS \"referencedTableSchema\", R.REFTABNAME AS \"referencedTableName\", TRIM(R.PK_COLNAMES) AS \"referencedColumnName\" FROM SYSCAT.REFERENCES R, SYSCAT.KEYCOLUSE C WHERE R.CONSTNAME = C.CONSTNAME AND R.TABSCHEMA = C.TABSCHEMA AND R.TABNAME = C.TABNAME".concat(condition, " GROUP BY R.REFTABSCHEMA, R.REFTABNAME, R.TABSCHEMA, R.TABNAME, R.CONSTNAME, R.PK_COLNAMES");
    }
  }, {
    key: "getForeignKeysQuery",
    value: function getForeignKeysQuery(table, schemaName) {
      var tableName = table.tableName || table;
      schemaName = table.schema || schemaName;
      var sql = "";

      if (tableName) {
        sql = " AND R.TABNAME = ".concat(wrapSingleQuote(tableName));
      }

      if (schemaName) {
        sql += " AND R.TABSCHEMA = ".concat(wrapSingleQuote(schemaName));
      }

      return this._getForeignKeysQuerySQL(sql);
    }
  }, {
    key: "getForeignKeyQuery",
    value: function getForeignKeyQuery(table, columnName) {
      var tableName = table.tableName || table;
      var schemaName = table.schema;
      var sql = "";

      if (tableName) {
        sql = " AND R.TABNAME = ".concat(wrapSingleQuote(tableName));
      }

      if (schemaName) {
        sql += " AND R.TABSCHEMA = ".concat(wrapSingleQuote(schemaName));
      }

      if (columnName) {
        sql += " AND C.COLNAME = ".concat(wrapSingleQuote(columnName));
      }

      return this._getForeignKeysQuerySQL(sql);
    }
  }, {
    key: "getPrimaryKeyConstraintQuery",
    value: function getPrimaryKeyConstraintQuery(table, attributeName) {
      var tableName = wrapSingleQuote(table.tableName || table);
      return ['SELECT TABNAME AS "tableName",', 'COLNAME AS "columnName",', 'CONSTNAME AS "constraintName"', "FROM SYSCAT.KEYCOLUSE WHERE CONSTNAME LIKE 'PK_%'", "AND COLNAME = ".concat(wrapSingleQuote(attributeName)), "AND TABNAME = ".concat(tableName, ";")].join(" ");
    }
  }, {
    key: "dropForeignKeyQuery",
    value: function dropForeignKeyQuery(tableName, foreignKey) {
      return _.template("ALTER TABLE <%= table %> DROP <%= key %>", this._templateSettings)({
        table: this.quoteTable(tableName),
        key: this.quoteIdentifier(foreignKey)
      });
    }
  }, {
    key: "dropConstraintQuery",
    value: function dropConstraintQuery(tableName, constraintName) {
      var sql = "ALTER TABLE <%= table %> DROP CONSTRAINT <%= constraint %>;";
      return _.template(sql, this._templateSettings)({
        table: this.quoteTable(tableName),
        constraint: this.quoteIdentifier(constraintName)
      });
    }
  }, {
    key: "setAutocommitQuery",
    value: function setAutocommitQuery() {
      return "";
    }
  }, {
    key: "setIsolationLevelQuery",
    value: function setIsolationLevelQuery() {}
  }, {
    key: "generateTransactionId",
    value: function generateTransactionId() {
      return randomBytes(10).toString("hex");
    }
  }, {
    key: "startTransactionQuery",
    value: function startTransactionQuery(transaction) {
      if (transaction.parent) {
        return "SAVE TRANSACTION ".concat(this.quoteIdentifier(transaction.name), ";");
      }

      return "BEGIN TRANSACTION;";
    }
  }, {
    key: "commitTransactionQuery",
    value: function commitTransactionQuery(transaction) {
      if (transaction.parent) {
        return;
      }

      return "COMMIT TRANSACTION;";
    }
  }, {
    key: "rollbackTransactionQuery",
    value: function rollbackTransactionQuery(transaction) {
      if (transaction.parent) {
        return "ROLLBACK TRANSACTION ".concat(this.quoteIdentifier(transaction.name), ";");
      }

      return "ROLLBACK TRANSACTION;";
    }
  }, {
    key: "addLimitAndOffset",
    value: function addLimitAndOffset(options) {
      var offset = options.offset || 0;
      var fragment = "";

      if (offset > 0) {
        fragment += " OFFSET ".concat(this.escape(offset), " ROWS");
      }

      if (options.limit) {
        fragment += " FETCH NEXT ".concat(this.escape(options.limit), " ROWS ONLY");
      }

      return fragment;
    }
  }, {
    key: "booleanValue",
    value: function booleanValue(value) {
      return value ? 1 : 0;
    }
  }, {
    key: "addUniqueFields",
    value: function addUniqueFields(dataValues, rawAttributes, uniqno) {
      uniqno = uniqno === void 0 ? 1 : uniqno;

      for (var key in rawAttributes) {
        if (rawAttributes[key].unique && dataValues[key] === void 0) {
          if (rawAttributes[key].type instanceof DataTypes.DATE) {
            dataValues[key] = Utils.now("db2");
          } else if (rawAttributes[key].type instanceof DataTypes.STRING) {
            dataValues[key] = "unique".concat(uniqno++);
          } else if (rawAttributes[key].type instanceof DataTypes.INTEGER) {
            dataValues[key] = uniqno++;
          } else if (rawAttributes[key].type instanceof DataTypes.BOOLEAN) {
            dataValues[key] = new DataTypes.BOOLEAN(false);
          }
        }
      }

      return uniqno;
    }
  }, {
    key: "quoteIdentifier",
    value: function quoteIdentifier(identifier, force) {
      return Utils.addTicks(Utils.removeTicks(identifier, '"'), '"');
    }
  }]);

  return Db2QueryGenerator;
}(AbstractQueryGenerator);

function wrapSingleQuote(identifier) {
  if (identifier) {
    return "'".concat(identifier, "'");
  }

  return "";
}

module.exports = Db2QueryGenerator;