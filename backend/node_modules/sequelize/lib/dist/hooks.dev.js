"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _ = require("lodash");

var _require = require("./utils/logger"),
    logger = _require.logger;

var debug = logger.debugContext("hooks");
var hookTypes = {
  beforeValidate: {
    params: 2
  },
  afterValidate: {
    params: 2
  },
  validationFailed: {
    params: 3
  },
  beforeCreate: {
    params: 2
  },
  afterCreate: {
    params: 2
  },
  beforeDestroy: {
    params: 2
  },
  afterDestroy: {
    params: 2
  },
  beforeRestore: {
    params: 2
  },
  afterRestore: {
    params: 2
  },
  beforeUpdate: {
    params: 2
  },
  afterUpdate: {
    params: 2
  },
  beforeSave: {
    params: 2,
    proxies: ["beforeUpdate", "beforeCreate"]
  },
  afterSave: {
    params: 2,
    proxies: ["afterUpdate", "afterCreate"]
  },
  beforeUpsert: {
    params: 2
  },
  afterUpsert: {
    params: 2
  },
  beforeBulkCreate: {
    params: 2
  },
  afterBulkCreate: {
    params: 2
  },
  beforeBulkDestroy: {
    params: 1
  },
  afterBulkDestroy: {
    params: 1
  },
  beforeBulkRestore: {
    params: 1
  },
  afterBulkRestore: {
    params: 1
  },
  beforeBulkUpdate: {
    params: 1
  },
  afterBulkUpdate: {
    params: 1
  },
  beforeFind: {
    params: 1
  },
  beforeFindAfterExpandIncludeAll: {
    params: 1
  },
  beforeFindAfterOptions: {
    params: 1
  },
  afterFind: {
    params: 2
  },
  beforeCount: {
    params: 1
  },
  beforeDefine: {
    params: 2,
    sync: true,
    noModel: true
  },
  afterDefine: {
    params: 1,
    sync: true,
    noModel: true
  },
  beforeInit: {
    params: 2,
    sync: true,
    noModel: true
  },
  afterInit: {
    params: 1,
    sync: true,
    noModel: true
  },
  beforeAssociate: {
    params: 2,
    sync: true
  },
  afterAssociate: {
    params: 2,
    sync: true
  },
  beforeConnect: {
    params: 1,
    noModel: true
  },
  afterConnect: {
    params: 2,
    noModel: true
  },
  beforeDisconnect: {
    params: 1,
    noModel: true
  },
  afterDisconnect: {
    params: 1,
    noModel: true
  },
  beforePoolAcquire: {
    params: 1,
    noModel: true
  },
  afterPoolAcquire: {
    params: 2,
    noModel: true
  },
  beforeSync: {
    params: 1
  },
  afterSync: {
    params: 1
  },
  beforeBulkSync: {
    params: 1
  },
  afterBulkSync: {
    params: 1
  },
  beforeQuery: {
    params: 2
  },
  afterQuery: {
    params: 2
  }
};
exports.hooks = hookTypes;

var getProxiedHooks = function getProxiedHooks(hookType) {
  return hookTypes[hookType].proxies ? hookTypes[hookType].proxies.concat(hookType) : [hookType];
};

function getHooks(hooked, hookType) {
  return (hooked.options.hooks || {})[hookType] || [];
}

var Hooks = {
  _setupHooks: function _setupHooks(hooks) {
    var _this = this;

    this.options.hooks = {};

    _.map(hooks || {}, function (hooksArray, hookName) {
      if (!Array.isArray(hooksArray)) hooksArray = [hooksArray];
      hooksArray.forEach(function (hookFn) {
        return _this.addHook(hookName, hookFn);
      });
    });
  },
  runHooks: function runHooks(hooks) {
    var hookType,
        _len,
        hookArgs,
        _key,
        _iteratorNormalCompletion,
        _didIteratorError,
        _iteratorError,
        _iterator,
        _step,
        hook,
        _iteratorNormalCompletion2,
        _didIteratorError2,
        _iteratorError2,
        _iterator2,
        _step2,
        _hook,
        _args = arguments;

    return regeneratorRuntime.async(function runHooks$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (hooks) {
              _context.next = 2;
              break;
            }

            throw new Error("runHooks requires at least 1 argument");

          case 2:
            if (typeof hooks === "string") {
              hookType = hooks;
              hooks = getHooks(this, hookType);

              if (this.sequelize) {
                hooks = hooks.concat(getHooks(this.sequelize, hookType));
              }
            }

            if (!Array.isArray(hooks)) {
              hooks = [hooks];
            }

            for (_len = _args.length, hookArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              hookArgs[_key - 1] = _args[_key];
            }

            if (!(hookTypes[hookType] && hookTypes[hookType].sync)) {
              _context.next = 26;
              break;
            }

            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context.prev = 9;

            for (_iterator = hooks[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              hook = _step.value;

              if (_typeof(hook) === "object") {
                hook = hook.fn;
              }

              debug("running hook(sync) ".concat(hookType));
              hook.apply(this, hookArgs);
            }

            _context.next = 17;
            break;

          case 13:
            _context.prev = 13;
            _context.t0 = _context["catch"](9);
            _didIteratorError = true;
            _iteratorError = _context.t0;

          case 17:
            _context.prev = 17;
            _context.prev = 18;

            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }

          case 20:
            _context.prev = 20;

            if (!_didIteratorError) {
              _context.next = 23;
              break;
            }

            throw _iteratorError;

          case 23:
            return _context.finish(20);

          case 24:
            return _context.finish(17);

          case 25:
            return _context.abrupt("return");

          case 26:
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _iteratorError2 = undefined;
            _context.prev = 29;
            _iterator2 = hooks[Symbol.iterator]();

          case 31:
            if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
              _context.next = 40;
              break;
            }

            _hook = _step2.value;

            if (_typeof(_hook) === "object") {
              _hook = _hook.fn;
            }

            debug("running hook ".concat(hookType));
            _context.next = 37;
            return regeneratorRuntime.awrap(_hook.apply(this, hookArgs));

          case 37:
            _iteratorNormalCompletion2 = true;
            _context.next = 31;
            break;

          case 40:
            _context.next = 46;
            break;

          case 42:
            _context.prev = 42;
            _context.t1 = _context["catch"](29);
            _didIteratorError2 = true;
            _iteratorError2 = _context.t1;

          case 46:
            _context.prev = 46;
            _context.prev = 47;

            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }

          case 49:
            _context.prev = 49;

            if (!_didIteratorError2) {
              _context.next = 52;
              break;
            }

            throw _iteratorError2;

          case 52:
            return _context.finish(49);

          case 53:
            return _context.finish(46);

          case 54:
          case "end":
            return _context.stop();
        }
      }
    }, null, this, [[9, 13, 17, 25], [18,, 20, 24], [29, 42, 46, 54], [47,, 49, 53]]);
  },
  addHook: function addHook(hookType, name, fn) {
    var _this2 = this;

    if (typeof name === "function") {
      fn = name;
      name = null;
    }

    debug("adding hook ".concat(hookType));
    hookType = getProxiedHooks(hookType);
    hookType.forEach(function (type) {
      var hooks = getHooks(_this2, type);
      hooks.push(name ? {
        name: name,
        fn: fn
      } : fn);
      _this2.options.hooks[type] = hooks;
    });
    return this;
  },
  removeHook: function removeHook(hookType, name) {
    var isReference = typeof name === "function" ? true : false;

    if (!this.hasHook(hookType)) {
      return this;
    }

    debug("removing hook ".concat(hookType));
    hookType = getProxiedHooks(hookType);
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = hookType[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var type = _step3.value;
        this.options.hooks[type] = this.options.hooks[type].filter(function (hook) {
          if (isReference && typeof hook === "function") {
            return hook !== name;
          }

          if (!isReference && _typeof(hook) === "object") {
            return hook.name !== name;
          }

          return true;
        });
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return this;
  },
  hasHook: function hasHook(hookType) {
    return this.options.hooks[hookType] && !!this.options.hooks[hookType].length;
  }
};
Hooks.hasHooks = Hooks.hasHook;

function applyTo(target) {
  var isModel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  _.mixin(target, Hooks);

  var _loop = function _loop() {
    var hook = _Object$keys[_i];

    if (isModel && hookTypes[hook].noModel) {
      return "continue";
    }

    target[hook] = function (name, callback) {
      return this.addHook(hook, name, callback);
    };
  };

  for (var _i = 0, _Object$keys = Object.keys(hookTypes); _i < _Object$keys.length; _i++) {
    var _ret = _loop();

    if (_ret === "continue") continue;
  }
}

exports.applyTo = applyTo;