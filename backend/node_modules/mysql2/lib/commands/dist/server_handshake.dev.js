'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var CommandCode = require('../constants/commands.js');

var Errors = require('../constants/errors.js');

var Command = require('./command.js');

var Packets = require('../packets/index.js');

var ServerHandshake =
/*#__PURE__*/
function (_Command) {
  _inherits(ServerHandshake, _Command);

  function ServerHandshake(args) {
    var _this;

    _classCallCheck(this, ServerHandshake);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ServerHandshake).call(this));
    _this.args = args;
    /*
    this.protocolVersion = args.protocolVersion || 10;
    this.serverVersion   = args.serverVersion;
    this.connectionId    = args.connectionId,
    this.statusFlags     = args.statusFlags,
    this.characterSet    = args.characterSet,
    this.capabilityFlags = args.capabilityFlags || 512;
    */

    return _this;
  }

  _createClass(ServerHandshake, [{
    key: "start",
    value: function start(packet, connection) {
      var serverHelloPacket = new Packets.Handshake(this.args);
      this.serverHello = serverHelloPacket;
      serverHelloPacket.setScrambleData(function (err) {
        if (err) {
          connection.emit('error', new Error('Error generating random bytes'));
          return;
        }

        connection.writePacket(serverHelloPacket.toPacket(0));
      });
      return ServerHandshake.prototype.readClientReply;
    }
  }, {
    key: "readClientReply",
    value: function readClientReply(packet, connection) {
      // check auth here
      var clientHelloReply = Packets.HandshakeResponse.fromPacket(packet); // TODO check we don't have something similar already

      connection.clientHelloReply = clientHelloReply;

      if (this.args.authCallback) {
        this.args.authCallback({
          user: clientHelloReply.user,
          database: clientHelloReply.database,
          address: connection.stream.remoteAddress,
          authPluginData1: this.serverHello.authPluginData1,
          authPluginData2: this.serverHello.authPluginData2,
          authToken: clientHelloReply.authToken
        }, function (err, mysqlError) {
          // if (err)
          if (!mysqlError) {
            connection.writeOk();
          } else {
            // TODO create constants / errorToCode
            // 1045 = ER_ACCESS_DENIED_ERROR
            connection.writeError({
              message: mysqlError.message || '',
              code: mysqlError.code || 1045
            });
            connection.close();
          }
        });
      } else {
        connection.writeOk();
      }

      return ServerHandshake.prototype.dispatchCommands;
    }
  }, {
    key: "_isStatement",
    value: function _isStatement(query, name) {
      var firstWord = query.split(' ')[0].toUpperCase();
      return firstWord === name;
    }
  }, {
    key: "dispatchCommands",
    value: function dispatchCommands(packet, connection) {
      // command from client to server
      var knownCommand = true;
      var encoding = connection.clientHelloReply.encoding;
      var commandCode = packet.readInt8();

      switch (commandCode) {
        case CommandCode.STMT_PREPARE:
          if (connection.listeners('stmt_prepare').length) {
            var query = packet.readString(undefined, encoding);
            connection.emit('stmt_prepare', query);
          } else {
            connection.writeError({
              code: Errors.HA_ERR_INTERNAL_ERROR,
              message: 'No query handler for prepared statements.'
            });
          }

          break;

        case CommandCode.STMT_EXECUTE:
          if (connection.listeners('stmt_execute').length) {
            var _Packets$Execute$from = Packets.Execute.fromPacket(packet, encoding),
                stmtId = _Packets$Execute$from.stmtId,
                flags = _Packets$Execute$from.flags,
                iterationCount = _Packets$Execute$from.iterationCount,
                values = _Packets$Execute$from.values;

            connection.emit('stmt_execute', stmtId, flags, iterationCount, values);
          } else {
            connection.writeError({
              code: Errors.HA_ERR_INTERNAL_ERROR,
              message: 'No query handler for execute statements.'
            });
          }

          break;

        case CommandCode.QUIT:
          if (connection.listeners('quit').length) {
            connection.emit('quit');
          } else {
            connection.stream.end();
          }

          break;

        case CommandCode.INIT_DB:
          if (connection.listeners('init_db').length) {
            var schemaName = packet.readString(undefined, encoding);
            connection.emit('init_db', schemaName);
          } else {
            connection.writeOk();
          }

          break;

        case CommandCode.QUERY:
          if (connection.listeners('query').length) {
            var _query = packet.readString(undefined, encoding);

            if (this._isStatement(_query, 'PREPARE') || this._isStatement(_query, 'SET')) {
              connection.emit('stmt_prepare', _query);
            } else if (this._isStatement(_query, 'EXECUTE')) {
              connection.emit('stmt_execute', null, null, null, null, _query);
            } else connection.emit('query', _query);
          } else {
            connection.writeError({
              code: Errors.HA_ERR_INTERNAL_ERROR,
              message: 'No query handler'
            });
          }

          break;

        case CommandCode.FIELD_LIST:
          if (connection.listeners('field_list').length) {
            var table = packet.readNullTerminatedString(encoding);
            var fields = packet.readString(undefined, encoding);
            connection.emit('field_list', table, fields);
          } else {
            connection.writeError({
              code: Errors.ER_WARN_DEPRECATED_SYNTAX,
              message: 'As of MySQL 5.7.11, COM_FIELD_LIST is deprecated and will be removed in a future version of MySQL.'
            });
          }

          break;

        case CommandCode.PING:
          if (connection.listeners('ping').length) {
            connection.emit('ping');
          } else {
            connection.writeOk();
          }

          break;

        default:
          knownCommand = false;
      }

      if (connection.listeners('packet').length) {
        connection.emit('packet', packet.clone(), knownCommand, commandCode);
      } else if (!knownCommand) {
        // eslint-disable-next-line no-console
        console.log('Unknown command:', commandCode);
      }

      return ServerHandshake.prototype.dispatchCommands;
    }
  }]);

  return ServerHandshake;
}(Command);

module.exports = ServerHandshake; // TODO: implement server-side 4.1 authentication

/*
4.1 authentication: (http://bazaar.launchpad.net/~mysql/mysql-server/5.5/view/head:/sql/password.c)

  SERVER:  public_seed=create_random_string()
           send(public_seed)

  CLIENT:  recv(public_seed)
           hash_stage1=sha1("password")
           hash_stage2=sha1(hash_stage1)
           reply=xor(hash_stage1, sha1(public_seed,hash_stage2)

           // this three steps are done in scramble()

           send(reply)


  SERVER:  recv(reply)
           hash_stage1=xor(reply, sha1(public_seed,hash_stage2))
           candidate_hash2=sha1(hash_stage1)
           check(candidate_hash2==hash_stage2)

server stores sha1(sha1(password)) ( hash_stag2)
*/