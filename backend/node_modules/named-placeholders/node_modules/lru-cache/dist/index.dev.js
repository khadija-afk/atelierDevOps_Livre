"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var perf = (typeof performance === "undefined" ? "undefined" : _typeof(performance)) === 'object' && performance && typeof performance.now === 'function' ? performance : Date;
var hasAbortController = typeof AbortController === 'function'; // minimal backwards-compatibility polyfill
// this doesn't have nearly all the checks and whatnot that
// actual AbortController/Signal has, but it's enough for
// our purposes, and if used properly, behaves the same.

var AC = hasAbortController ? AbortController :
/*#__PURE__*/
function () {
  function AbortController() {
    _classCallCheck(this, AbortController);

    this.signal = new AS();
  }

  _createClass(AbortController, [{
    key: "abort",
    value: function abort() {
      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Error('This operation was aborted');
      this.signal.reason = this.signal.reason || reason;
      this.signal.aborted = true;
      this.signal.dispatchEvent({
        type: 'abort',
        target: this.signal
      });
    }
  }]);

  return AbortController;
}();
var hasAbortSignal = typeof AbortSignal === 'function'; // Some polyfills put this on the AC class, not global

var hasACAbortSignal = typeof AC.AbortSignal === 'function';
var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController :
/*#__PURE__*/
function () {
  function AbortSignal() {
    _classCallCheck(this, AbortSignal);

    this.reason = undefined;
    this.aborted = false;
    this._listeners = [];
  }

  _createClass(AbortSignal, [{
    key: "dispatchEvent",
    value: function dispatchEvent(e) {
      if (e.type === 'abort') {
        this.aborted = true;
        this.onabort(e);

        this._listeners.forEach(function (f) {
          return f(e);
        }, this);
      }
    }
  }, {
    key: "onabort",
    value: function onabort() {}
  }, {
    key: "addEventListener",
    value: function addEventListener(ev, fn) {
      if (ev === 'abort') {
        this._listeners.push(fn);
      }
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(ev, fn) {
      if (ev === 'abort') {
        this._listeners = this._listeners.filter(function (f) {
          return f !== fn;
        });
      }
    }
  }]);

  return AbortSignal;
}();
var warned = new Set();

var deprecatedOption = function deprecatedOption(opt, instead) {
  var code = "LRU_CACHE_OPTION_".concat(opt);

  if (shouldWarn(code)) {
    warn(code, "".concat(opt, " option"), "options.".concat(instead), LRUCache);
  }
};

var deprecatedMethod = function deprecatedMethod(method, instead) {
  var code = "LRU_CACHE_METHOD_".concat(method);

  if (shouldWarn(code)) {
    var prototype = LRUCache.prototype;

    var _Object$getOwnPropert = Object.getOwnPropertyDescriptor(prototype, method),
        get = _Object$getOwnPropert.get;

    warn(code, "".concat(method, " method"), "cache.".concat(instead, "()"), get);
  }
};

var deprecatedProperty = function deprecatedProperty(field, instead) {
  var code = "LRU_CACHE_PROPERTY_".concat(field);

  if (shouldWarn(code)) {
    var prototype = LRUCache.prototype;

    var _Object$getOwnPropert2 = Object.getOwnPropertyDescriptor(prototype, field),
        get = _Object$getOwnPropert2.get;

    warn(code, "".concat(field, " property"), "cache.".concat(instead), get);
  }
};

var emitWarning = function emitWarning() {
  var _process, _console;

  (typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process && typeof process.emitWarning === 'function' ? (_process = process).emitWarning.apply(_process, arguments) : (_console = console).error.apply(_console, arguments);
};

var shouldWarn = function shouldWarn(code) {
  return !warned.has(code);
};

var warn = function warn(code, what, instead, fn) {
  warned.add(code);
  var msg = "The ".concat(what, " is deprecated. Please use ").concat(instead, " instead.");
  emitWarning(msg, 'DeprecationWarning', code, fn);
};

var isPosInt = function isPosInt(n) {
  return n && n === Math.floor(n) && n > 0 && isFinite(n);
};
/* istanbul ignore next - This is a little bit ridiculous, tbh.
 * The maximum array length is 2^32-1 or thereabouts on most JS impls.
 * And well before that point, you're caching the entire world, I mean,
 * that's ~32GB of just integers for the next/prev links, plus whatever
 * else to hold that many keys and values.  Just filling the memory with
 * zeroes at init time is brutal when you get that big.
 * But why not be complete?
 * Maybe in the future, these limits will have expanded. */


var getUintArray = function getUintArray(max) {
  return !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
};

var ZeroArray =
/*#__PURE__*/
function (_Array) {
  _inherits(ZeroArray, _Array);

  function ZeroArray(size) {
    var _this;

    _classCallCheck(this, ZeroArray);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ZeroArray).call(this, size));

    _this.fill(0);

    return _this;
  }

  return ZeroArray;
}(_wrapNativeSuper(Array));

var Stack =
/*#__PURE__*/
function () {
  function Stack(max) {
    _classCallCheck(this, Stack);

    if (max === 0) {
      return [];
    }

    var UintArray = getUintArray(max);
    this.heap = new UintArray(max);
    this.length = 0;
  }

  _createClass(Stack, [{
    key: "push",
    value: function push(n) {
      this.heap[this.length++] = n;
    }
  }, {
    key: "pop",
    value: function pop() {
      return this.heap[--this.length];
    }
  }]);

  return Stack;
}();

var LRUCache =
/*#__PURE__*/
function () {
  function LRUCache() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, LRUCache);

    var _options$max = options.max,
        max = _options$max === void 0 ? 0 : _options$max,
        ttl = options.ttl,
        _options$ttlResolutio = options.ttlResolution,
        ttlResolution = _options$ttlResolutio === void 0 ? 1 : _options$ttlResolutio,
        ttlAutopurge = options.ttlAutopurge,
        updateAgeOnGet = options.updateAgeOnGet,
        updateAgeOnHas = options.updateAgeOnHas,
        allowStale = options.allowStale,
        dispose = options.dispose,
        disposeAfter = options.disposeAfter,
        noDisposeOnSet = options.noDisposeOnSet,
        noUpdateTTL = options.noUpdateTTL,
        _options$maxSize = options.maxSize,
        maxSize = _options$maxSize === void 0 ? 0 : _options$maxSize,
        _options$maxEntrySize = options.maxEntrySize,
        maxEntrySize = _options$maxEntrySize === void 0 ? 0 : _options$maxEntrySize,
        sizeCalculation = options.sizeCalculation,
        fetchMethod = options.fetchMethod,
        fetchContext = options.fetchContext,
        noDeleteOnFetchRejection = options.noDeleteOnFetchRejection,
        noDeleteOnStaleGet = options.noDeleteOnStaleGet,
        allowStaleOnFetchRejection = options.allowStaleOnFetchRejection,
        allowStaleOnFetchAbort = options.allowStaleOnFetchAbort,
        ignoreFetchAbort = options.ignoreFetchAbort; // deprecated options, don't trigger a warning for getting them if
    // the thing being passed in is another LRUCache we're copying.

    var _ref = options instanceof LRUCache ? {} : options,
        length = _ref.length,
        maxAge = _ref.maxAge,
        stale = _ref.stale;

    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError('max option must be a nonnegative integer');
    }

    var UintArray = max ? getUintArray(max) : Array;

    if (!UintArray) {
      throw new Error('invalid max value: ' + max);
    }

    this.max = max;
    this.maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.maxSize;
    this.sizeCalculation = sizeCalculation || length;

    if (this.sizeCalculation) {
      if (!this.maxSize && !this.maxEntrySize) {
        throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
      }

      if (typeof this.sizeCalculation !== 'function') {
        throw new TypeError('sizeCalculation set to non-function');
      }
    }

    this.fetchMethod = fetchMethod || null;

    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {
      throw new TypeError('fetchMethod must be a function if specified');
    }

    this.fetchContext = fetchContext;

    if (!this.fetchMethod && fetchContext !== undefined) {
      throw new TypeError('cannot set fetchContext without fetchMethod');
    }

    this.keyMap = new Map();
    this.keyList = new Array(max).fill(null);
    this.valList = new Array(max).fill(null);
    this.next = new UintArray(max);
    this.prev = new UintArray(max);
    this.head = 0;
    this.tail = 0;
    this.free = new Stack(max);
    this.initialFill = 1;
    this.size = 0;

    if (typeof dispose === 'function') {
      this.dispose = dispose;
    }

    if (typeof disposeAfter === 'function') {
      this.disposeAfter = disposeAfter;
      this.disposed = [];
    } else {
      this.disposeAfter = null;
      this.disposed = null;
    }

    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort; // NB: maxEntrySize is set to maxSize if it's set

    if (this.maxEntrySize !== 0) {
      if (this.maxSize !== 0) {
        if (!isPosInt(this.maxSize)) {
          throw new TypeError('maxSize must be a positive integer if specified');
        }
      }

      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError('maxEntrySize must be a positive integer if specified');
      }

      this.initializeSizeTracking();
    }

    this.allowStale = !!allowStale || !!stale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || maxAge || 0;

    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError('ttl must be a positive integer if specified');
      }

      this.initializeTTLTracking();
    } // do not allow completely unbounded caches


    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
      throw new TypeError('At least one of max, maxSize, or ttl is required');
    }

    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
      var code = 'LRU_CACHE_UNBOUNDED';

      if (shouldWarn(code)) {
        warned.add(code);
        var msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' + 'result in unbounded memory consumption.';
        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
      }
    }

    if (stale) {
      deprecatedOption('stale', 'allowStale');
    }

    if (maxAge) {
      deprecatedOption('maxAge', 'ttl');
    }

    if (length) {
      deprecatedOption('length', 'sizeCalculation');
    }
  }

  _createClass(LRUCache, [{
    key: "getRemainingTTL",
    value: function getRemainingTTL(key) {
      return this.has(key, {
        updateAgeOnHas: false
      }) ? Infinity : 0;
    }
  }, {
    key: "initializeTTLTracking",
    value: function initializeTTLTracking() {
      var _this2 = this;

      this.ttls = new ZeroArray(this.max);
      this.starts = new ZeroArray(this.max);

      this.setItemTTL = function (index, ttl) {
        var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : perf.now();
        _this2.starts[index] = ttl !== 0 ? start : 0;
        _this2.ttls[index] = ttl;

        if (ttl !== 0 && _this2.ttlAutopurge) {
          var t = setTimeout(function () {
            if (_this2.isStale(index)) {
              _this2["delete"](_this2.keyList[index]);
            }
          }, ttl + 1);
          /* istanbul ignore else - unref() not supported on all platforms */

          if (t.unref) {
            t.unref();
          }
        }
      };

      this.updateItemAge = function (index) {
        _this2.starts[index] = _this2.ttls[index] !== 0 ? perf.now() : 0;
      };

      this.statusTTL = function (status, index) {
        if (status) {
          status.ttl = _this2.ttls[index];
          status.start = _this2.starts[index];
          status.now = cachedNow || getNow();
          status.remainingTTL = status.now + status.ttl - status.start;
        }
      }; // debounce calls to perf.now() to 1s so we're not hitting
      // that costly call repeatedly.


      var cachedNow = 0;

      var getNow = function getNow() {
        var n = perf.now();

        if (_this2.ttlResolution > 0) {
          cachedNow = n;
          var t = setTimeout(function () {
            return cachedNow = 0;
          }, _this2.ttlResolution);
          /* istanbul ignore else - not available on all platforms */

          if (t.unref) {
            t.unref();
          }
        }

        return n;
      };

      this.getRemainingTTL = function (key) {
        var index = _this2.keyMap.get(key);

        if (index === undefined) {
          return 0;
        }

        return _this2.ttls[index] === 0 || _this2.starts[index] === 0 ? Infinity : _this2.starts[index] + _this2.ttls[index] - (cachedNow || getNow());
      };

      this.isStale = function (index) {
        return _this2.ttls[index] !== 0 && _this2.starts[index] !== 0 && (cachedNow || getNow()) - _this2.starts[index] > _this2.ttls[index];
      };
    }
  }, {
    key: "updateItemAge",
    value: function updateItemAge(_index) {}
  }, {
    key: "statusTTL",
    value: function statusTTL(_status, _index) {}
  }, {
    key: "setItemTTL",
    value: function setItemTTL(_index, _ttl, _start) {}
  }, {
    key: "isStale",
    value: function isStale(_index) {
      return false;
    }
  }, {
    key: "initializeSizeTracking",
    value: function initializeSizeTracking() {
      var _this3 = this;

      this.calculatedSize = 0;
      this.sizes = new ZeroArray(this.max);

      this.removeItemSize = function (index) {
        _this3.calculatedSize -= _this3.sizes[index];
        _this3.sizes[index] = 0;
      };

      this.requireSize = function (k, v, size, sizeCalculation) {
        // provisionally accept background fetches.
        // actual value size will be checked when they return.
        if (_this3.isBackgroundFetch(v)) {
          return 0;
        }

        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== 'function') {
              throw new TypeError('sizeCalculation must be a function');
            }

            size = sizeCalculation(v, k);

            if (!isPosInt(size)) {
              throw new TypeError('sizeCalculation return invalid (expect positive integer)');
            }
          } else {
            throw new TypeError('invalid size value (must be positive integer). ' + 'When maxSize or maxEntrySize is used, sizeCalculation or size ' + 'must be set.');
          }
        }

        return size;
      };

      this.addItemSize = function (index, size, status) {
        _this3.sizes[index] = size;

        if (_this3.maxSize) {
          var maxSize = _this3.maxSize - _this3.sizes[index];

          while (_this3.calculatedSize > maxSize) {
            _this3.evict(true);
          }
        }

        _this3.calculatedSize += _this3.sizes[index];

        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = _this3.calculatedSize;
        }
      };
    }
  }, {
    key: "removeItemSize",
    value: function removeItemSize(_index) {}
  }, {
    key: "addItemSize",
    value: function addItemSize(_index, _size) {}
  }, {
    key: "requireSize",
    value: function requireSize(_k, _v, size, sizeCalculation) {
      if (size || sizeCalculation) {
        throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
      }
    }
  }, {
    key: "indexes",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function indexes() {
      var _ref2,
          _ref2$allowStale,
          allowStale,
          i,
          _args = arguments;

      return regeneratorRuntime.wrap(function indexes$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _ref2 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, _ref2$allowStale = _ref2.allowStale, allowStale = _ref2$allowStale === void 0 ? this.allowStale : _ref2$allowStale;

              if (!this.size) {
                _context.next = 16;
                break;
              }

              i = this.tail;

            case 3:
              if (!true) {
                _context.next = 16;
                break;
              }

              if (this.isValidIndex(i)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("break", 16);

            case 6:
              if (!(allowStale || !this.isStale(i))) {
                _context.next = 9;
                break;
              }

              _context.next = 9;
              return i;

            case 9:
              if (!(i === this.head)) {
                _context.next = 13;
                break;
              }

              return _context.abrupt("break", 16);

            case 13:
              i = this.prev[i];

            case 14:
              _context.next = 3;
              break;

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, indexes, this);
    })
  }, {
    key: "rindexes",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function rindexes() {
      var _ref3,
          _ref3$allowStale,
          allowStale,
          i,
          _args2 = arguments;

      return regeneratorRuntime.wrap(function rindexes$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _ref3 = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, _ref3$allowStale = _ref3.allowStale, allowStale = _ref3$allowStale === void 0 ? this.allowStale : _ref3$allowStale;

              if (!this.size) {
                _context2.next = 16;
                break;
              }

              i = this.head;

            case 3:
              if (!true) {
                _context2.next = 16;
                break;
              }

              if (this.isValidIndex(i)) {
                _context2.next = 6;
                break;
              }

              return _context2.abrupt("break", 16);

            case 6:
              if (!(allowStale || !this.isStale(i))) {
                _context2.next = 9;
                break;
              }

              _context2.next = 9;
              return i;

            case 9:
              if (!(i === this.tail)) {
                _context2.next = 13;
                break;
              }

              return _context2.abrupt("break", 16);

            case 13:
              i = this.next[i];

            case 14:
              _context2.next = 3;
              break;

            case 16:
            case "end":
              return _context2.stop();
          }
        }
      }, rindexes, this);
    })
  }, {
    key: "isValidIndex",
    value: function isValidIndex(index) {
      return index !== undefined && this.keyMap.get(this.keyList[index]) === index;
    }
  }, {
    key: "entries",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function entries() {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, i;

      return regeneratorRuntime.wrap(function entries$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context3.prev = 3;
              _iterator = this.indexes()[Symbol.iterator]();

            case 5:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context3.next = 13;
                break;
              }

              i = _step.value;

              if (!(this.valList[i] !== undefined && this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i]))) {
                _context3.next = 10;
                break;
              }

              _context3.next = 10;
              return [this.keyList[i], this.valList[i]];

            case 10:
              _iteratorNormalCompletion = true;
              _context3.next = 5;
              break;

            case 13:
              _context3.next = 19;
              break;

            case 15:
              _context3.prev = 15;
              _context3.t0 = _context3["catch"](3);
              _didIteratorError = true;
              _iteratorError = _context3.t0;

            case 19:
              _context3.prev = 19;
              _context3.prev = 20;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 22:
              _context3.prev = 22;

              if (!_didIteratorError) {
                _context3.next = 25;
                break;
              }

              throw _iteratorError;

            case 25:
              return _context3.finish(22);

            case 26:
              return _context3.finish(19);

            case 27:
            case "end":
              return _context3.stop();
          }
        }
      }, entries, this, [[3, 15, 19, 27], [20,, 22, 26]]);
    })
  }, {
    key: "rentries",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function rentries() {
      var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, i;

      return regeneratorRuntime.wrap(function rentries$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context4.prev = 3;
              _iterator2 = this.rindexes()[Symbol.iterator]();

            case 5:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context4.next = 13;
                break;
              }

              i = _step2.value;

              if (!(this.valList[i] !== undefined && this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i]))) {
                _context4.next = 10;
                break;
              }

              _context4.next = 10;
              return [this.keyList[i], this.valList[i]];

            case 10:
              _iteratorNormalCompletion2 = true;
              _context4.next = 5;
              break;

            case 13:
              _context4.next = 19;
              break;

            case 15:
              _context4.prev = 15;
              _context4.t0 = _context4["catch"](3);
              _didIteratorError2 = true;
              _iteratorError2 = _context4.t0;

            case 19:
              _context4.prev = 19;
              _context4.prev = 20;

              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }

            case 22:
              _context4.prev = 22;

              if (!_didIteratorError2) {
                _context4.next = 25;
                break;
              }

              throw _iteratorError2;

            case 25:
              return _context4.finish(22);

            case 26:
              return _context4.finish(19);

            case 27:
            case "end":
              return _context4.stop();
          }
        }
      }, rentries, this, [[3, 15, 19, 27], [20,, 22, 26]]);
    })
  }, {
    key: "keys",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function keys() {
      var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, i;

      return regeneratorRuntime.wrap(function keys$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context5.prev = 3;
              _iterator3 = this.indexes()[Symbol.iterator]();

            case 5:
              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                _context5.next = 13;
                break;
              }

              i = _step3.value;

              if (!(this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i]))) {
                _context5.next = 10;
                break;
              }

              _context5.next = 10;
              return this.keyList[i];

            case 10:
              _iteratorNormalCompletion3 = true;
              _context5.next = 5;
              break;

            case 13:
              _context5.next = 19;
              break;

            case 15:
              _context5.prev = 15;
              _context5.t0 = _context5["catch"](3);
              _didIteratorError3 = true;
              _iteratorError3 = _context5.t0;

            case 19:
              _context5.prev = 19;
              _context5.prev = 20;

              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }

            case 22:
              _context5.prev = 22;

              if (!_didIteratorError3) {
                _context5.next = 25;
                break;
              }

              throw _iteratorError3;

            case 25:
              return _context5.finish(22);

            case 26:
              return _context5.finish(19);

            case 27:
            case "end":
              return _context5.stop();
          }
        }
      }, keys, this, [[3, 15, 19, 27], [20,, 22, 26]]);
    })
  }, {
    key: "rkeys",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function rkeys() {
      var _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, i;

      return regeneratorRuntime.wrap(function rkeys$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _iteratorNormalCompletion4 = true;
              _didIteratorError4 = false;
              _iteratorError4 = undefined;
              _context6.prev = 3;
              _iterator4 = this.rindexes()[Symbol.iterator]();

            case 5:
              if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
                _context6.next = 13;
                break;
              }

              i = _step4.value;

              if (!(this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i]))) {
                _context6.next = 10;
                break;
              }

              _context6.next = 10;
              return this.keyList[i];

            case 10:
              _iteratorNormalCompletion4 = true;
              _context6.next = 5;
              break;

            case 13:
              _context6.next = 19;
              break;

            case 15:
              _context6.prev = 15;
              _context6.t0 = _context6["catch"](3);
              _didIteratorError4 = true;
              _iteratorError4 = _context6.t0;

            case 19:
              _context6.prev = 19;
              _context6.prev = 20;

              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }

            case 22:
              _context6.prev = 22;

              if (!_didIteratorError4) {
                _context6.next = 25;
                break;
              }

              throw _iteratorError4;

            case 25:
              return _context6.finish(22);

            case 26:
              return _context6.finish(19);

            case 27:
            case "end":
              return _context6.stop();
          }
        }
      }, rkeys, this, [[3, 15, 19, 27], [20,, 22, 26]]);
    })
  }, {
    key: "values",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function values() {
      var _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, i;

      return regeneratorRuntime.wrap(function values$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _iteratorNormalCompletion5 = true;
              _didIteratorError5 = false;
              _iteratorError5 = undefined;
              _context7.prev = 3;
              _iterator5 = this.indexes()[Symbol.iterator]();

            case 5:
              if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
                _context7.next = 13;
                break;
              }

              i = _step5.value;

              if (!(this.valList[i] !== undefined && !this.isBackgroundFetch(this.valList[i]))) {
                _context7.next = 10;
                break;
              }

              _context7.next = 10;
              return this.valList[i];

            case 10:
              _iteratorNormalCompletion5 = true;
              _context7.next = 5;
              break;

            case 13:
              _context7.next = 19;
              break;

            case 15:
              _context7.prev = 15;
              _context7.t0 = _context7["catch"](3);
              _didIteratorError5 = true;
              _iteratorError5 = _context7.t0;

            case 19:
              _context7.prev = 19;
              _context7.prev = 20;

              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                _iterator5["return"]();
              }

            case 22:
              _context7.prev = 22;

              if (!_didIteratorError5) {
                _context7.next = 25;
                break;
              }

              throw _iteratorError5;

            case 25:
              return _context7.finish(22);

            case 26:
              return _context7.finish(19);

            case 27:
            case "end":
              return _context7.stop();
          }
        }
      }, values, this, [[3, 15, 19, 27], [20,, 22, 26]]);
    })
  }, {
    key: "rvalues",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function rvalues() {
      var _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, i;

      return regeneratorRuntime.wrap(function rvalues$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _iteratorNormalCompletion6 = true;
              _didIteratorError6 = false;
              _iteratorError6 = undefined;
              _context8.prev = 3;
              _iterator6 = this.rindexes()[Symbol.iterator]();

            case 5:
              if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
                _context8.next = 13;
                break;
              }

              i = _step6.value;

              if (!(this.valList[i] !== undefined && !this.isBackgroundFetch(this.valList[i]))) {
                _context8.next = 10;
                break;
              }

              _context8.next = 10;
              return this.valList[i];

            case 10:
              _iteratorNormalCompletion6 = true;
              _context8.next = 5;
              break;

            case 13:
              _context8.next = 19;
              break;

            case 15:
              _context8.prev = 15;
              _context8.t0 = _context8["catch"](3);
              _didIteratorError6 = true;
              _iteratorError6 = _context8.t0;

            case 19:
              _context8.prev = 19;
              _context8.prev = 20;

              if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                _iterator6["return"]();
              }

            case 22:
              _context8.prev = 22;

              if (!_didIteratorError6) {
                _context8.next = 25;
                break;
              }

              throw _iteratorError6;

            case 25:
              return _context8.finish(22);

            case 26:
              return _context8.finish(19);

            case 27:
            case "end":
              return _context8.stop();
          }
        }
      }, rvalues, this, [[3, 15, 19, 27], [20,, 22, 26]]);
    })
  }, {
    key: Symbol.iterator,
    value: function value() {
      return this.entries();
    }
  }, {
    key: "find",
    value: function find(fn, getOptions) {
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this.indexes()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var i = _step7.value;
          var v = this.valList[i];
          var value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === undefined) continue;

          if (fn(value, this.keyList[i], this)) {
            return this.get(this.keyList[i], getOptions);
          }
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
            _iterator7["return"]();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    }
  }, {
    key: "forEach",
    value: function forEach(fn) {
      var thisp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = this.indexes()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var i = _step8.value;
          var v = this.valList[i];
          var value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === undefined) continue;
          fn.call(thisp, value, this.keyList[i], this);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
  }, {
    key: "rforEach",
    value: function rforEach(fn) {
      var thisp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = this.rindexes()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var i = _step9.value;
          var v = this.valList[i];
          var value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === undefined) continue;
          fn.call(thisp, value, this.keyList[i], this);
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
            _iterator9["return"]();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }
    }
  }, {
    key: "purgeStale",
    value: function purgeStale() {
      var deleted = false;
      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = this.rindexes({
          allowStale: true
        })[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var i = _step10.value;

          if (this.isStale(i)) {
            this["delete"](this.keyList[i]);
            deleted = true;
          }
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
            _iterator10["return"]();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }

      return deleted;
    }
  }, {
    key: "dump",
    value: function dump() {
      var arr = [];
      var _iteratorNormalCompletion11 = true;
      var _didIteratorError11 = false;
      var _iteratorError11 = undefined;

      try {
        for (var _iterator11 = this.indexes({
          allowStale: true
        })[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
          var i = _step11.value;
          var key = this.keyList[i];
          var v = this.valList[i];
          var value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === undefined) continue;
          var entry = {
            value: value
          };

          if (this.ttls) {
            entry.ttl = this.ttls[i]; // always dump the start relative to a portable timestamp
            // it's ok for this to be a bit slow, it's a rare operation.

            var age = perf.now() - this.starts[i];
            entry.start = Math.floor(Date.now() - age);
          }

          if (this.sizes) {
            entry.size = this.sizes[i];
          }

          arr.unshift([key, entry]);
        }
      } catch (err) {
        _didIteratorError11 = true;
        _iteratorError11 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
            _iterator11["return"]();
          }
        } finally {
          if (_didIteratorError11) {
            throw _iteratorError11;
          }
        }
      }

      return arr;
    }
  }, {
    key: "load",
    value: function load(arr) {
      this.clear();
      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = arr[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var _step12$value = _slicedToArray(_step12.value, 2),
              key = _step12$value[0],
              entry = _step12$value[1];

          if (entry.start) {
            // entry.start is a portable timestamp, but we may be using
            // node's performance.now(), so calculate the offset.
            // it's ok for this to be a bit slow, it's a rare operation.
            var age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }

          this.set(key, entry.value, entry);
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
            _iterator12["return"]();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }
    }
  }, {
    key: "dispose",
    value: function dispose(_v, _k, _reason) {}
  }, {
    key: "set",
    value: function set(k, v) {
      var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref4$ttl = _ref4.ttl,
          ttl = _ref4$ttl === void 0 ? this.ttl : _ref4$ttl,
          start = _ref4.start,
          _ref4$noDisposeOnSet = _ref4.noDisposeOnSet,
          noDisposeOnSet = _ref4$noDisposeOnSet === void 0 ? this.noDisposeOnSet : _ref4$noDisposeOnSet,
          _ref4$size = _ref4.size,
          size = _ref4$size === void 0 ? 0 : _ref4$size,
          _ref4$sizeCalculation = _ref4.sizeCalculation,
          sizeCalculation = _ref4$sizeCalculation === void 0 ? this.sizeCalculation : _ref4$sizeCalculation,
          _ref4$noUpdateTTL = _ref4.noUpdateTTL,
          noUpdateTTL = _ref4$noUpdateTTL === void 0 ? this.noUpdateTTL : _ref4$noUpdateTTL,
          status = _ref4.status;

      size = this.requireSize(k, v, size, sizeCalculation); // if the item doesn't fit, don't do anything
      // NB: maxEntrySize set to maxSize by default

      if (this.maxEntrySize && size > this.maxEntrySize) {
        if (status) {
          status.set = 'miss';
          status.maxEntrySizeExceeded = true;
        } // have to delete, in case a background fetch is there already.
        // in non-async cases, this is a no-op


        this["delete"](k);
        return this;
      }

      var index = this.size === 0 ? undefined : this.keyMap.get(k);

      if (index === undefined) {
        // addition
        index = this.newIndex();
        this.keyList[index] = k;
        this.valList[index] = v;
        this.keyMap.set(k, index);
        this.next[this.tail] = index;
        this.prev[index] = this.tail;
        this.tail = index;
        this.size++;
        this.addItemSize(index, size, status);

        if (status) {
          status.set = 'add';
        }

        noUpdateTTL = false;
      } else {
        // update
        this.moveToTail(index);
        var oldVal = this.valList[index];

        if (v !== oldVal) {
          if (this.isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort(new Error('replaced'));
          } else {
            if (!noDisposeOnSet) {
              this.dispose(oldVal, k, 'set');

              if (this.disposeAfter) {
                this.disposed.push([oldVal, k, 'set']);
              }
            }
          }

          this.removeItemSize(index);
          this.valList[index] = v;
          this.addItemSize(index, size, status);

          if (status) {
            status.set = 'replace';
            var oldValue = oldVal && this.isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
            if (oldValue !== undefined) status.oldValue = oldValue;
          }
        } else if (status) {
          status.set = 'update';
        }
      }

      if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
        this.initializeTTLTracking();
      }

      if (!noUpdateTTL) {
        this.setItemTTL(index, ttl, start);
      }

      this.statusTTL(status, index);

      if (this.disposeAfter) {
        while (this.disposed.length) {
          this.disposeAfter.apply(this, _toConsumableArray(this.disposed.shift()));
        }
      }

      return this;
    }
  }, {
    key: "newIndex",
    value: function newIndex() {
      if (this.size === 0) {
        return this.tail;
      }

      if (this.size === this.max && this.max !== 0) {
        return this.evict(false);
      }

      if (this.free.length !== 0) {
        return this.free.pop();
      } // initial fill, just keep writing down the list


      return this.initialFill++;
    }
  }, {
    key: "pop",
    value: function pop() {
      if (this.size) {
        var val = this.valList[this.head];
        this.evict(true);
        return val;
      }
    }
  }, {
    key: "evict",
    value: function evict(free) {
      var head = this.head;
      var k = this.keyList[head];
      var v = this.valList[head];

      if (this.isBackgroundFetch(v)) {
        v.__abortController.abort(new Error('evicted'));
      } else {
        this.dispose(v, k, 'evict');

        if (this.disposeAfter) {
          this.disposed.push([v, k, 'evict']);
        }
      }

      this.removeItemSize(head); // if we aren't about to use the index, then null these out

      if (free) {
        this.keyList[head] = null;
        this.valList[head] = null;
        this.free.push(head);
      }

      this.head = this.next[head];
      this.keyMap["delete"](k);
      this.size--;
      return head;
    }
  }, {
    key: "has",
    value: function has(k) {
      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref5$updateAgeOnHas = _ref5.updateAgeOnHas,
          updateAgeOnHas = _ref5$updateAgeOnHas === void 0 ? this.updateAgeOnHas : _ref5$updateAgeOnHas,
          status = _ref5.status;

      var index = this.keyMap.get(k);

      if (index !== undefined) {
        if (!this.isStale(index)) {
          if (updateAgeOnHas) {
            this.updateItemAge(index);
          }

          if (status) status.has = 'hit';
          this.statusTTL(status, index);
          return true;
        } else if (status) {
          status.has = 'stale';
          this.statusTTL(status, index);
        }
      } else if (status) {
        status.has = 'miss';
      }

      return false;
    } // like get(), but without any LRU updating or TTL expiration

  }, {
    key: "peek",
    value: function peek(k) {
      var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref6$allowStale = _ref6.allowStale,
          allowStale = _ref6$allowStale === void 0 ? this.allowStale : _ref6$allowStale;

      var index = this.keyMap.get(k);

      if (index !== undefined && (allowStale || !this.isStale(index))) {
        var v = this.valList[index]; // either stale and allowed, or forcing a refresh of non-stale value

        return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
    }
  }, {
    key: "backgroundFetch",
    value: function backgroundFetch(k, index, options, context) {
      var _this4 = this;

      var v = index === undefined ? undefined : this.valList[index];

      if (this.isBackgroundFetch(v)) {
        return v;
      }

      var ac = new AC();

      if (options.signal) {
        options.signal.addEventListener('abort', function () {
          return ac.abort(options.signal.reason);
        });
      }

      var fetchOpts = {
        signal: ac.signal,
        options: options,
        context: context
      };

      var cb = function cb(v) {
        var updateCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var aborted = ac.signal.aborted;
        var ignoreAbort = options.ignoreFetchAbort && v !== undefined;

        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true;
            options.status.fetchError = ac.signal.reason;
            if (ignoreAbort) options.status.fetchAbortIgnored = true;
          } else {
            options.status.fetchResolved = true;
          }
        }

        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        } // either we didn't abort, and are still here, or we did, and ignored


        if (_this4.valList[index] === p) {
          if (v === undefined) {
            if (p.__staleWhileFetching) {
              _this4.valList[index] = p.__staleWhileFetching;
            } else {
              _this4["delete"](k);
            }
          } else {
            if (options.status) options.status.fetchUpdated = true;

            _this4.set(k, v, fetchOpts.options);
          }
        }

        return v;
      };

      var eb = function eb(er) {
        if (options.status) {
          options.status.fetchRejected = true;
          options.status.fetchError = er;
        }

        return fetchFail(er);
      };

      var fetchFail = function fetchFail(er) {
        var aborted = ac.signal.aborted;
        var allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
        var allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        var noDelete = allowStale || options.noDeleteOnFetchRejection;

        if (_this4.valList[index] === p) {
          // if we allow stale on fetch rejections, then we need to ensure that
          // the stale value is not removed from the cache when the fetch fails.
          var del = !noDelete || p.__staleWhileFetching === undefined;

          if (del) {
            _this4["delete"](k);
          } else if (!allowStaleAborted) {
            // still replace the *promise* with the stale value,
            // since we are done with the promise at this point.
            // leave it untouched if we're still waiting for an
            // aborted background fetch that hasn't yet returned.
            _this4.valList[index] = p.__staleWhileFetching;
          }
        }

        if (allowStale) {
          if (options.status && p.__staleWhileFetching !== undefined) {
            options.status.returnedStale = true;
          }

          return p.__staleWhileFetching;
        } else if (p.__returned === p) {
          throw er;
        }
      };

      var pcall = function pcall(res, rej) {
        _this4.fetchMethod(k, v, fetchOpts).then(function (v) {
          return res(v);
        }, rej); // ignored, we go until we finish, regardless.
        // defer check until we are actually aborting,
        // so fetchMethod can override.


        ac.signal.addEventListener('abort', function () {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res(); // when it eventually resolves, update the cache.

            if (options.allowStaleOnFetchAbort) {
              res = function res(v) {
                return cb(v, true);
              };
            }
          }
        });
      };

      if (options.status) options.status.fetchDispatched = true;
      var p = new Promise(pcall).then(cb, eb);
      p.__abortController = ac;
      p.__staleWhileFetching = v;
      p.__returned = null;

      if (index === undefined) {
        // internal, don't expose status.
        this.set(k, p, _objectSpread({}, fetchOpts.options, {
          status: undefined
        }));
        index = this.keyMap.get(k);
      } else {
        this.valList[index] = p;
      }

      return p;
    }
  }, {
    key: "isBackgroundFetch",
    value: function isBackgroundFetch(p) {
      return p && _typeof(p) === 'object' && typeof p.then === 'function' && Object.prototype.hasOwnProperty.call(p, '__staleWhileFetching') && Object.prototype.hasOwnProperty.call(p, '__returned') && (p.__returned === p || p.__returned === null);
    } // this takes the union of get() and set() opts, because it does both

  }, {
    key: "fetch",
    value: function fetch(k) {
      var _ref7,
          _ref7$allowStale,
          allowStale,
          _ref7$updateAgeOnGet,
          updateAgeOnGet,
          _ref7$noDeleteOnStale,
          noDeleteOnStaleGet,
          _ref7$ttl,
          ttl,
          _ref7$noDisposeOnSet,
          noDisposeOnSet,
          _ref7$size,
          size,
          _ref7$sizeCalculation,
          sizeCalculation,
          _ref7$noUpdateTTL,
          noUpdateTTL,
          _ref7$noDeleteOnFetch,
          noDeleteOnFetchRejection,
          _ref7$allowStaleOnFet,
          allowStaleOnFetchRejection,
          _ref7$ignoreFetchAbor,
          ignoreFetchAbort,
          _ref7$allowStaleOnFet2,
          allowStaleOnFetchAbort,
          _ref7$fetchContext,
          fetchContext,
          _ref7$forceRefresh,
          forceRefresh,
          status,
          signal,
          options,
          index,
          p,
          v,
          stale,
          isStale,
          _p,
          hasStale,
          staleVal,
          _args9 = arguments;

      return regeneratorRuntime.async(function fetch$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _ref7 = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {}, _ref7$allowStale = _ref7.allowStale, allowStale = _ref7$allowStale === void 0 ? this.allowStale : _ref7$allowStale, _ref7$updateAgeOnGet = _ref7.updateAgeOnGet, updateAgeOnGet = _ref7$updateAgeOnGet === void 0 ? this.updateAgeOnGet : _ref7$updateAgeOnGet, _ref7$noDeleteOnStale = _ref7.noDeleteOnStaleGet, noDeleteOnStaleGet = _ref7$noDeleteOnStale === void 0 ? this.noDeleteOnStaleGet : _ref7$noDeleteOnStale, _ref7$ttl = _ref7.ttl, ttl = _ref7$ttl === void 0 ? this.ttl : _ref7$ttl, _ref7$noDisposeOnSet = _ref7.noDisposeOnSet, noDisposeOnSet = _ref7$noDisposeOnSet === void 0 ? this.noDisposeOnSet : _ref7$noDisposeOnSet, _ref7$size = _ref7.size, size = _ref7$size === void 0 ? 0 : _ref7$size, _ref7$sizeCalculation = _ref7.sizeCalculation, sizeCalculation = _ref7$sizeCalculation === void 0 ? this.sizeCalculation : _ref7$sizeCalculation, _ref7$noUpdateTTL = _ref7.noUpdateTTL, noUpdateTTL = _ref7$noUpdateTTL === void 0 ? this.noUpdateTTL : _ref7$noUpdateTTL, _ref7$noDeleteOnFetch = _ref7.noDeleteOnFetchRejection, noDeleteOnFetchRejection = _ref7$noDeleteOnFetch === void 0 ? this.noDeleteOnFetchRejection : _ref7$noDeleteOnFetch, _ref7$allowStaleOnFet = _ref7.allowStaleOnFetchRejection, allowStaleOnFetchRejection = _ref7$allowStaleOnFet === void 0 ? this.allowStaleOnFetchRejection : _ref7$allowStaleOnFet, _ref7$ignoreFetchAbor = _ref7.ignoreFetchAbort, ignoreFetchAbort = _ref7$ignoreFetchAbor === void 0 ? this.ignoreFetchAbort : _ref7$ignoreFetchAbor, _ref7$allowStaleOnFet2 = _ref7.allowStaleOnFetchAbort, allowStaleOnFetchAbort = _ref7$allowStaleOnFet2 === void 0 ? this.allowStaleOnFetchAbort : _ref7$allowStaleOnFet2, _ref7$fetchContext = _ref7.fetchContext, fetchContext = _ref7$fetchContext === void 0 ? this.fetchContext : _ref7$fetchContext, _ref7$forceRefresh = _ref7.forceRefresh, forceRefresh = _ref7$forceRefresh === void 0 ? false : _ref7$forceRefresh, status = _ref7.status, signal = _ref7.signal;

              if (this.fetchMethod) {
                _context9.next = 4;
                break;
              }

              if (status) status.fetch = 'get';
              return _context9.abrupt("return", this.get(k, {
                allowStale: allowStale,
                updateAgeOnGet: updateAgeOnGet,
                noDeleteOnStaleGet: noDeleteOnStaleGet,
                status: status
              }));

            case 4:
              options = {
                allowStale: allowStale,
                updateAgeOnGet: updateAgeOnGet,
                noDeleteOnStaleGet: noDeleteOnStaleGet,
                ttl: ttl,
                noDisposeOnSet: noDisposeOnSet,
                size: size,
                sizeCalculation: sizeCalculation,
                noUpdateTTL: noUpdateTTL,
                noDeleteOnFetchRejection: noDeleteOnFetchRejection,
                allowStaleOnFetchRejection: allowStaleOnFetchRejection,
                allowStaleOnFetchAbort: allowStaleOnFetchAbort,
                ignoreFetchAbort: ignoreFetchAbort,
                status: status,
                signal: signal
              };
              index = this.keyMap.get(k);

              if (!(index === undefined)) {
                _context9.next = 12;
                break;
              }

              if (status) status.fetch = 'miss';
              p = this.backgroundFetch(k, index, options, fetchContext);
              return _context9.abrupt("return", p.__returned = p);

            case 12:
              // in cache, maybe already fetching
              v = this.valList[index];

              if (!this.isBackgroundFetch(v)) {
                _context9.next = 17;
                break;
              }

              stale = allowStale && v.__staleWhileFetching !== undefined;

              if (status) {
                status.fetch = 'inflight';
                if (stale) status.returnedStale = true;
              }

              return _context9.abrupt("return", stale ? v.__staleWhileFetching : v.__returned = v);

            case 17:
              // if we force a refresh, that means do NOT serve the cached value,
              // unless we are already in the process of refreshing the cache.
              isStale = this.isStale(index);

              if (!(!forceRefresh && !isStale)) {
                _context9.next = 24;
                break;
              }

              if (status) status.fetch = 'hit';
              this.moveToTail(index);

              if (updateAgeOnGet) {
                this.updateItemAge(index);
              }

              this.statusTTL(status, index);
              return _context9.abrupt("return", v);

            case 24:
              // ok, it is stale or a forced refresh, and not already fetching.
              // refresh the cache.
              _p = this.backgroundFetch(k, index, options, fetchContext);
              hasStale = _p.__staleWhileFetching !== undefined;
              staleVal = hasStale && allowStale;

              if (status) {
                status.fetch = hasStale && isStale ? 'stale' : 'refresh';
                if (staleVal && isStale) status.returnedStale = true;
              }

              return _context9.abrupt("return", staleVal ? _p.__staleWhileFetching : _p.__returned = _p);

            case 29:
            case "end":
              return _context9.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "get",
    value: function get(k) {
      var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref8$allowStale = _ref8.allowStale,
          allowStale = _ref8$allowStale === void 0 ? this.allowStale : _ref8$allowStale,
          _ref8$updateAgeOnGet = _ref8.updateAgeOnGet,
          updateAgeOnGet = _ref8$updateAgeOnGet === void 0 ? this.updateAgeOnGet : _ref8$updateAgeOnGet,
          _ref8$noDeleteOnStale = _ref8.noDeleteOnStaleGet,
          noDeleteOnStaleGet = _ref8$noDeleteOnStale === void 0 ? this.noDeleteOnStaleGet : _ref8$noDeleteOnStale,
          status = _ref8.status;

      var index = this.keyMap.get(k);

      if (index !== undefined) {
        var value = this.valList[index];
        var fetching = this.isBackgroundFetch(value);
        this.statusTTL(status, index);

        if (this.isStale(index)) {
          if (status) status.get = 'stale'; // delete only if not an in-flight background fetch

          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              this["delete"](k);
            }

            if (status) status.returnedStale = allowStale;
            return allowStale ? value : undefined;
          } else {
            if (status) {
              status.returnedStale = allowStale && value.__staleWhileFetching !== undefined;
            }

            return allowStale ? value.__staleWhileFetching : undefined;
          }
        } else {
          if (status) status.get = 'hit'; // if we're currently fetching it, we don't actually have it yet
          // it's not stale, which means this isn't a staleWhileRefetching.
          // If it's not stale, and fetching, AND has a __staleWhileFetching
          // value, then that means the user fetched with {forceRefresh:true},
          // so it's safe to return that value.

          if (fetching) {
            return value.__staleWhileFetching;
          }

          this.moveToTail(index);

          if (updateAgeOnGet) {
            this.updateItemAge(index);
          }

          return value;
        }
      } else if (status) {
        status.get = 'miss';
      }
    }
  }, {
    key: "connect",
    value: function connect(p, n) {
      this.prev[n] = p;
      this.next[p] = n;
    }
  }, {
    key: "moveToTail",
    value: function moveToTail(index) {
      // if tail already, nothing to do
      // if head, move head to next[index]
      // else
      //   move next[prev[index]] to next[index] (head has no prev)
      //   move prev[next[index]] to prev[index]
      // prev[index] = tail
      // next[tail] = index
      // tail = index
      if (index !== this.tail) {
        if (index === this.head) {
          this.head = this.next[index];
        } else {
          this.connect(this.prev[index], this.next[index]);
        }

        this.connect(this.tail, index);
        this.tail = index;
      }
    }
  }, {
    key: "delete",
    value: function _delete(k) {
      var deleted = false;

      if (this.size !== 0) {
        var index = this.keyMap.get(k);

        if (index !== undefined) {
          deleted = true;

          if (this.size === 1) {
            this.clear();
          } else {
            this.removeItemSize(index);
            var v = this.valList[index];

            if (this.isBackgroundFetch(v)) {
              v.__abortController.abort(new Error('deleted'));
            } else {
              this.dispose(v, k, 'delete');

              if (this.disposeAfter) {
                this.disposed.push([v, k, 'delete']);
              }
            }

            this.keyMap["delete"](k);
            this.keyList[index] = null;
            this.valList[index] = null;

            if (index === this.tail) {
              this.tail = this.prev[index];
            } else if (index === this.head) {
              this.head = this.next[index];
            } else {
              this.next[this.prev[index]] = this.next[index];
              this.prev[this.next[index]] = this.prev[index];
            }

            this.size--;
            this.free.push(index);
          }
        }
      }

      if (this.disposed) {
        while (this.disposed.length) {
          this.disposeAfter.apply(this, _toConsumableArray(this.disposed.shift()));
        }
      }

      return deleted;
    }
  }, {
    key: "clear",
    value: function clear() {
      var _iteratorNormalCompletion13 = true;
      var _didIteratorError13 = false;
      var _iteratorError13 = undefined;

      try {
        for (var _iterator13 = this.rindexes({
          allowStale: true
        })[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
          var index = _step13.value;
          var v = this.valList[index];

          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('deleted'));
          } else {
            var k = this.keyList[index];
            this.dispose(v, k, 'delete');

            if (this.disposeAfter) {
              this.disposed.push([v, k, 'delete']);
            }
          }
        }
      } catch (err) {
        _didIteratorError13 = true;
        _iteratorError13 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
            _iterator13["return"]();
          }
        } finally {
          if (_didIteratorError13) {
            throw _iteratorError13;
          }
        }
      }

      this.keyMap.clear();
      this.valList.fill(null);
      this.keyList.fill(null);

      if (this.ttls) {
        this.ttls.fill(0);
        this.starts.fill(0);
      }

      if (this.sizes) {
        this.sizes.fill(0);
      }

      this.head = 0;
      this.tail = 0;
      this.initialFill = 1;
      this.free.length = 0;
      this.calculatedSize = 0;
      this.size = 0;

      if (this.disposed) {
        while (this.disposed.length) {
          this.disposeAfter.apply(this, _toConsumableArray(this.disposed.shift()));
        }
      }
    }
  }, {
    key: "prune",
    get: function get() {
      deprecatedMethod('prune', 'purgeStale');
      return this.purgeStale;
    }
  }, {
    key: "del",
    get: function get() {
      deprecatedMethod('del', 'delete');
      return this["delete"];
    }
  }, {
    key: "reset",
    get: function get() {
      deprecatedMethod('reset', 'clear');
      return this.clear;
    }
  }, {
    key: "length",
    get: function get() {
      deprecatedProperty('length', 'size');
      return this.size;
    }
  }], [{
    key: "AbortController",
    get: function get() {
      return AC;
    }
  }, {
    key: "AbortSignal",
    get: function get() {
      return AS;
    }
  }]);

  return LRUCache;
}();

module.exports = LRUCache;