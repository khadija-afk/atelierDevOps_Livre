// This file was modified by Oracle on June 1, 2021.
// A utility method was introduced to generate an Error instance from a
// binary server packet.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.
// This file was modified by Oracle on September 21, 2021.
// The new AuthNextFactor packet is now available.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var process = require('process');

var AuthNextFactor = require('./auth_next_factor');

var AuthSwitchRequest = require('./auth_switch_request');

var AuthSwitchRequestMoreData = require('./auth_switch_request_more_data');

var AuthSwitchResponse = require('./auth_switch_response');

var BinaryRow = require('./binary_row');

var BinlogDump = require('./binlog_dump');

var ChangeUser = require('./change_user');

var CloseStatement = require('./close_statement');

var ColumnDefinition = require('./column_definition');

var Execute = require('./execute');

var Handshake = require('./handshake');

var HandshakeResponse = require('./handshake_response');

var PrepareStatement = require('./prepare_statement');

var PreparedStatementHeader = require('./prepared_statement_header');

var Query = require('./query');

var RegisterSlave = require('./register_slave');

var ResultSetHeader = require('./resultset_header');

var SSLRequest = require('./ssl_request');

var TextRow = require('./text_row');

var ctorMap = {
  AuthNextFactor: AuthNextFactor,
  AuthSwitchRequest: AuthSwitchRequest,
  AuthSwitchRequestMoreData: AuthSwitchRequestMoreData,
  AuthSwitchResponse: AuthSwitchResponse,
  BinaryRow: BinaryRow,
  BinlogDump: BinlogDump,
  ChangeUser: ChangeUser,
  CloseStatement: CloseStatement,
  ColumnDefinition: ColumnDefinition,
  Execute: Execute,
  Handshake: Handshake,
  HandshakeResponse: HandshakeResponse,
  PrepareStatement: PrepareStatement,
  PreparedStatementHeader: PreparedStatementHeader,
  Query: Query,
  RegisterSlave: RegisterSlave,
  ResultSetHeader: ResultSetHeader,
  SSLRequest: SSLRequest,
  TextRow: TextRow
};
Object.entries(ctorMap).forEach(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      name = _ref2[0],
      ctor = _ref2[1];

  module.exports[name] = ctor; // monkey-patch it to include name if debug is on

  if (process.env.NODE_DEBUG) {
    if (ctor.prototype.toPacket) {
      var old = ctor.prototype.toPacket;

      ctor.prototype.toPacket = function () {
        var p = old.call(this);
        p._name = name;
        return p;
      };
    }
  }
}); // simple packets:

var Packet = require('./packet');

exports.Packet = Packet;

var OK =
/*#__PURE__*/
function () {
  function OK() {
    _classCallCheck(this, OK);
  }

  _createClass(OK, null, [{
    key: "toPacket",
    value: function toPacket(args, encoding) {
      args = args || {};
      var affectedRows = args.affectedRows || 0;
      var insertId = args.insertId || 0;
      var serverStatus = args.serverStatus || 0;
      var warningCount = args.warningCount || 0;
      var message = args.message || '';
      var length = 9 + Packet.lengthCodedNumberLength(affectedRows);
      length += Packet.lengthCodedNumberLength(insertId);
      var buffer = Buffer.allocUnsafe(length);
      var packet = new Packet(0, buffer, 0, length);
      packet.offset = 4;
      packet.writeInt8(0);
      packet.writeLengthCodedNumber(affectedRows);
      packet.writeLengthCodedNumber(insertId);
      packet.writeInt16(serverStatus);
      packet.writeInt16(warningCount);
      packet.writeString(message, encoding);
      packet._name = 'OK';
      return packet;
    }
  }]);

  return OK;
}();

exports.OK = OK; // warnings, statusFlags

var EOF =
/*#__PURE__*/
function () {
  function EOF() {
    _classCallCheck(this, EOF);
  }

  _createClass(EOF, null, [{
    key: "toPacket",
    value: function toPacket(warnings, statusFlags) {
      if (typeof warnings === 'undefined') {
        warnings = 0;
      }

      if (typeof statusFlags === 'undefined') {
        statusFlags = 0;
      }

      var packet = new Packet(0, Buffer.allocUnsafe(9), 0, 9);
      packet.offset = 4;
      packet.writeInt8(0xfe);
      packet.writeInt16(warnings);
      packet.writeInt16(statusFlags);
      packet._name = 'EOF';
      return packet;
    }
  }]);

  return EOF;
}();

exports.EOF = EOF;

var Error =
/*#__PURE__*/
function () {
  function Error() {
    _classCallCheck(this, Error);
  }

  _createClass(Error, null, [{
    key: "toPacket",
    value: function toPacket(args, encoding) {
      var length = 13 + Buffer.byteLength(args.message, 'utf8');
      var packet = new Packet(0, Buffer.allocUnsafe(length), 0, length);
      packet.offset = 4;
      packet.writeInt8(0xff);
      packet.writeInt16(args.code); // TODO: sql state parameter

      packet.writeString('#_____', encoding);
      packet.writeString(args.message, encoding);
      packet._name = 'Error';
      return packet;
    }
  }, {
    key: "fromPacket",
    value: function fromPacket(packet) {
      packet.readInt8(); // marker

      var code = packet.readInt16();
      packet.readString(1, 'ascii'); // sql state marker
      // The SQL state of the ERR_Packet which is always 5 bytes long.
      // https://dev.mysql.com/doc/dev/mysql-server/8.0.11/page_protocol_basic_dt_strings.html#sect_protocol_basic_dt_string_fix

      packet.readString(5, 'ascii'); // sql state (ignore for now)

      var message = packet.readNullTerminatedString('utf8');
      var error = new Error();
      error.message = message;
      error.code = code;
      return error;
    }
  }]);

  return Error;
}();

exports.Error = Error;