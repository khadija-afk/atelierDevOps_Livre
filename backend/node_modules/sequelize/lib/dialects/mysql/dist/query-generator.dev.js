"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return a;
};

var __spreadProps = function __spreadProps(a, b) {
  return __defProps(a, __getOwnPropDescs(b));
};

var _ = require("lodash");

var Utils = require("../../utils");

var AbstractQueryGenerator = require("../abstract/query-generator");

var util = require("util");

var Op = require("../../operators");

var JSON_FUNCTION_REGEX = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
var JSON_OPERATOR_REGEX = /^\s*(->>?|@>|<@|\?[|&]?|\|{2}|#-)/i;
var TOKEN_CAPTURE_REGEX = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;
var FOREIGN_KEY_FIELDS = ["CONSTRAINT_NAME as constraint_name", "CONSTRAINT_NAME as constraintName", "CONSTRAINT_SCHEMA as constraintSchema", "CONSTRAINT_SCHEMA as constraintCatalog", "TABLE_NAME as tableName", "TABLE_SCHEMA as tableSchema", "TABLE_SCHEMA as tableCatalog", "COLUMN_NAME as columnName", "REFERENCED_TABLE_SCHEMA as referencedTableSchema", "REFERENCED_TABLE_SCHEMA as referencedTableCatalog", "REFERENCED_TABLE_NAME as referencedTableName", "REFERENCED_COLUMN_NAME as referencedColumnName"].join(",");
var typeWithoutDefault =
/* @__PURE__ */
new Set(["BLOB", "TEXT", "GEOMETRY", "JSON"]);

var MySQLQueryGenerator =
/*#__PURE__*/
function (_AbstractQueryGenerat) {
  _inherits(MySQLQueryGenerator, _AbstractQueryGenerat);

  function MySQLQueryGenerator(options) {
    var _spreadProps;

    var _this;

    _classCallCheck(this, MySQLQueryGenerator);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MySQLQueryGenerator).call(this, options));
    _this.OperatorMap = __spreadProps(__spreadValues({}, _this.OperatorMap), (_spreadProps = {}, _defineProperty(_spreadProps, Op.regexp, "REGEXP"), _defineProperty(_spreadProps, Op.notRegexp, "NOT REGEXP"), _spreadProps));
    return _this;
  }

  _createClass(MySQLQueryGenerator, [{
    key: "createDatabaseQuery",
    value: function createDatabaseQuery(databaseName, options) {
      options = __spreadValues({
        charset: null,
        collate: null
      }, options);
      return Utils.joinSQLFragments(["CREATE DATABASE IF NOT EXISTS", this.quoteIdentifier(databaseName), options.charset && "DEFAULT CHARACTER SET ".concat(this.escape(options.charset)), options.collate && "DEFAULT COLLATE ".concat(this.escape(options.collate)), ";"]);
    }
  }, {
    key: "dropDatabaseQuery",
    value: function dropDatabaseQuery(databaseName) {
      return "DROP DATABASE IF EXISTS ".concat(this.quoteIdentifier(databaseName), ";");
    }
  }, {
    key: "createSchema",
    value: function createSchema() {
      return "SHOW TABLES";
    }
  }, {
    key: "showSchemasQuery",
    value: function showSchemasQuery() {
      return "SHOW TABLES";
    }
  }, {
    key: "versionQuery",
    value: function versionQuery() {
      return "SELECT VERSION() as `version`";
    }
  }, {
    key: "createTableQuery",
    value: function createTableQuery(tableName, attributes, options) {
      var _this2 = this;

      options = __spreadValues({
        engine: "InnoDB",
        charset: null,
        rowFormat: null
      }, options);
      var primaryKeys = [];
      var foreignKeys = {};
      var attrStr = [];

      for (var attr in attributes) {
        if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;
        var dataType = attributes[attr];
        var match = void 0;

        if (dataType.includes("PRIMARY KEY")) {
          primaryKeys.push(attr);

          if (dataType.includes("REFERENCES")) {
            match = dataType.match(/^(.+) (REFERENCES.*)$/);
            attrStr.push("".concat(this.quoteIdentifier(attr), " ").concat(match[1].replace("PRIMARY KEY", "")));
            foreignKeys[attr] = match[2];
          } else {
            attrStr.push("".concat(this.quoteIdentifier(attr), " ").concat(dataType.replace("PRIMARY KEY", "")));
          }
        } else if (dataType.includes("REFERENCES")) {
          match = dataType.match(/^(.+) (REFERENCES.*)$/);
          attrStr.push("".concat(this.quoteIdentifier(attr), " ").concat(match[1]));
          foreignKeys[attr] = match[2];
        } else {
          attrStr.push("".concat(this.quoteIdentifier(attr), " ").concat(dataType));
        }
      }

      var table = this.quoteTable(tableName);
      var attributesClause = attrStr.join(", ");
      var pkString = primaryKeys.map(function (pk) {
        return _this2.quoteIdentifier(pk);
      }).join(", ");

      if (options.uniqueKeys) {
        _.each(options.uniqueKeys, function (columns, indexName) {
          if (columns.customIndex) {
            if (typeof indexName !== "string") {
              indexName = "uniq_".concat(tableName, "_").concat(columns.fields.join("_"));
            }

            attributesClause += ", UNIQUE ".concat(_this2.quoteIdentifier(indexName), " (").concat(columns.fields.map(function (field) {
              return _this2.quoteIdentifier(field);
            }).join(", "), ")");
          }
        });
      }

      if (pkString.length > 0) {
        attributesClause += ", PRIMARY KEY (".concat(pkString, ")");
      }

      for (var fkey in foreignKeys) {
        if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
          attributesClause += ", FOREIGN KEY (".concat(this.quoteIdentifier(fkey), ") ").concat(foreignKeys[fkey]);
        }
      }

      return Utils.joinSQLFragments(["CREATE TABLE IF NOT EXISTS", table, "(".concat(attributesClause, ")"), "ENGINE=".concat(options.engine), options.comment && typeof options.comment === "string" && "COMMENT ".concat(this.escape(options.comment)), options.charset && "DEFAULT CHARSET=".concat(options.charset), options.collate && "COLLATE ".concat(options.collate), options.initialAutoIncrement && "AUTO_INCREMENT=".concat(options.initialAutoIncrement), options.rowFormat && "ROW_FORMAT=".concat(options.rowFormat), ";"]);
    }
  }, {
    key: "describeTableQuery",
    value: function describeTableQuery(tableName, schema, schemaDelimiter) {
      var table = this.quoteTable(this.addSchema({
        tableName: tableName,
        _schema: schema,
        _schemaDelimiter: schemaDelimiter
      }));
      return "SHOW FULL COLUMNS FROM ".concat(table, ";");
    }
  }, {
    key: "showTablesQuery",
    value: function showTablesQuery(database) {
      var query = "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'";

      if (database) {
        query += " AND TABLE_SCHEMA = ".concat(this.escape(database));
      } else {
        query += " AND TABLE_SCHEMA NOT IN ('MYSQL', 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS', 'mysql', 'information_schema', 'performance_schema', 'sys')";
      }

      return "".concat(query, ";");
    }
  }, {
    key: "tableExistsQuery",
    value: function tableExistsQuery(table) {
      var tableName = this.escape(this.quoteTable(table).slice(1, -1));
      return "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ".concat(tableName, " AND TABLE_SCHEMA = ").concat(this.escape(this.sequelize.config.database));
    }
  }, {
    key: "addColumnQuery",
    value: function addColumnQuery(table, key, dataType) {
      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(table), "ADD", this.quoteIdentifier(key), this.attributeToSQL(dataType, {
        context: "addColumn",
        tableName: table,
        foreignKey: key
      }), ";"]);
    }
  }, {
    key: "removeColumnQuery",
    value: function removeColumnQuery(tableName, attributeName) {
      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(tableName), "DROP", this.quoteIdentifier(attributeName), ";"]);
    }
  }, {
    key: "changeColumnQuery",
    value: function changeColumnQuery(tableName, attributes) {
      var attrString = [];
      var constraintString = [];

      for (var attributeName in attributes) {
        var definition = attributes[attributeName];

        if (definition.includes("REFERENCES")) {
          var attrName = this.quoteIdentifier(attributeName);
          definition = definition.replace(/.+?(?=REFERENCES)/, "");
          constraintString.push("FOREIGN KEY (".concat(attrName, ") ").concat(definition));
        } else {
          attrString.push("`".concat(attributeName, "` `").concat(attributeName, "` ").concat(definition));
        }
      }

      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(tableName), attrString.length && "CHANGE ".concat(attrString.join(", ")), constraintString.length && "ADD ".concat(constraintString.join(", ")), ";"]);
    }
  }, {
    key: "renameColumnQuery",
    value: function renameColumnQuery(tableName, attrBefore, attributes) {
      var attrString = [];

      for (var attrName in attributes) {
        var definition = attributes[attrName];
        attrString.push("`".concat(attrBefore, "` `").concat(attrName, "` ").concat(definition));
      }

      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(tableName), "CHANGE", attrString.join(", "), ";"]);
    }
  }, {
    key: "handleSequelizeMethod",
    value: function handleSequelizeMethod(smth, tableName, factory, options, prepend) {
      var _this3 = this;

      if (smth instanceof Utils.Json) {
        if (smth.conditions) {
          var conditions = this.parseConditionObject(smth.conditions).map(function (condition) {
            return "".concat(_this3.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path)), " = '").concat(condition.value, "'");
          });
          return conditions.join(" AND ");
        }

        if (smth.path) {
          var str;

          if (this._checkValidJsonStatement(smth.path)) {
            str = smth.path;
          } else {
            var paths = _.toPath(smth.path);

            var column = paths.shift();
            str = this.jsonPathExtractionQuery(column, paths);
          }

          if (smth.value) {
            str += util.format(" = %s", this.escape(smth.value));
          }

          return str;
        }
      } else if (smth instanceof Utils.Cast) {
        if (/timestamp/i.test(smth.type)) {
          smth.type = "datetime";
        } else if (smth.json && /boolean/i.test(smth.type)) {
          smth.type = "char";
        } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {
          smth.type = "decimal";
        } else if (/text/i.test(smth.type)) {
          smth.type = "char";
        }
      }

      return _get(_getPrototypeOf(MySQLQueryGenerator.prototype), "handleSequelizeMethod", this).call(this, smth, tableName, factory, options, prepend);
    }
  }, {
    key: "_toJSONValue",
    value: function _toJSONValue(value) {
      if (typeof value === "boolean") {
        return value.toString();
      }

      if (value === null) {
        return "null";
      }

      return value;
    }
  }, {
    key: "truncateTableQuery",
    value: function truncateTableQuery(tableName) {
      return "TRUNCATE ".concat(this.quoteTable(tableName));
    }
  }, {
    key: "deleteQuery",
    value: function deleteQuery(tableName, where) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var model = arguments.length > 3 ? arguments[3] : undefined;
      var limit = "";
      var query = "DELETE FROM ".concat(this.quoteTable(tableName));

      if (options.limit) {
        limit = " LIMIT ".concat(this.escape(options.limit));
      }

      where = this.getWhereConditions(where, null, model, options);

      if (where) {
        query += " WHERE ".concat(where);
      }

      return query + limit;
    }
  }, {
    key: "showIndexesQuery",
    value: function showIndexesQuery(tableName, options) {
      return Utils.joinSQLFragments(["SHOW INDEX FROM ".concat(this.quoteTable(tableName)), options && options.database && "FROM `".concat(options.database, "`")]);
    }
  }, {
    key: "showConstraintsQuery",
    value: function showConstraintsQuery(table, constraintName) {
      var tableName = table.tableName || table;
      var schemaName = table.schema;
      return Utils.joinSQLFragments(["SELECT CONSTRAINT_CATALOG AS constraintCatalog,", "CONSTRAINT_NAME AS constraintName,", "CONSTRAINT_SCHEMA AS constraintSchema,", "CONSTRAINT_TYPE AS constraintType,", "TABLE_NAME AS tableName,", "TABLE_SCHEMA AS tableSchema", "from INFORMATION_SCHEMA.TABLE_CONSTRAINTS", "WHERE table_name='".concat(tableName, "'"), constraintName && "AND constraint_name = '".concat(constraintName, "'"), schemaName && "AND TABLE_SCHEMA = '".concat(schemaName, "'"), ";"]);
    }
  }, {
    key: "removeIndexQuery",
    value: function removeIndexQuery(tableName, indexNameOrAttributes) {
      var indexName = indexNameOrAttributes;

      if (typeof indexName !== "string") {
        indexName = Utils.underscore("".concat(tableName, "_").concat(indexNameOrAttributes.join("_")));
      }

      return Utils.joinSQLFragments(["DROP INDEX", this.quoteIdentifier(indexName), "ON", this.quoteTable(tableName)]);
    }
  }, {
    key: "attributeToSQL",
    value: function attributeToSQL(attribute, options) {
      if (!_.isPlainObject(attribute)) {
        attribute = {
          type: attribute
        };
      }

      var attributeString = attribute.type.toString({
        escape: this.escape.bind(this)
      });
      var template = attributeString;

      if (attribute.allowNull === false) {
        template += " NOT NULL";
      }

      if (attribute.autoIncrement) {
        template += " auto_increment";
      }

      if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {
        template += " DEFAULT ".concat(this.escape(attribute.defaultValue));
      }

      if (attribute.unique === true) {
        template += " UNIQUE";
      }

      if (attribute.primaryKey) {
        template += " PRIMARY KEY";
      }

      if (attribute.comment) {
        template += " COMMENT ".concat(this.escape(attribute.comment));
      }

      if (attribute.first) {
        template += " FIRST";
      }

      if (attribute.after) {
        template += " AFTER ".concat(this.quoteIdentifier(attribute.after));
      }

      if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {
        if (options && options.context === "addColumn" && options.foreignKey) {
          var attrName = this.quoteIdentifier(options.foreignKey);
          var fkName = this.quoteIdentifier("".concat(options.tableName, "_").concat(attrName, "_foreign_idx"));
          template += ", ADD CONSTRAINT ".concat(fkName, " FOREIGN KEY (").concat(attrName, ")");
        }

        template += " REFERENCES ".concat(this.quoteTable(attribute.references.model));

        if (attribute.references.key) {
          template += " (".concat(this.quoteIdentifier(attribute.references.key), ")");
        } else {
          template += " (".concat(this.quoteIdentifier("id"), ")");
        }

        if (attribute.onDelete) {
          template += " ON DELETE ".concat(attribute.onDelete.toUpperCase());
        }

        if (attribute.onUpdate) {
          template += " ON UPDATE ".concat(attribute.onUpdate.toUpperCase());
        }
      }

      return template;
    }
  }, {
    key: "attributesToSQL",
    value: function attributesToSQL(attributes, options) {
      var result = {};

      for (var key in attributes) {
        var attribute = attributes[key];
        result[attribute.field || key] = this.attributeToSQL(attribute, options);
      }

      return result;
    }
  }, {
    key: "_checkValidJsonStatement",
    value: function _checkValidJsonStatement(stmt) {
      if (typeof stmt !== "string") {
        return false;
      }

      var currentIndex = 0;
      var openingBrackets = 0;
      var closingBrackets = 0;
      var hasJsonFunction = false;
      var hasInvalidToken = false;

      while (currentIndex < stmt.length) {
        var string = stmt.substr(currentIndex);
        var functionMatches = JSON_FUNCTION_REGEX.exec(string);

        if (functionMatches) {
          currentIndex += functionMatches[0].indexOf("(");
          hasJsonFunction = true;
          continue;
        }

        var operatorMatches = JSON_OPERATOR_REGEX.exec(string);

        if (operatorMatches) {
          currentIndex += operatorMatches[0].length;
          hasJsonFunction = true;
          continue;
        }

        var tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);

        if (tokenMatches) {
          var capturedToken = tokenMatches[1];

          if (capturedToken === "(") {
            openingBrackets++;
          } else if (capturedToken === ")") {
            closingBrackets++;
          } else if (capturedToken === ";") {
            hasInvalidToken = true;
            break;
          }

          currentIndex += tokenMatches[0].length;
          continue;
        }

        break;
      }

      if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {
        throw new Error("Invalid json statement: ".concat(stmt));
      }

      return hasJsonFunction;
    }
  }, {
    key: "getForeignKeysQuery",
    value: function getForeignKeysQuery(table, schemaName) {
      var tableName = table.tableName || table;
      return Utils.joinSQLFragments(["SELECT", FOREIGN_KEY_FIELDS, "FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '".concat(tableName, "'"), "AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='".concat(schemaName, "'"), "AND REFERENCED_TABLE_NAME IS NOT NULL", ";"]);
    }
  }, {
    key: "getForeignKeyQuery",
    value: function getForeignKeyQuery(table, columnName) {
      var quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : "";
      var quotedTableName = wrapSingleQuote(table.tableName || table);
      var quotedColumnName = wrapSingleQuote(columnName);
      return Utils.joinSQLFragments(["SELECT", FOREIGN_KEY_FIELDS, "FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE", "WHERE (", ["REFERENCED_TABLE_NAME = ".concat(quotedTableName), table.schema && "AND REFERENCED_TABLE_SCHEMA = ".concat(quotedSchemaName), "AND REFERENCED_COLUMN_NAME = ".concat(quotedColumnName)], ") OR (", ["TABLE_NAME = ".concat(quotedTableName), table.schema && "AND TABLE_SCHEMA = ".concat(quotedSchemaName), "AND COLUMN_NAME = ".concat(quotedColumnName), "AND REFERENCED_TABLE_NAME IS NOT NULL"], ")"]);
    }
  }, {
    key: "dropForeignKeyQuery",
    value: function dropForeignKeyQuery(tableName, foreignKey) {
      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(tableName), "DROP FOREIGN KEY", this.quoteIdentifier(foreignKey), ";"]);
    }
  }, {
    key: "quoteIdentifier",
    value: function quoteIdentifier(identifier, force) {
      return Utils.addTicks(Utils.removeTicks(identifier, "`"), "`");
    }
  }]);

  return MySQLQueryGenerator;
}(AbstractQueryGenerator);

function wrapSingleQuote(identifier) {
  return Utils.addTicks(identifier, "'");
}

module.exports = MySQLQueryGenerator;