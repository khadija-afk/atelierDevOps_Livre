"use strict";

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return a;
};

var __spreadProps = function __spreadProps(a, b) {
  return __defProps(a, __getOwnPropDescs(b));
};

var assert = require("assert");

var _ = require("lodash");

var Dottie = require("dottie");

var Utils = require("./utils");

var _require = require("./utils/logger"),
    logger = _require.logger;

var BelongsTo = require("./associations/belongs-to");

var BelongsToMany = require("./associations/belongs-to-many");

var InstanceValidator = require("./instance-validator");

var QueryTypes = require("./query-types");

var sequelizeErrors = require("./errors");

var Association = require("./associations/base");

var HasMany = require("./associations/has-many");

var DataTypes = require("./data-types");

var Hooks = require("./hooks");

var associationsMixin = require("./associations/mixin");

var Op = require("./operators");

var _require2 = require("./utils/deprecations"),
    noDoubleNestedGroup = _require2.noDoubleNestedGroup;

var validQueryKeywords =
/* @__PURE__ */
new Set(["where", "attributes", "paranoid", "include", "order", "limit", "offset", "transaction", "lock", "raw", "logging", "benchmark", "having", "searchPath", "rejectOnEmpty", "plain", "scope", "group", "through", "defaults", "distinct", "primary", "exception", "type", "hooks", "force", "name"]);
var nonCascadingOptions = ["include", "attributes", "originalAttributes", "order", "where", "limit", "offset", "plain", "group", "having"];

var Model =
/*#__PURE__*/
function () {
  _createClass(Model, [{
    key: "sequelize",
    get: function get() {
      return this.constructor.sequelize;
    }
  }], [{
    key: "queryInterface",
    get: function get() {
      return this.sequelize.getQueryInterface();
    }
  }, {
    key: "queryGenerator",
    get: function get() {
      return this.queryInterface.queryGenerator;
    }
  }]);

  function Model() {
    var _this = this;

    var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Model);

    if (!this.constructor._overwrittenAttributesChecked) {
      this.constructor._overwrittenAttributesChecked = true;
      setTimeout(function () {
        var overwrittenAttributes = [];

        for (var _i = 0, _Object$keys = Object.keys(_this.constructor._attributeManipulation); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];

          if (Object.prototype.hasOwnProperty.call(_this, key)) {
            overwrittenAttributes.push(key);
          }
        }

        if (overwrittenAttributes.length > 0) {
          logger.warn("Model ".concat(JSON.stringify(_this.constructor.name), " is declaring public class fields for attribute(s): ").concat(overwrittenAttributes.map(function (attr) {
            return JSON.stringify(attr);
          }).join(", "), ".\nThese class fields are shadowing Sequelize's attribute getters & setters.\nSee https://sequelize.org/main/manual/model-basics.html#caveat-with-public-class-fields"));
        }
      }, 0);
    }

    options = __spreadValues({
      isNewRecord: true,
      _schema: this.constructor._schema,
      _schemaDelimiter: this.constructor._schemaDelimiter
    }, options);

    if (options.attributes) {
      options.attributes = options.attributes.map(function (attribute) {
        return Array.isArray(attribute) ? attribute[1] : attribute;
      });
    }

    if (!options.includeValidated) {
      this.constructor._conformIncludes(options, this.constructor);

      if (options.include) {
        this.constructor._expandIncludeAll(options);

        this.constructor._validateIncludedElements(options);
      }
    }

    this.dataValues = {};
    this._previousDataValues = {};
    this.uniqno = 1;
    this._changed =
    /* @__PURE__ */
    new Set();
    this._options = options;
    this.isNewRecord = options.isNewRecord;

    this._initValues(values, options);
  }

  _createClass(Model, [{
    key: "_initValues",
    value: function _initValues(values, options) {
      var defaults;
      var key;
      values = __spreadValues({}, values);

      if (options.isNewRecord) {
        defaults = {};

        if (this.constructor._hasDefaultValues) {
          defaults = _.mapValues(this.constructor._defaultValues, function (valueFn) {
            var value = valueFn();
            return value && value instanceof Utils.SequelizeMethod ? value : _.cloneDeep(value);
          });
        }

        if (this.constructor.primaryKeyAttributes.length) {
          this.constructor.primaryKeyAttributes.forEach(function (primaryKeyAttribute) {
            if (!Object.prototype.hasOwnProperty.call(defaults, primaryKeyAttribute)) {
              defaults[primaryKeyAttribute] = null;
            }
          });
        }

        if (this.constructor._timestampAttributes.createdAt && defaults[this.constructor._timestampAttributes.createdAt]) {
          this.dataValues[this.constructor._timestampAttributes.createdAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.createdAt], this.sequelize.options.dialect);
          delete defaults[this.constructor._timestampAttributes.createdAt];
        }

        if (this.constructor._timestampAttributes.updatedAt && defaults[this.constructor._timestampAttributes.updatedAt]) {
          this.dataValues[this.constructor._timestampAttributes.updatedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.updatedAt], this.sequelize.options.dialect);
          delete defaults[this.constructor._timestampAttributes.updatedAt];
        }

        if (this.constructor._timestampAttributes.deletedAt && defaults[this.constructor._timestampAttributes.deletedAt]) {
          this.dataValues[this.constructor._timestampAttributes.deletedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.deletedAt], this.sequelize.options.dialect);
          delete defaults[this.constructor._timestampAttributes.deletedAt];
        }

        for (key in defaults) {
          if (values[key] === void 0) {
            this.set(key, Utils.toDefaultValue(defaults[key], this.sequelize.options.dialect), {
              raw: true
            });
            delete values[key];
          }
        }
      }

      this.set(values, options);
    }
  }, {
    key: "where",
    value: function where(checkVersion) {
      var _this2 = this;

      var where = this.constructor.primaryKeyAttributes.reduce(function (result, attribute) {
        result[attribute] = _this2.get(attribute, {
          raw: true
        });
        return result;
      }, {});

      if (_.size(where) === 0) {
        return this.constructor.options.whereCollection;
      }

      var versionAttr = this.constructor._versionAttribute;

      if (checkVersion && versionAttr) {
        where[versionAttr] = this.get(versionAttr, {
          raw: true
        });
      }

      return Utils.mapWhereFieldNames(where, this.constructor);
    }
  }, {
    key: "toString",
    value: function toString() {
      return "[object SequelizeInstance:".concat(this.constructor.name, "]");
    }
  }, {
    key: "getDataValue",
    value: function getDataValue(key) {
      return this.dataValues[key];
    }
  }, {
    key: "setDataValue",
    value: function setDataValue(key, value) {
      var originalValue = this._previousDataValues[key];

      if (!_.isEqual(value, originalValue)) {
        this.changed(key, true);
      }

      this.dataValues[key] = value;
    }
  }, {
    key: "get",
    value: function get(key, options) {
      if (options === void 0 && _typeof(key) === "object") {
        options = key;
        key = void 0;
      }

      options = options || {};

      if (key) {
        if (Object.prototype.hasOwnProperty.call(this._customGetters, key) && !options.raw) {
          return this._customGetters[key].call(this, key, options);
        }

        if (options.plain && this._options.include && this._options.includeNames.includes(key)) {
          if (Array.isArray(this.dataValues[key])) {
            return this.dataValues[key].map(function (instance) {
              return instance.get(options);
            });
          }

          if (this.dataValues[key] instanceof Model) {
            return this.dataValues[key].get(options);
          }

          return this.dataValues[key];
        }

        return this.dataValues[key];
      }

      if (this._hasCustomGetters || options.plain && this._options.include || options.clone) {
        var values = {};

        var _key;

        if (this._hasCustomGetters) {
          for (_key in this._customGetters) {
            if (this._options.attributes && !this._options.attributes.includes(_key)) {
              continue;
            }

            if (Object.prototype.hasOwnProperty.call(this._customGetters, _key)) {
              values[_key] = this.get(_key, options);
            }
          }
        }

        for (_key in this.dataValues) {
          if (!Object.prototype.hasOwnProperty.call(values, _key) && Object.prototype.hasOwnProperty.call(this.dataValues, _key)) {
            values[_key] = this.get(_key, options);
          }
        }

        return values;
      }

      return this.dataValues;
    }
  }, {
    key: "set",
    value: function set(key, value, options) {
      var _this3 = this;

      var values;
      var originalValue;

      if (_typeof(key) === "object" && key !== null) {
        values = key;
        options = value || {};

        if (options.reset) {
          this.dataValues = {};

          for (var key2 in values) {
            this.changed(key2, false);
          }
        }

        if (options.raw && !(this._options && this._options.include) && !(options && options.attributes) && !this.constructor._hasDateAttributes && !this.constructor._hasBooleanAttributes) {
          if (Object.keys(this.dataValues).length) {
            Object.assign(this.dataValues, values);
          } else {
            this.dataValues = values;
          }

          this._previousDataValues = __spreadValues({}, this.dataValues);
        } else {
          if (options.attributes) {
            var setKeys = function setKeys(data) {
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var k = _step2.value;

                  if (values[k] === void 0) {
                    continue;
                  }

                  _this3.set(k, values[k], options);
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                    _iterator2["return"]();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            };

            setKeys(options.attributes);

            if (this.constructor._hasVirtualAttributes) {
              setKeys(this.constructor._virtualAttributes);
            }

            if (this._options.includeNames) {
              setKeys(this._options.includeNames);
            }
          } else {
            for (var _key2 in values) {
              this.set(_key2, values[_key2], options);
            }
          }

          if (options.raw) {
            this._previousDataValues = __spreadValues({}, this.dataValues);
          }
        }

        return this;
      }

      if (!options) options = {};

      if (!options.raw) {
        originalValue = this.dataValues[key];
      }

      if (!options.raw && this._customSetters[key]) {
        this._customSetters[key].call(this, value, key);

        var newValue = this.dataValues[key];

        if (!_.isEqual(newValue, originalValue)) {
          this._previousDataValues[key] = originalValue;
          this.changed(key, true);
        }
      } else {
        if (this._options && this._options.include && this._options.includeNames.includes(key)) {
          this._setInclude(key, value, options);

          return this;
        }

        if (!options.raw) {
          if (!this._isAttribute(key)) {
            if (key.includes(".") && this.constructor._jsonAttributes.has(key.split(".")[0])) {
              var previousNestedValue = Dottie.get(this.dataValues, key);

              if (!_.isEqual(previousNestedValue, value)) {
                Dottie.set(this.dataValues, key, value);
                this.changed(key.split(".")[0], true);
              }
            }

            return this;
          }

          if (this.constructor._hasPrimaryKeys && originalValue && this.constructor._isPrimaryKey(key)) {
            return this;
          }

          if (!this.isNewRecord && this.constructor._hasReadOnlyAttributes && this.constructor._readOnlyAttributes.has(key)) {
            return this;
          }
        }

        if (!(value instanceof Utils.SequelizeMethod) && Object.prototype.hasOwnProperty.call(this.constructor._dataTypeSanitizers, key)) {
          value = this.constructor._dataTypeSanitizers[key].call(this, value, options);
        }

        if (!options.raw && (value instanceof Utils.SequelizeMethod || !(value instanceof Utils.SequelizeMethod) && this.constructor._dataTypeChanges[key] && this.constructor._dataTypeChanges[key].call(this, value, originalValue, options) || !this.constructor._dataTypeChanges[key] && !_.isEqual(value, originalValue))) {
          this._previousDataValues[key] = originalValue;
          this.changed(key, true);
        }

        this.dataValues[key] = value;
      }

      return this;
    }
  }, {
    key: "setAttributes",
    value: function setAttributes(updates) {
      return this.set(updates);
    }
  }, {
    key: "changed",
    value: function changed(key, value) {
      if (key === void 0) {
        if (this._changed.size > 0) {
          return Array.from(this._changed);
        }

        return false;
      }

      if (value === true) {
        this._changed.add(key);

        return this;
      }

      if (value === false) {
        this._changed["delete"](key);

        return this;
      }

      return this._changed.has(key);
    }
  }, {
    key: "previous",
    value: function previous(key) {
      var _this4 = this;

      if (key) {
        return this._previousDataValues[key];
      }

      return _.pickBy(this._previousDataValues, function (value, key2) {
        return _this4.changed(key2);
      });
    }
  }, {
    key: "_setInclude",
    value: function _setInclude(key, value, options) {
      if (!Array.isArray(value)) value = [value];

      if (value[0] instanceof Model) {
        value = value.map(function (instance) {
          return instance.dataValues;
        });
      }

      var include = this._options.includeMap[key];
      var association = include.association;
      var accessor = key;
      var primaryKeyAttribute = include.model.primaryKeyAttribute;
      var childOptions = {
        isNewRecord: this.isNewRecord,
        include: include.include,
        includeNames: include.includeNames,
        includeMap: include.includeMap,
        includeValidated: true,
        raw: options.raw,
        attributes: include.originalAttributes
      };
      var isEmpty;

      if (include.originalAttributes === void 0 || include.originalAttributes.length) {
        if (association.isSingleAssociation) {
          if (Array.isArray(value)) {
            value = value[0];
          }

          isEmpty = value && value[primaryKeyAttribute] === null || value === null;
          this[accessor] = this.dataValues[accessor] = isEmpty ? null : include.model.build(value, childOptions);
        } else {
          isEmpty = value[0] && value[0][primaryKeyAttribute] === null;
          this[accessor] = this.dataValues[accessor] = isEmpty ? [] : include.model.bulkBuild(value, childOptions);
        }
      }
    }
  }, {
    key: "save",
    value: function save(options) {
      var _this5 = this,
          _this$constructor$que;

      var t,
          primaryKeyName,
          primaryKeyAttribute,
          createdAtAttr,
          versionAttr,
          hook,
          wasNewRecord,
          now,
          updatedAtAttr,
          beforeHookValues,
          ignoreChanged,
          hookChanged,
          afterHookValues,
          _i2,
          _Object$keys2,
          key,
          realFields,
          versionFieldName,
          values,
          query,
          args,
          where,
          _ref,
          _ref2,
          result,
          rowsUpdated,
          _i3,
          _Object$keys3,
          attr,
          _iteratorNormalCompletion3,
          _didIteratorError3,
          _iteratorError3,
          _iterator3,
          _step3,
          field,
          _args4 = arguments;

      return regeneratorRuntime.async(function save$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!(_args4.length > 1)) {
                _context4.next = 2;
                break;
              }

              throw new Error("The second argument was removed in favor of the options object.");

            case 2:
              options = Utils.cloneDeep(options);

              if (options.transaction === void 0 && this.sequelize.constructor._cls) {
                t = this.sequelize.constructor._cls.get("transaction");

                if (t) {
                  options.transaction = t;
                }
              }

              options = _.defaults(options, {
                hooks: true,
                validate: true
              });

              if (!options.fields) {
                if (this.isNewRecord) {
                  options.fields = Object.keys(this.constructor.rawAttributes);
                } else {
                  options.fields = _.intersection(this.changed(), Object.keys(this.constructor.rawAttributes));
                }

                options.defaultFields = options.fields;
              }

              if (options.returning === void 0) {
                if (options.association) {
                  options.returning = false;
                } else if (this.isNewRecord) {
                  options.returning = true;
                }
              }

              primaryKeyName = this.constructor.primaryKeyAttribute;
              primaryKeyAttribute = primaryKeyName && this.constructor.rawAttributes[primaryKeyName];
              createdAtAttr = this.constructor._timestampAttributes.createdAt;
              versionAttr = this.constructor._versionAttribute;
              hook = this.isNewRecord ? "Create" : "Update";
              wasNewRecord = this.isNewRecord;
              now = Utils.now(this.sequelize.options.dialect);
              updatedAtAttr = this.constructor._timestampAttributes.updatedAt;

              if (updatedAtAttr && options.fields.length > 0 && !options.fields.includes(updatedAtAttr)) {
                options.fields.push(updatedAtAttr);
              }

              if (versionAttr && options.fields.length > 0 && !options.fields.includes(versionAttr)) {
                options.fields.push(versionAttr);
              }

              if (options.silent === true && !(this.isNewRecord && this.get(updatedAtAttr, {
                raw: true
              }))) {
                _.remove(options.fields, function (val) {
                  return val === updatedAtAttr;
                });

                updatedAtAttr = false;
              }

              if (this.isNewRecord === true) {
                if (createdAtAttr && !options.fields.includes(createdAtAttr)) {
                  options.fields.push(createdAtAttr);
                }

                if (primaryKeyAttribute && primaryKeyAttribute.defaultValue && !options.fields.includes(primaryKeyName)) {
                  options.fields.unshift(primaryKeyName);
                }
              }

              if (!(this.isNewRecord === false)) {
                _context4.next = 22;
                break;
              }

              if (!(primaryKeyName && this.get(primaryKeyName, {
                raw: true
              }) === void 0)) {
                _context4.next = 22;
                break;
              }

              throw new Error("You attempted to save an instance with no primary key, this is not allowed since it would result in a global update");

            case 22:
              if (updatedAtAttr && !options.silent && options.fields.includes(updatedAtAttr)) {
                this.dataValues[updatedAtAttr] = this.constructor._getDefaultTimestamp(updatedAtAttr) || now;
              }

              if (this.isNewRecord && createdAtAttr && !this.dataValues[createdAtAttr]) {
                this.dataValues[createdAtAttr] = this.constructor._getDefaultTimestamp(createdAtAttr) || now;
              }

              if (this.sequelize.options.dialect === "db2" && this.isNewRecord) {
                this.uniqno = this.sequelize.dialect.queryGenerator.addUniqueFields(this.dataValues, this.constructor.rawAttributes, this.uniqno);
              }

              if (!options.validate) {
                _context4.next = 28;
                break;
              }

              _context4.next = 28;
              return regeneratorRuntime.awrap(this.validate(options));

            case 28:
              if (!options.hooks) {
                _context4.next = 41;
                break;
              }

              beforeHookValues = _.pick(this.dataValues, options.fields);
              ignoreChanged = _.difference(this.changed(), options.fields);

              if (updatedAtAttr && options.fields.includes(updatedAtAttr)) {
                ignoreChanged = _.without(ignoreChanged, updatedAtAttr);
              }

              _context4.next = 34;
              return regeneratorRuntime.awrap(this.constructor.runHooks("before".concat(hook), this, options));

            case 34:
              if (options.defaultFields && !this.isNewRecord) {
                afterHookValues = _.pick(this.dataValues, _.difference(this.changed(), ignoreChanged));
                hookChanged = [];

                for (_i2 = 0, _Object$keys2 = Object.keys(afterHookValues); _i2 < _Object$keys2.length; _i2++) {
                  key = _Object$keys2[_i2];

                  if (afterHookValues[key] !== beforeHookValues[key]) {
                    hookChanged.push(key);
                  }
                }

                options.fields = _.uniq(options.fields.concat(hookChanged));
              }

              if (!hookChanged) {
                _context4.next = 41;
                break;
              }

              if (!options.validate) {
                _context4.next = 41;
                break;
              }

              options.skip = _.difference(Object.keys(this.constructor.rawAttributes), hookChanged);
              _context4.next = 40;
              return regeneratorRuntime.awrap(this.validate(options));

            case 40:
              delete options.skip;

            case 41:
              if (!(options.fields.length && this.isNewRecord && this._options.include && this._options.include.length)) {
                _context4.next = 44;
                break;
              }

              _context4.next = 44;
              return regeneratorRuntime.awrap(Promise.all(this._options.include.filter(function (include) {
                return include.association instanceof BelongsTo;
              }).map(function _callee(include) {
                var instance, includeOptions;
                return regeneratorRuntime.async(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        instance = _this5.get(include.as);

                        if (instance) {
                          _context.next = 3;
                          break;
                        }

                        return _context.abrupt("return");

                      case 3:
                        includeOptions = _(Utils.cloneDeep(include)).omit(["association"]).defaults({
                          transaction: options.transaction,
                          logging: options.logging,
                          parentRecord: _this5
                        }).value();
                        _context.next = 6;
                        return regeneratorRuntime.awrap(instance.save(includeOptions));

                      case 6:
                        _context.next = 8;
                        return regeneratorRuntime.awrap(_this5[include.association.accessors.set](instance, {
                          save: false,
                          logging: options.logging
                        }));

                      case 8:
                      case "end":
                        return _context.stop();
                    }
                  }
                });
              })));

            case 44:
              realFields = options.fields.filter(function (field) {
                return !_this5.constructor._virtualAttributes.has(field);
              });

              if (realFields.length) {
                _context4.next = 47;
                break;
              }

              return _context4.abrupt("return", this);

            case 47:
              if (!(!this.changed() && !this.isNewRecord)) {
                _context4.next = 49;
                break;
              }

              return _context4.abrupt("return", this);

            case 49:
              versionFieldName = _.get(this.constructor.rawAttributes[versionAttr], "field") || versionAttr;
              values = Utils.mapValueFieldNames(this.dataValues, options.fields, this.constructor);
              query = null;
              args = [];

              if (this.isNewRecord) {
                query = "insert";
                args = [this, this.constructor.getTableName(options), values, options];
              } else {
                where = this.where(true);

                if (versionAttr) {
                  values[versionFieldName] = parseInt(values[versionFieldName], 10) + 1;
                }

                query = "update";
                args = [this, this.constructor.getTableName(options), values, where, options];
              }

              _context4.next = 56;
              return regeneratorRuntime.awrap((_this$constructor$que = this.constructor.queryInterface)[query].apply(_this$constructor$que, _toConsumableArray(args)));

            case 56:
              _ref = _context4.sent;
              _ref2 = _slicedToArray(_ref, 2);
              result = _ref2[0];
              rowsUpdated = _ref2[1];

              if (!versionAttr) {
                _context4.next = 66;
                break;
              }

              if (!(rowsUpdated < 1)) {
                _context4.next = 65;
                break;
              }

              throw new sequelizeErrors.OptimisticLockError({
                modelName: this.constructor.name,
                values: values,
                where: where
              });

            case 65:
              result.dataValues[versionAttr] = values[versionFieldName];

            case 66:
              for (_i3 = 0, _Object$keys3 = Object.keys(this.constructor.rawAttributes); _i3 < _Object$keys3.length; _i3++) {
                attr = _Object$keys3[_i3];

                if (this.constructor.rawAttributes[attr].field && values[this.constructor.rawAttributes[attr].field] !== void 0 && this.constructor.rawAttributes[attr].field !== attr) {
                  values[attr] = values[this.constructor.rawAttributes[attr].field];
                  delete values[this.constructor.rawAttributes[attr].field];
                }
              }

              Object.assign(values, result.dataValues);
              Object.assign(result.dataValues, values);

              if (!(wasNewRecord && this._options.include && this._options.include.length)) {
                _context4.next = 72;
                break;
              }

              _context4.next = 72;
              return regeneratorRuntime.awrap(Promise.all(this._options.include.filter(function (include) {
                return !(include.association instanceof BelongsTo || include.parent && include.parent.association instanceof BelongsToMany);
              }).map(function _callee3(include) {
                var instances, includeOptions;
                return regeneratorRuntime.async(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        instances = _this5.get(include.as);

                        if (instances) {
                          _context3.next = 3;
                          break;
                        }

                        return _context3.abrupt("return");

                      case 3:
                        if (!Array.isArray(instances)) instances = [instances];
                        includeOptions = _(Utils.cloneDeep(include)).omit(["association"]).defaults({
                          transaction: options.transaction,
                          logging: options.logging,
                          parentRecord: _this5
                        }).value();
                        _context3.next = 7;
                        return regeneratorRuntime.awrap(Promise.all(instances.map(function _callee2(instance) {
                          var _spreadValues, values0, _i4, _Object$keys4, attr;

                          return regeneratorRuntime.async(function _callee2$(_context2) {
                            while (1) {
                              switch (_context2.prev = _context2.next) {
                                case 0:
                                  if (!(include.association instanceof BelongsToMany)) {
                                    _context2.next = 18;
                                    break;
                                  }

                                  _context2.next = 3;
                                  return regeneratorRuntime.awrap(instance.save(includeOptions));

                                case 3:
                                  values0 = __spreadValues((_spreadValues = {}, _defineProperty(_spreadValues, include.association.foreignKey, _this5.get(_this5.constructor.primaryKeyAttribute, {
                                    raw: true
                                  })), _defineProperty(_spreadValues, include.association.otherKey, instance.get(instance.constructor.primaryKeyAttribute, {
                                    raw: true
                                  })), _spreadValues), include.association.through.scope);

                                  if (!instance[include.association.through.model.name]) {
                                    _context2.next = 14;
                                    break;
                                  }

                                  _i4 = 0, _Object$keys4 = Object.keys(include.association.through.model.rawAttributes);

                                case 6:
                                  if (!(_i4 < _Object$keys4.length)) {
                                    _context2.next = 14;
                                    break;
                                  }

                                  attr = _Object$keys4[_i4];

                                  if (!(include.association.through.model.rawAttributes[attr]._autoGenerated || attr === include.association.foreignKey || attr === include.association.otherKey || typeof instance[include.association.through.model.name][attr] === "undefined")) {
                                    _context2.next = 10;
                                    break;
                                  }

                                  return _context2.abrupt("continue", 11);

                                case 10:
                                  values0[attr] = instance[include.association.through.model.name][attr];

                                case 11:
                                  _i4++;
                                  _context2.next = 6;
                                  break;

                                case 14:
                                  _context2.next = 16;
                                  return regeneratorRuntime.awrap(include.association.throughModel.create(values0, includeOptions));

                                case 16:
                                  _context2.next = 22;
                                  break;

                                case 18:
                                  instance.set(include.association.foreignKey, _this5.get(include.association.sourceKey || _this5.constructor.primaryKeyAttribute, {
                                    raw: true
                                  }), {
                                    raw: true
                                  });
                                  Object.assign(instance, include.association.scope);
                                  _context2.next = 22;
                                  return regeneratorRuntime.awrap(instance.save(includeOptions));

                                case 22:
                                case "end":
                                  return _context2.stop();
                              }
                            }
                          });
                        })));

                      case 7:
                      case "end":
                        return _context3.stop();
                    }
                  }
                });
              })));

            case 72:
              if (!options.hooks) {
                _context4.next = 75;
                break;
              }

              _context4.next = 75;
              return regeneratorRuntime.awrap(this.constructor.runHooks("after".concat(hook), result, options));

            case 75:
              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context4.prev = 78;

              for (_iterator3 = options.fields[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                field = _step3.value;
                result._previousDataValues[field] = result.dataValues[field];
                this.changed(field, false);
              }

              _context4.next = 86;
              break;

            case 82:
              _context4.prev = 82;
              _context4.t0 = _context4["catch"](78);
              _didIteratorError3 = true;
              _iteratorError3 = _context4.t0;

            case 86:
              _context4.prev = 86;
              _context4.prev = 87;

              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }

            case 89:
              _context4.prev = 89;

              if (!_didIteratorError3) {
                _context4.next = 92;
                break;
              }

              throw _iteratorError3;

            case 92:
              return _context4.finish(89);

            case 93:
              return _context4.finish(86);

            case 94:
              this.isNewRecord = false;
              return _context4.abrupt("return", result);

            case 96:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this, [[78, 82, 86, 94], [87,, 89, 93]]);
    }
  }, {
    key: "reload",
    value: function reload(options) {
      var reloaded;
      return regeneratorRuntime.async(function reload$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              options = Utils.defaults({
                where: this.where()
              }, options, {
                include: this._options.include || void 0
              });
              _context5.next = 3;
              return regeneratorRuntime.awrap(this.constructor.findOne(options));

            case 3:
              reloaded = _context5.sent;

              if (reloaded) {
                _context5.next = 6;
                break;
              }

              throw new sequelizeErrors.InstanceError("Instance could not be reloaded because it does not exist anymore (find call returned null)");

            case 6:
              this._options = reloaded._options;
              this.set(reloaded.dataValues, {
                raw: true,
                reset: !options.attributes
              });
              return _context5.abrupt("return", this);

            case 9:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "validate",
    value: function validate(options) {
      return regeneratorRuntime.async(function validate$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", new InstanceValidator(this, options).validate());

            case 1:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "update",
    value: function update(values, options) {
      var changedBefore, t, setOptions, sideEffects, fields;
      return regeneratorRuntime.async(function update$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              values = _.omitBy(values, function (value) {
                return value === void 0;
              });
              changedBefore = this.changed() || [];
              options = options || {};
              if (Array.isArray(options)) options = {
                fields: options
              };
              options = Utils.cloneDeep(options);

              if (options.transaction === void 0 && this.sequelize.constructor._cls) {
                t = this.sequelize.constructor._cls.get("transaction");

                if (t) {
                  options.transaction = t;
                }
              }

              setOptions = Utils.cloneDeep(options);
              setOptions.attributes = options.fields;
              this.set(values, setOptions);
              sideEffects = _.without.apply(_, [this.changed()].concat(_toConsumableArray(changedBefore)));
              fields = _.union(Object.keys(values), sideEffects);

              if (!options.fields) {
                options.fields = _.intersection(fields, this.changed());
                options.defaultFields = options.fields;
              }

              _context7.next = 14;
              return regeneratorRuntime.awrap(this.save(options));

            case 14:
              return _context7.abrupt("return", _context7.sent);

            case 15:
            case "end":
              return _context7.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "destroy",
    value: function destroy(options) {
      var t, where, result, attributeName, attribute, defaultValue, currentValue, undefinedOrNull;
      return regeneratorRuntime.async(function destroy$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              options = __spreadValues({
                hooks: true,
                force: false
              }, options);

              if (options.transaction === void 0 && this.sequelize.constructor._cls) {
                t = this.sequelize.constructor._cls.get("transaction");

                if (t) {
                  options.transaction = t;
                }
              }

              if (!options.hooks) {
                _context8.next = 5;
                break;
              }

              _context8.next = 5;
              return regeneratorRuntime.awrap(this.constructor.runHooks("beforeDestroy", this, options));

            case 5:
              where = this.where(true);

              if (!(this.constructor._timestampAttributes.deletedAt && options.force === false)) {
                _context8.next = 18;
                break;
              }

              attributeName = this.constructor._timestampAttributes.deletedAt;
              attribute = this.constructor.rawAttributes[attributeName];
              defaultValue = Object.prototype.hasOwnProperty.call(attribute, "defaultValue") ? attribute.defaultValue : null;
              currentValue = this.getDataValue(attributeName);
              undefinedOrNull = currentValue == null && defaultValue == null;

              if (undefinedOrNull || _.isEqual(currentValue, defaultValue)) {
                this.setDataValue(attributeName, new Date());
              }

              _context8.next = 15;
              return regeneratorRuntime.awrap(this.save(__spreadProps(__spreadValues({}, options), {
                hooks: false
              })));

            case 15:
              result = _context8.sent;
              _context8.next = 21;
              break;

            case 18:
              _context8.next = 20;
              return regeneratorRuntime.awrap(this.constructor.queryInterface["delete"](this, this.constructor.getTableName(options), where, __spreadValues({
                type: QueryTypes.DELETE,
                limit: null
              }, options)));

            case 20:
              result = _context8.sent;

            case 21:
              if (!options.hooks) {
                _context8.next = 24;
                break;
              }

              _context8.next = 24;
              return regeneratorRuntime.awrap(this.constructor.runHooks("afterDestroy", this, options));

            case 24:
              return _context8.abrupt("return", result);

            case 25:
            case "end":
              return _context8.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "isSoftDeleted",
    value: function isSoftDeleted() {
      if (!this.constructor._timestampAttributes.deletedAt) {
        throw new Error("Model is not paranoid");
      }

      var deletedAtAttribute = this.constructor.rawAttributes[this.constructor._timestampAttributes.deletedAt];
      var defaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, "defaultValue") ? deletedAtAttribute.defaultValue : null;
      var deletedAt = this.get(this.constructor._timestampAttributes.deletedAt) || null;
      var isSet = deletedAt !== defaultValue;
      return isSet;
    }
  }, {
    key: "restore",
    value: function restore(options) {
      var t, deletedAtCol, deletedAtAttribute, deletedAtDefaultValue, result;
      return regeneratorRuntime.async(function restore$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (this.constructor._timestampAttributes.deletedAt) {
                _context9.next = 2;
                break;
              }

              throw new Error("Model is not paranoid");

            case 2:
              options = __spreadValues({
                hooks: true,
                force: false
              }, options);

              if (options.transaction === void 0 && this.sequelize.constructor._cls) {
                t = this.sequelize.constructor._cls.get("transaction");

                if (t) {
                  options.transaction = t;
                }
              }

              if (!options.hooks) {
                _context9.next = 7;
                break;
              }

              _context9.next = 7;
              return regeneratorRuntime.awrap(this.constructor.runHooks("beforeRestore", this, options));

            case 7:
              deletedAtCol = this.constructor._timestampAttributes.deletedAt;
              deletedAtAttribute = this.constructor.rawAttributes[deletedAtCol];
              deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, "defaultValue") ? deletedAtAttribute.defaultValue : null;
              this.setDataValue(deletedAtCol, deletedAtDefaultValue);
              _context9.next = 13;
              return regeneratorRuntime.awrap(this.save(__spreadProps(__spreadValues({}, options), {
                hooks: false,
                omitNull: false
              })));

            case 13:
              result = _context9.sent;

              if (!options.hooks) {
                _context9.next = 18;
                break;
              }

              _context9.next = 17;
              return regeneratorRuntime.awrap(this.constructor.runHooks("afterRestore", this, options));

            case 17:
              return _context9.abrupt("return", result);

            case 18:
              return _context9.abrupt("return", result);

            case 19:
            case "end":
              return _context9.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "increment",
    value: function increment(fields, options) {
      var identifier;
      return regeneratorRuntime.async(function increment$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              identifier = this.where();
              options = Utils.cloneDeep(options);
              options.where = __spreadValues(__spreadValues({}, options.where), identifier);
              options.instance = this;
              _context10.next = 6;
              return regeneratorRuntime.awrap(this.constructor.increment(fields, options));

            case 6:
              return _context10.abrupt("return", this);

            case 7:
            case "end":
              return _context10.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "decrement",
    value: function decrement(fields, options) {
      return regeneratorRuntime.async(function decrement$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              return _context11.abrupt("return", this.increment(fields, __spreadProps(__spreadValues({
                by: 1
              }, options), {
                increment: false
              })));

            case 1:
            case "end":
              return _context11.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "equals",
    value: function equals(other) {
      var _this6 = this;

      if (!other || !other.constructor) {
        return false;
      }

      if (!(other instanceof this.constructor)) {
        return false;
      }

      return this.constructor.primaryKeyAttributes.every(function (attribute) {
        return _this6.get(attribute, {
          raw: true
        }) === other.get(attribute, {
          raw: true
        });
      });
    }
  }, {
    key: "equalsOneOf",
    value: function equalsOneOf(others) {
      var _this7 = this;

      return others.some(function (other) {
        return _this7.equals(other);
      });
    }
  }, {
    key: "setValidators",
    value: function setValidators(attribute, validators) {
      this.validators[attribute] = validators;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return _.cloneDeep(this.get({
        plain: true
      }));
    }
  }], [{
    key: "_paranoidClause",
    value: function _paranoidClause(model) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options.include) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = options.include[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var include = _step4.value;

            this._paranoidClause(include.model, include);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }

      if (_.get(options, "groupedLimit.on.options.paranoid")) {
        var throughModel = _.get(options, "groupedLimit.on.through.model");

        if (throughModel) {
          options.groupedLimit.through = this._paranoidClause(throughModel, options.groupedLimit.through);
        }
      }

      if (!model.options.timestamps || !model.options.paranoid || options.paranoid === false) {
        return options;
      }

      var deletedAtCol = model._timestampAttributes.deletedAt;
      var deletedAtAttribute = model.rawAttributes[deletedAtCol];
      var deletedAtObject = {};
      var deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, "defaultValue") ? deletedAtAttribute.defaultValue : null;
      deletedAtDefaultValue = deletedAtDefaultValue || _defineProperty({}, Op.eq, null);
      deletedAtObject[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;

      if (Utils.isWhereEmpty(options.where)) {
        options.where = deletedAtObject;
      } else {
        options.where = _defineProperty({}, Op.and, [deletedAtObject, options.where]);
      }

      return options;
    }
  }, {
    key: "_addDefaultAttributes",
    value: function _addDefaultAttributes() {
      var tail = {};
      var head = {};

      if (!_.some(this.rawAttributes, "primaryKey")) {
        if ("id" in this.rawAttributes) {
          throw new Error("A column called 'id' was added to the attributes of '".concat(this.tableName, "' but not marked with 'primaryKey: true'"));
        }

        head = {
          id: {
            type: new DataTypes.INTEGER(),
            allowNull: false,
            primaryKey: true,
            autoIncrement: true,
            _autoGenerated: true
          }
        };
      }

      if (this._timestampAttributes.createdAt) {
        tail[this._timestampAttributes.createdAt] = {
          type: DataTypes.DATE,
          allowNull: false,
          _autoGenerated: true
        };
      }

      if (this._timestampAttributes.updatedAt) {
        tail[this._timestampAttributes.updatedAt] = {
          type: DataTypes.DATE,
          allowNull: false,
          _autoGenerated: true
        };
      }

      if (this._timestampAttributes.deletedAt) {
        tail[this._timestampAttributes.deletedAt] = {
          type: DataTypes.DATE,
          _autoGenerated: true
        };
      }

      if (this._versionAttribute) {
        tail[this._versionAttribute] = {
          type: DataTypes.INTEGER,
          allowNull: false,
          defaultValue: 0,
          _autoGenerated: true
        };
      }

      var newRawAttributes = __spreadValues(__spreadValues({}, head), this.rawAttributes);

      _.each(tail, function (value, attr) {
        if (newRawAttributes[attr] === void 0) {
          newRawAttributes[attr] = value;
        }
      });

      this.rawAttributes = newRawAttributes;

      if (!Object.keys(this.primaryKeys).length) {
        this.primaryKeys.id = this.rawAttributes.id;
      }
    }
  }, {
    key: "getAttributes",
    value: function getAttributes() {
      return this.rawAttributes;
    }
  }, {
    key: "_findAutoIncrementAttribute",
    value: function _findAutoIncrementAttribute() {
      this.autoIncrementAttribute = null;

      for (var name in this.rawAttributes) {
        if (Object.prototype.hasOwnProperty.call(this.rawAttributes, name)) {
          var definition = this.rawAttributes[name];

          if (definition && definition.autoIncrement) {
            if (this.autoIncrementAttribute) {
              throw new Error("Invalid Instance definition. Only one autoincrement field allowed.");
            }

            this.autoIncrementAttribute = name;
          }
        }
      }
    }
  }, {
    key: "_conformIncludes",
    value: function _conformIncludes(options, self) {
      var _this8 = this;

      if (!options.include) return;

      if (!Array.isArray(options.include)) {
        options.include = [options.include];
      } else if (!options.include.length) {
        delete options.include;
        return;
      }

      options.include = options.include.map(function (include) {
        return _this8._conformInclude(include, self);
      });
    }
  }, {
    key: "_transformStringAssociation",
    value: function _transformStringAssociation(include, self) {
      if (self && typeof include === "string") {
        if (!Object.prototype.hasOwnProperty.call(self.associations, include)) {
          throw new Error("Association with alias \"".concat(include, "\" does not exist on ").concat(self.name));
        }

        return self.associations[include];
      }

      return include;
    }
  }, {
    key: "_conformInclude",
    value: function _conformInclude(include, self) {
      if (include) {
        var model;
        if (include._pseudo) return include;
        include = this._transformStringAssociation(include, self);

        if (include instanceof Association) {
          if (self && include.target.name === self.name) {
            model = include.source;
          } else {
            model = include.target;
          }

          return {
            model: model,
            association: include,
            as: include.as
          };
        }

        if (include.prototype && include.prototype instanceof Model) {
          return {
            model: include
          };
        }

        if (_.isPlainObject(include)) {
          if (include.association) {
            include.association = this._transformStringAssociation(include.association, self);

            if (self && include.association.target.name === self.name) {
              model = include.association.source;
            } else {
              model = include.association.target;
            }

            if (!include.model) include.model = model;
            if (!include.as) include.as = include.association.as;

            this._conformIncludes(include, model);

            return include;
          }

          if (include.model) {
            this._conformIncludes(include, include.model);

            return include;
          }

          if (include.all) {
            this._conformIncludes(include);

            return include;
          }
        }
      }

      throw new Error("Include unexpected. Element has to be either a Model, an Association or an object.");
    }
  }, {
    key: "_expandIncludeAllElement",
    value: function _expandIncludeAllElement(includes, include) {
      var all = include.all;
      delete include.all;

      if (all !== true) {
        if (!Array.isArray(all)) {
          all = [all];
        }

        var validTypes = {
          BelongsTo: true,
          HasOne: true,
          HasMany: true,
          One: ["BelongsTo", "HasOne"],
          Has: ["HasOne", "HasMany"],
          Many: ["HasMany"]
        };

        for (var i = 0; i < all.length; i++) {
          var type = all[i];

          if (type === "All") {
            all = true;
            break;
          }

          var types = validTypes[type];

          if (!types) {
            throw new sequelizeErrors.EagerLoadingError("include all '".concat(type, "' is not valid - must be BelongsTo, HasOne, HasMany, One, Has, Many or All"));
          }

          if (types !== true) {
            all.splice(i, 1);
            i--;

            for (var j = 0; j < types.length; j++) {
              if (!all.includes(types[j])) {
                all.unshift(types[j]);
                i++;
              }
            }
          }
        }
      }

      var nested = include.nested;

      if (nested) {
        delete include.nested;

        if (!include.include) {
          include.include = [];
        } else if (!Array.isArray(include.include)) {
          include.include = [include.include];
        }
      }

      var used = [];

      (function addAllIncludes(parent, includes2) {
        _.forEach(parent.associations, function (association) {
          if (all !== true && !all.includes(association.associationType)) {
            return;
          }

          var model = association.target;
          var as = association.options.as;
          var predicate = {
            model: model
          };

          if (as) {
            predicate.as = as;
          }

          if (_.some(includes2, predicate)) {
            return;
          }

          if (nested && used.includes(model)) {
            return;
          }

          used.push(parent);
          var thisInclude = Utils.cloneDeep(include);
          thisInclude.model = model;

          if (as) {
            thisInclude.as = as;
          }

          includes2.push(thisInclude);

          if (nested) {
            addAllIncludes(model, thisInclude.include);
            if (thisInclude.include.length === 0) delete thisInclude.include;
          }
        });

        used.pop();
      })(this, includes);
    }
  }, {
    key: "_validateIncludedElements",
    value: function _validateIncludedElements(options, tableNames) {
      var _this9 = this;

      if (!options.model) options.model = this;
      tableNames = tableNames || {};
      options.includeNames = [];
      options.includeMap = {};
      options.hasSingleAssociation = false;
      options.hasMultiAssociation = false;

      if (!options.parent) {
        options.topModel = options.model;
        options.topLimit = options.limit;
      }

      options.include = options.include.map(function (include) {
        include = _this9._conformInclude(include);
        include.parent = options;
        include.topLimit = options.topLimit;

        _this9._validateIncludedElement.call(options.model, include, tableNames, options);

        if (include.duplicating === void 0) {
          include.duplicating = include.association.isMultiAssociation;
        }

        include.hasDuplicating = include.hasDuplicating || include.duplicating;
        include.hasRequired = include.hasRequired || include.required;
        options.hasDuplicating = options.hasDuplicating || include.hasDuplicating;
        options.hasRequired = options.hasRequired || include.required;
        options.hasWhere = options.hasWhere || include.hasWhere || !!include.where;
        return include;
      });
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = options.include[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var include = _step5.value;
          include.hasParentWhere = options.hasParentWhere || !!options.where;
          include.hasParentRequired = options.hasParentRequired || !!options.required;

          if (include.subQuery !== false && options.hasDuplicating && options.topLimit) {
            if (include.duplicating) {
              include.subQuery = include.subQuery || false;
              include.subQueryFilter = include.hasRequired;
            } else {
              include.subQuery = include.hasRequired;
              include.subQueryFilter = false;
            }
          } else {
            include.subQuery = include.subQuery || false;

            if (include.duplicating) {
              include.subQueryFilter = include.subQuery;
            } else {
              include.subQueryFilter = false;
              include.subQuery = include.subQuery || include.hasParentRequired && include.hasRequired && !include.separate;
            }
          }

          options.includeMap[include.as] = include;
          options.includeNames.push(include.as);

          if (options.topModel === options.model && options.subQuery === void 0 && options.topLimit) {
            if (include.subQuery) {
              options.subQuery = include.subQuery;
            } else if (include.hasDuplicating) {
              options.subQuery = true;
            }
          }

          options.hasIncludeWhere = options.hasIncludeWhere || include.hasIncludeWhere || !!include.where;
          options.hasIncludeRequired = options.hasIncludeRequired || include.hasIncludeRequired || !!include.required;

          if (include.association.isMultiAssociation || include.hasMultiAssociation) {
            options.hasMultiAssociation = true;
          }

          if (include.association.isSingleAssociation || include.hasSingleAssociation) {
            options.hasSingleAssociation = true;
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      if (options.topModel === options.model && options.subQuery === void 0) {
        options.subQuery = false;
      }

      return options;
    }
  }, {
    key: "_validateIncludedElement",
    value: function _validateIncludedElement(include, tableNames, options) {
      tableNames[include.model.getTableName()] = true;

      if (include.attributes && !options.raw) {
        include.model._expandAttributes(include);

        include.originalAttributes = include.model._injectDependentVirtualAttributes(include.attributes);
        include = Utils.mapFinderOptions(include, include.model);

        if (include.attributes.length) {
          _.each(include.model.primaryKeys, function (attr, key) {
            if (!include.attributes.some(function (includeAttr) {
              if (attr.field !== key) {
                return Array.isArray(includeAttr) && includeAttr[0] === attr.field && includeAttr[1] === key;
              }

              return includeAttr === key;
            })) {
              include.attributes.unshift(key);
            }
          });
        }
      } else {
        include = Utils.mapFinderOptions(include, include.model);
      }

      if (include._pseudo) {
        if (!include.attributes) {
          include.attributes = Object.keys(include.model.tableAttributes);
        }

        return Utils.mapFinderOptions(include, include.model);
      }

      var association = include.association || this._getIncludedAssociation(include.model, include.as);

      include.association = association;
      include.as = association.as;

      if (include.association.through && Object(include.association.through.model) === include.association.through.model) {
        if (!include.include) include.include = [];
        var through = include.association.through;
        include.through = _.defaults(include.through || {}, {
          model: through.model,
          as: through.model.name,
          association: {
            isSingleAssociation: true
          },
          _pseudo: true,
          parent: include
        });

        if (through.scope) {
          include.through.where = include.through.where ? _defineProperty({}, Op.and, [include.through.where, through.scope]) : through.scope;
        }

        include.include.push(include.through);
        tableNames[through.tableName] = true;
      }

      var model;

      if (include.model.scoped === true) {
        model = include.model;
      } else {
        model = include.association.target.name === include.model.name ? include.association.target : include.association.source;
      }

      model._injectScope(include);

      if (!include.attributes) {
        include.attributes = Object.keys(include.model.tableAttributes);
      }

      include = Utils.mapFinderOptions(include, include.model);

      if (include.required === void 0) {
        include.required = !!include.where;
      }

      if (include.association.scope) {
        include.where = include.where ? _defineProperty({}, Op.and, [include.where, include.association.scope]) : include.association.scope;
      }

      if (include.limit && include.separate === void 0) {
        include.separate = true;
      }

      if (include.separate === true) {
        if (!(include.association instanceof HasMany)) {
          throw new Error("Only HasMany associations support include.separate");
        }

        include.duplicating = false;

        if (options.attributes && options.attributes.length && !_.flattenDepth(options.attributes, 2).includes(association.sourceKey)) {
          options.attributes.push(association.sourceKey);
        }

        if (include.attributes && include.attributes.length && !_.flattenDepth(include.attributes, 2).includes(association.foreignKey)) {
          include.attributes.push(association.foreignKey);
        }
      }

      if (Object.prototype.hasOwnProperty.call(include, "include")) {
        this._validateIncludedElements.call(include.model, include, tableNames);
      }

      return include;
    }
  }, {
    key: "_getIncludedAssociation",
    value: function _getIncludedAssociation(targetModel, targetAlias) {
      var associations = this.getAssociations(targetModel);
      var association = null;

      if (associations.length === 0) {
        throw new sequelizeErrors.EagerLoadingError("".concat(targetModel.name, " is not associated to ").concat(this.name, "!"));
      }

      if (associations.length === 1) {
        association = this.getAssociationForAlias(targetModel, targetAlias);

        if (association) {
          return association;
        }

        if (targetAlias) {
          var existingAliases = this.getAssociations(targetModel).map(function (association2) {
            return association2.as;
          });
          throw new sequelizeErrors.EagerLoadingError("".concat(targetModel.name, " is associated to ").concat(this.name, " using an alias. You've included an alias (").concat(targetAlias, "), but it does not match the alias(es) defined in your association (").concat(existingAliases.join(", "), ")."));
        }

        throw new sequelizeErrors.EagerLoadingError("".concat(targetModel.name, " is associated to ").concat(this.name, " using an alias. You must use the 'as' keyword to specify the alias within your include statement."));
      }

      association = this.getAssociationForAlias(targetModel, targetAlias);

      if (!association) {
        throw new sequelizeErrors.EagerLoadingError("".concat(targetModel.name, " is associated to ").concat(this.name, " multiple times. To identify the correct association, you must use the 'as' keyword to specify the alias of the association you want to include."));
      }

      return association;
    }
  }, {
    key: "_expandIncludeAll",
    value: function _expandIncludeAll(options) {
      var _this10 = this;

      var includes = options.include;

      if (!includes) {
        return;
      }

      for (var index = 0; index < includes.length; index++) {
        var include = includes[index];

        if (include.all) {
          includes.splice(index, 1);
          index--;

          this._expandIncludeAllElement(includes, include);
        }
      }

      includes.forEach(function (include) {
        _this10._expandIncludeAll.call(include.model, include);
      });
    }
  }, {
    key: "_conformIndex",
    value: function _conformIndex(index) {
      if (!index.fields) {
        throw new Error('Missing "fields" property for index definition');
      }

      index = _.defaults(index, {
        type: "",
        parser: null
      });

      if (index.type && index.type.toLowerCase() === "unique") {
        index.unique = true;
        delete index.type;
      }

      return index;
    }
  }, {
    key: "_uniqIncludes",
    value: function _uniqIncludes(options) {
      var _this11 = this;

      if (!options.include) return;
      options.include = _(options.include).groupBy(function (include) {
        return "".concat(include.model && include.model.name, "-").concat(include.as);
      }).map(function (includes) {
        return _this11._assignOptions.apply(_this11, _toConsumableArray(includes));
      }).value();
    }
  }, {
    key: "_baseMerge",
    value: function _baseMerge() {
      _.assignWith.apply(_, arguments);

      this._conformIncludes(arguments.length <= 0 ? undefined : arguments[0], this);

      this._uniqIncludes(arguments.length <= 0 ? undefined : arguments[0]);

      return arguments.length <= 0 ? undefined : arguments[0];
    }
  }, {
    key: "_mergeFunction",
    value: function _mergeFunction(objValue, srcValue, key) {
      if (Array.isArray(objValue) && Array.isArray(srcValue)) {
        return _.union(objValue, srcValue);
      }

      if (["where", "having"].includes(key)) {
        if (this.options && this.options.whereMergeStrategy === "and") {
          return combineWheresWithAnd(objValue, srcValue);
        }

        if (srcValue instanceof Utils.SequelizeMethod) {
          srcValue = _defineProperty({}, Op.and, srcValue);
        }

        if (_.isPlainObject(objValue) && _.isPlainObject(srcValue)) {
          return Object.assign(objValue, srcValue);
        }
      } else if (key === "attributes" && _.isPlainObject(objValue) && _.isPlainObject(srcValue)) {
        return _.assignWith(objValue, srcValue, function (objValue2, srcValue2) {
          if (Array.isArray(objValue2) && Array.isArray(srcValue2)) {
            return _.union(objValue2, srcValue2);
          }
        });
      }

      if (srcValue) {
        return Utils.cloneDeep(srcValue, true);
      }

      return srcValue === void 0 ? objValue : srcValue;
    }
  }, {
    key: "_assignOptions",
    value: function _assignOptions() {
      for (var _len = arguments.length, args = new Array(_len), _key3 = 0; _key3 < _len; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this._baseMerge.apply(this, args.concat([this._mergeFunction.bind(this)]));
    }
  }, {
    key: "_defaultsOptions",
    value: function _defaultsOptions(target, opts) {
      var _this12 = this;

      return this._baseMerge(target, opts, function (srcValue, objValue, key) {
        return _this12._mergeFunction(objValue, srcValue, key);
      });
    }
  }, {
    key: "init",
    value: function init(attributes) {
      var _this13 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!options.sequelize) {
        throw new Error("No Sequelize instance passed");
      }

      this.sequelize = options.sequelize;
      var globalOptions = this.sequelize.options;
      options = Utils.merge(_.cloneDeep(globalOptions.define), options);

      if (!options.modelName) {
        options.modelName = this.name;
      }

      options = Utils.merge({
        name: {
          plural: Utils.pluralize(options.modelName),
          singular: Utils.singularize(options.modelName)
        },
        indexes: [],
        omitNull: globalOptions.omitNull,
        schema: globalOptions.schema
      }, options);
      this.sequelize.runHooks("beforeDefine", attributes, options);

      if (options.modelName !== this.name) {
        Object.defineProperty(this, "name", {
          value: options.modelName
        });
      }

      delete options.modelName;
      this.options = __spreadValues({
        timestamps: true,
        validate: {},
        freezeTableName: false,
        underscored: false,
        paranoid: false,
        rejectOnEmpty: false,
        whereCollection: null,
        schema: null,
        schemaDelimiter: "",
        defaultScope: {},
        scopes: {},
        indexes: [],
        whereMergeStrategy: "overwrite"
      }, options);

      if (this.sequelize.isDefined(this.name)) {
        this.sequelize.modelManager.removeModel(this.sequelize.modelManager.getModel(this.name));
      }

      this.associations = {};

      this._setupHooks(options.hooks);

      this.underscored = this.options.underscored;

      if (!this.options.tableName) {
        this.tableName = this.options.freezeTableName ? this.name : Utils.underscoredIf(Utils.pluralize(this.name), this.underscored);
      } else {
        this.tableName = this.options.tableName;
      }

      this._schema = this.options.schema;
      this._schemaDelimiter = this.options.schemaDelimiter;

      _.each(options.validate, function (validator, validatorType) {
        if (Object.prototype.hasOwnProperty.call(attributes, validatorType)) {
          throw new Error("A model validator function must not have the same name as a field. Model: ".concat(_this13.name, ", field/validation name: ").concat(validatorType));
        }

        if (typeof validator !== "function") {
          throw new Error("Members of the validate option must be functions. Model: ".concat(_this13.name, ", error with validate member ").concat(validatorType));
        }
      });

      if (!_.includes(["and", "overwrite"], this.options && this.options.whereMergeStrategy)) {
        throw new Error("Invalid value ".concat(this.options && this.options.whereMergeStrategy, " for whereMergeStrategy. Allowed values are 'and' and 'overwrite'."));
      }

      this.rawAttributes = _.mapValues(attributes, function (attribute, name) {
        attribute = _this13.sequelize.normalizeAttribute(attribute);

        if (attribute.type === void 0) {
          throw new Error("Unrecognized datatype for attribute \"".concat(_this13.name, ".").concat(name, "\""));
        }

        if (attribute.allowNull !== false && _.get(attribute, "validate.notNull")) {
          throw new Error("Invalid definition for \"".concat(_this13.name, ".").concat(name, "\", \"notNull\" validator is only allowed with \"allowNull:false\""));
        }

        if (_.get(attribute, "references.model.prototype") instanceof Model) {
          attribute.references.model = attribute.references.model.getTableName();
        }

        return attribute;
      });
      var tableName = this.getTableName();
      this._indexes = this.options.indexes.map(function (index) {
        return Utils.nameIndex(_this13._conformIndex(index), tableName);
      });
      this.primaryKeys = {};
      this._readOnlyAttributes =
      /* @__PURE__ */
      new Set();
      this._timestampAttributes = {};

      if (this.options.timestamps) {
        for (var _i5 = 0, _arr2 = ["createdAt", "updatedAt", "deletedAt"]; _i5 < _arr2.length; _i5++) {
          var key = _arr2[_i5];

          if (!["undefined", "string", "boolean"].includes(_typeof(this.options[key]))) {
            throw new Error("Value for \"".concat(key, "\" option must be a string or a boolean, got ").concat(_typeof(this.options[key])));
          }

          if (this.options[key] === "") {
            throw new Error("Value for \"".concat(key, "\" option cannot be an empty string"));
          }
        }

        if (this.options.createdAt !== false) {
          this._timestampAttributes.createdAt = typeof this.options.createdAt === "string" ? this.options.createdAt : "createdAt";

          this._readOnlyAttributes.add(this._timestampAttributes.createdAt);
        }

        if (this.options.updatedAt !== false) {
          this._timestampAttributes.updatedAt = typeof this.options.updatedAt === "string" ? this.options.updatedAt : "updatedAt";

          this._readOnlyAttributes.add(this._timestampAttributes.updatedAt);
        }

        if (this.options.paranoid && this.options.deletedAt !== false) {
          this._timestampAttributes.deletedAt = typeof this.options.deletedAt === "string" ? this.options.deletedAt : "deletedAt";

          this._readOnlyAttributes.add(this._timestampAttributes.deletedAt);
        }
      }

      if (this.options.version) {
        this._versionAttribute = typeof this.options.version === "string" ? this.options.version : "version";

        this._readOnlyAttributes.add(this._versionAttribute);
      }

      this._hasReadOnlyAttributes = this._readOnlyAttributes.size > 0;

      this._addDefaultAttributes();

      this.refreshAttributes();

      this._findAutoIncrementAttribute();

      this._scope = this.options.defaultScope;
      this._scopeNames = ["defaultScope"];
      this.sequelize.modelManager.addModel(this);
      this.sequelize.runHooks("afterDefine", this);
      return this;
    }
  }, {
    key: "refreshAttributes",
    value: function refreshAttributes() {
      var _this14 = this;

      var attributeManipulation = {};
      this.prototype._customGetters = {};
      this.prototype._customSetters = {};
      ["get", "set"].forEach(function (type) {
        var opt = "".concat(type, "terMethods");

        var funcs = __spreadValues({}, _this14.options[opt]);

        var _custom = type === "get" ? _this14.prototype._customGetters : _this14.prototype._customSetters;

        _.each(funcs, function (method, attribute) {
          _custom[attribute] = method;

          if (type === "get") {
            funcs[attribute] = function () {
              return this.get(attribute);
            };
          }

          if (type === "set") {
            funcs[attribute] = function (value) {
              return this.set(attribute, value);
            };
          }
        });

        _.each(_this14.rawAttributes, function (options, attribute) {
          if (Object.prototype.hasOwnProperty.call(options, type)) {
            _custom[attribute] = options[type];
          }

          if (type === "get") {
            funcs[attribute] = function () {
              return this.get(attribute);
            };
          }

          if (type === "set") {
            funcs[attribute] = function (value) {
              return this.set(attribute, value);
            };
          }
        });

        _.each(funcs, function (fct, name) {
          if (!attributeManipulation[name]) {
            attributeManipulation[name] = {
              configurable: true
            };
          }

          attributeManipulation[name][type] = fct;
        });
      });
      this._dataTypeChanges = {};
      this._dataTypeSanitizers = {};
      this._hasBooleanAttributes = false;
      this._hasDateAttributes = false;
      this._jsonAttributes =
      /* @__PURE__ */
      new Set();
      this._virtualAttributes =
      /* @__PURE__ */
      new Set();
      this._defaultValues = {};
      this.prototype.validators = {};
      this.fieldRawAttributesMap = {};
      this.primaryKeys = {};
      this.uniqueKeys = {};

      _.each(this.rawAttributes, function (definition, name) {
        definition.type = _this14.sequelize.normalizeDataType(definition.type);
        definition.Model = _this14;
        definition.fieldName = name;
        definition._modelAttribute = true;

        if (definition.field === void 0) {
          definition.field = Utils.underscoredIf(name, _this14.underscored);
        }

        if (definition.primaryKey === true) {
          _this14.primaryKeys[name] = definition;
        }

        _this14.fieldRawAttributesMap[definition.field] = definition;

        if (definition.type._sanitize) {
          _this14._dataTypeSanitizers[name] = definition.type._sanitize;
        }

        if (definition.type._isChanged) {
          _this14._dataTypeChanges[name] = definition.type._isChanged;
        }

        if (definition.type instanceof DataTypes.BOOLEAN) {
          _this14._hasBooleanAttributes = true;
        } else if (definition.type instanceof DataTypes.DATE || definition.type instanceof DataTypes.DATEONLY) {
          _this14._hasDateAttributes = true;
        } else if (definition.type instanceof DataTypes.JSON) {
          _this14._jsonAttributes.add(name);
        } else if (definition.type instanceof DataTypes.VIRTUAL) {
          _this14._virtualAttributes.add(name);
        }

        if (Object.prototype.hasOwnProperty.call(definition, "defaultValue")) {
          _this14._defaultValues[name] = function () {
            return Utils.toDefaultValue(definition.defaultValue, _this14.sequelize.options.dialect);
          };
        }

        if (Object.prototype.hasOwnProperty.call(definition, "unique") && definition.unique) {
          var idxName;

          if (_typeof(definition.unique) === "object" && Object.prototype.hasOwnProperty.call(definition.unique, "name")) {
            idxName = definition.unique.name;
          } else if (typeof definition.unique === "string") {
            idxName = definition.unique;
          } else {
            idxName = "".concat(_this14.tableName, "_").concat(name, "_unique");
          }

          var idx = _this14.uniqueKeys[idxName] || {
            fields: []
          };
          idx.fields.push(definition.field);
          idx.msg = idx.msg || definition.unique.msg || null;
          idx.name = idxName || false;
          idx.column = name;
          idx.customIndex = definition.unique !== true;
          _this14.uniqueKeys[idxName] = idx;
        }

        if (Object.prototype.hasOwnProperty.call(definition, "validate")) {
          _this14.prototype.validators[name] = definition.validate;
        }

        if (definition.index === true && definition.type instanceof DataTypes.JSONB) {
          _this14._indexes.push(Utils.nameIndex(_this14._conformIndex({
            fields: [definition.field || name],
            using: "gin"
          }), _this14.getTableName()));

          delete definition.index;
        }
      });

      this.fieldAttributeMap = _.reduce(this.fieldRawAttributesMap, function (map, value, key) {
        if (key !== value.fieldName) {
          map[key] = value.fieldName;
        }

        return map;
      }, {});
      this._hasJsonAttributes = !!this._jsonAttributes.size;
      this._hasVirtualAttributes = !!this._virtualAttributes.size;
      this._hasDefaultValues = !_.isEmpty(this._defaultValues);
      this.tableAttributes = _.omitBy(this.rawAttributes, function (_a, key) {
        return _this14._virtualAttributes.has(key);
      });
      this.prototype._hasCustomGetters = Object.keys(this.prototype._customGetters).length;
      this.prototype._hasCustomSetters = Object.keys(this.prototype._customSetters).length;

      for (var _i6 = 0, _Object$keys5 = Object.keys(attributeManipulation); _i6 < _Object$keys5.length; _i6++) {
        var key = _Object$keys5[_i6];

        if (Object.prototype.hasOwnProperty.call(Model.prototype, key)) {
          this.sequelize.log("Not overriding built-in method from model attribute: ".concat(key));
          continue;
        }

        Object.defineProperty(this.prototype, key, attributeManipulation[key]);
      }

      this.prototype.rawAttributes = this.rawAttributes;

      this.prototype._isAttribute = function (key) {
        return Object.prototype.hasOwnProperty.call(_this14.prototype.rawAttributes, key);
      };

      this.primaryKeyAttributes = Object.keys(this.primaryKeys);
      this.primaryKeyAttribute = this.primaryKeyAttributes[0];

      if (this.primaryKeyAttribute) {
        this.primaryKeyField = this.rawAttributes[this.primaryKeyAttribute].field || this.primaryKeyAttribute;
      }

      this._hasPrimaryKeys = this.primaryKeyAttributes.length > 0;

      this._isPrimaryKey = function (key) {
        return _this14.primaryKeyAttributes.includes(key);
      };

      this._attributeManipulation = attributeManipulation;
    }
  }, {
    key: "removeAttribute",
    value: function removeAttribute(attribute) {
      delete this.rawAttributes[attribute];
      this.refreshAttributes();
    }
  }, {
    key: "sync",
    value: function sync(options) {
      var _this15 = this;

      var attributes, rawAttributes, tableName, tableExists, tableInfos, columns, foreignKeyReferences, removedConstraints, columnName, _columnName, currentAttribute, references, database, schema, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, foreignKeyReference, constraintName, existingIndexes, missingIndexes, _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, index;

      return regeneratorRuntime.async(function sync$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              options = __spreadValues(__spreadValues({}, this.options), options);
              options.hooks = options.hooks === void 0 ? true : !!options.hooks;
              attributes = this.tableAttributes;
              rawAttributes = this.fieldRawAttributesMap;

              if (!options.hooks) {
                _context12.next = 7;
                break;
              }

              _context12.next = 7;
              return regeneratorRuntime.awrap(this.runHooks("beforeSync", options));

            case 7:
              tableName = this.getTableName(options);

              if (!options.force) {
                _context12.next = 14;
                break;
              }

              _context12.next = 11;
              return regeneratorRuntime.awrap(this.drop(options));

            case 11:
              tableExists = false;
              _context12.next = 17;
              break;

            case 14:
              _context12.next = 16;
              return regeneratorRuntime.awrap(this.queryInterface.tableExists(tableName, options));

            case 16:
              tableExists = _context12.sent;

            case 17:
              if (tableExists) {
                _context12.next = 22;
                break;
              }

              _context12.next = 20;
              return regeneratorRuntime.awrap(this.queryInterface.createTable(tableName, attributes, options, this));

            case 20:
              _context12.next = 24;
              break;

            case 22:
              _context12.next = 24;
              return regeneratorRuntime.awrap(this.queryInterface.ensureEnums(tableName, attributes, options, this));

            case 24:
              if (!(tableExists && options.alter)) {
                _context12.next = 91;
                break;
              }

              _context12.next = 27;
              return regeneratorRuntime.awrap(Promise.all([this.queryInterface.describeTable(tableName, options), this.queryInterface.getForeignKeyReferencesForTable(tableName, options)]));

            case 27:
              tableInfos = _context12.sent;
              columns = tableInfos[0];
              foreignKeyReferences = tableInfos[1];
              removedConstraints = {};
              _context12.t0 = regeneratorRuntime.keys(attributes);

            case 32:
              if ((_context12.t1 = _context12.t0()).done) {
                _context12.next = 41;
                break;
              }

              columnName = _context12.t1.value;

              if (Object.prototype.hasOwnProperty.call(attributes, columnName)) {
                _context12.next = 36;
                break;
              }

              return _context12.abrupt("continue", 32);

            case 36:
              if (!(!columns[columnName] && !columns[attributes[columnName].field])) {
                _context12.next = 39;
                break;
              }

              _context12.next = 39;
              return regeneratorRuntime.awrap(this.queryInterface.addColumn(tableName, attributes[columnName].field || columnName, attributes[columnName], options));

            case 39:
              _context12.next = 32;
              break;

            case 41:
              if (!(options.alter === true || _typeof(options.alter) === "object" && options.alter.drop !== false)) {
                _context12.next = 91;
                break;
              }

              _context12.t2 = regeneratorRuntime.keys(columns);

            case 43:
              if ((_context12.t3 = _context12.t2()).done) {
                _context12.next = 91;
                break;
              }

              _columnName = _context12.t3.value;

              if (Object.prototype.hasOwnProperty.call(columns, _columnName)) {
                _context12.next = 47;
                break;
              }

              return _context12.abrupt("continue", 43);

            case 47:
              currentAttribute = rawAttributes[_columnName];

              if (currentAttribute) {
                _context12.next = 52;
                break;
              }

              _context12.next = 51;
              return regeneratorRuntime.awrap(this.queryInterface.removeColumn(tableName, _columnName, options));

            case 51:
              return _context12.abrupt("continue", 43);

            case 52:
              if (!currentAttribute.primaryKey) {
                _context12.next = 54;
                break;
              }

              return _context12.abrupt("continue", 43);

            case 54:
              references = currentAttribute.references;

              if (!currentAttribute.references) {
                _context12.next = 87;
                break;
              }

              database = this.sequelize.config.database;
              schema = this.sequelize.config.schema;
              _iteratorNormalCompletion6 = true;
              _didIteratorError6 = false;
              _iteratorError6 = undefined;
              _context12.prev = 61;
              _iterator6 = foreignKeyReferences[Symbol.iterator]();

            case 63:
              if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
                _context12.next = 73;
                break;
              }

              foreignKeyReference = _step6.value;
              constraintName = foreignKeyReference.constraintName;

              if (!(!!constraintName && foreignKeyReference.tableCatalog === database && (schema ? foreignKeyReference.tableSchema === schema : true) && foreignKeyReference.referencedTableName === references.model && foreignKeyReference.referencedColumnName === references.key && (schema ? foreignKeyReference.referencedTableSchema === schema : true) && !removedConstraints[constraintName])) {
                _context12.next = 70;
                break;
              }

              _context12.next = 69;
              return regeneratorRuntime.awrap(this.queryInterface.removeConstraint(tableName, constraintName, options));

            case 69:
              removedConstraints[constraintName] = true;

            case 70:
              _iteratorNormalCompletion6 = true;
              _context12.next = 63;
              break;

            case 73:
              _context12.next = 79;
              break;

            case 75:
              _context12.prev = 75;
              _context12.t4 = _context12["catch"](61);
              _didIteratorError6 = true;
              _iteratorError6 = _context12.t4;

            case 79:
              _context12.prev = 79;
              _context12.prev = 80;

              if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                _iterator6["return"]();
              }

            case 82:
              _context12.prev = 82;

              if (!_didIteratorError6) {
                _context12.next = 85;
                break;
              }

              throw _iteratorError6;

            case 85:
              return _context12.finish(82);

            case 86:
              return _context12.finish(79);

            case 87:
              _context12.next = 89;
              return regeneratorRuntime.awrap(this.queryInterface.changeColumn(tableName, _columnName, currentAttribute, options));

            case 89:
              _context12.next = 43;
              break;

            case 91:
              _context12.next = 93;
              return regeneratorRuntime.awrap(this.queryInterface.showIndex(tableName, options));

            case 93:
              existingIndexes = _context12.sent;
              missingIndexes = this._indexes.filter(function (item1) {
                return !existingIndexes.some(function (item2) {
                  return item1.name === item2.name;
                });
              }).sort(function (index1, index2) {
                if (_this15.sequelize.options.dialect === "postgres") {
                  if (index1.concurrently === true) return 1;
                  if (index2.concurrently === true) return -1;
                }

                return 0;
              });
              _iteratorNormalCompletion7 = true;
              _didIteratorError7 = false;
              _iteratorError7 = undefined;
              _context12.prev = 98;
              _iterator7 = missingIndexes[Symbol.iterator]();

            case 100:
              if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {
                _context12.next = 107;
                break;
              }

              index = _step7.value;
              _context12.next = 104;
              return regeneratorRuntime.awrap(this.queryInterface.addIndex(tableName, __spreadValues(__spreadValues({}, options), index)));

            case 104:
              _iteratorNormalCompletion7 = true;
              _context12.next = 100;
              break;

            case 107:
              _context12.next = 113;
              break;

            case 109:
              _context12.prev = 109;
              _context12.t5 = _context12["catch"](98);
              _didIteratorError7 = true;
              _iteratorError7 = _context12.t5;

            case 113:
              _context12.prev = 113;
              _context12.prev = 114;

              if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
                _iterator7["return"]();
              }

            case 116:
              _context12.prev = 116;

              if (!_didIteratorError7) {
                _context12.next = 119;
                break;
              }

              throw _iteratorError7;

            case 119:
              return _context12.finish(116);

            case 120:
              return _context12.finish(113);

            case 121:
              if (!options.hooks) {
                _context12.next = 124;
                break;
              }

              _context12.next = 124;
              return regeneratorRuntime.awrap(this.runHooks("afterSync", options));

            case 124:
              return _context12.abrupt("return", this);

            case 125:
            case "end":
              return _context12.stop();
          }
        }
      }, null, this, [[61, 75, 79, 87], [80,, 82, 86], [98, 109, 113, 121], [114,, 116, 120]]);
    }
  }, {
    key: "drop",
    value: function drop(options) {
      return regeneratorRuntime.async(function drop$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              _context13.next = 2;
              return regeneratorRuntime.awrap(this.queryInterface.dropTable(this.getTableName(options), options));

            case 2:
              return _context13.abrupt("return", _context13.sent);

            case 3:
            case "end":
              return _context13.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "dropSchema",
    value: function dropSchema(schema) {
      return regeneratorRuntime.async(function dropSchema$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return regeneratorRuntime.awrap(this.queryInterface.dropSchema(schema));

            case 2:
              return _context14.abrupt("return", _context14.sent);

            case 3:
            case "end":
              return _context14.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "schema",
    value: function schema(_schema, options) {
      var clone =
      /*#__PURE__*/
      function (_this16) {
        _inherits(clone, _this16);

        function clone() {
          _classCallCheck(this, clone);

          return _possibleConstructorReturn(this, _getPrototypeOf(clone).apply(this, arguments));
        }

        return clone;
      }(this);

      Object.defineProperty(clone, "name", {
        value: this.name
      });
      clone._schema = _schema;

      if (options) {
        if (typeof options === "string") {
          clone._schemaDelimiter = options;
        } else if (options.schemaDelimiter) {
          clone._schemaDelimiter = options.schemaDelimiter;
        }
      }

      return clone;
    }
  }, {
    key: "getTableName",
    value: function getTableName() {
      return this.queryGenerator.addSchema(this);
    }
  }, {
    key: "unscoped",
    value: function unscoped() {
      return this.scope();
    }
  }, {
    key: "addScope",
    value: function addScope(name, scope, options) {
      options = __spreadValues({
        override: false
      }, options);

      if ((name === "defaultScope" && Object.keys(this.options.defaultScope).length > 0 || name in this.options.scopes) && options.override === false) {
        throw new Error("The scope ".concat(name, " already exists. Pass { override: true } as options to silence this error"));
      }

      if (name === "defaultScope") {
        this.options.defaultScope = this._scope = scope;
      } else {
        this.options.scopes[name] = scope;
      }
    }
  }, {
    key: "scope",
    value: function scope(option) {
      var self =
      /*#__PURE__*/
      function (_this17) {
        _inherits(self, _this17);

        function self() {
          _classCallCheck(this, self);

          return _possibleConstructorReturn(this, _getPrototypeOf(self).apply(this, arguments));
        }

        return self;
      }(this);

      var scope;
      var scopeName;
      Object.defineProperty(self, "name", {
        value: this.name
      });
      self._scope = {};
      self._scopeNames = [];
      self.scoped = true;

      if (!option) {
        return self;
      }

      var options = _.flatten(arguments);

      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = options[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var option2 = _step8.value;
          scope = null;
          scopeName = null;

          if (_.isPlainObject(option2)) {
            if (option2.method) {
              if (Array.isArray(option2.method) && !!self.options.scopes[option2.method[0]]) {
                scopeName = option2.method[0];
                scope = self.options.scopes[scopeName].apply(self, option2.method.slice(1));
              } else if (self.options.scopes[option2.method]) {
                scopeName = option2.method;
                scope = self.options.scopes[scopeName].apply(self);
              }
            } else {
              scope = option2;
            }
          } else if (option2 === "defaultScope" && _.isPlainObject(self.options.defaultScope)) {
            scope = self.options.defaultScope;
          } else {
            scopeName = option2;
            scope = self.options.scopes[scopeName];

            if (typeof scope === "function") {
              scope = scope();
            }
          }

          if (scope) {
            this._conformIncludes(scope, this);

            this._assignOptions(self._scope, Utils.cloneDeep(scope));

            self._scopeNames.push(scopeName ? scopeName : "defaultScope");
          } else {
            throw new sequelizeErrors.SequelizeScopeError("Invalid scope ".concat(scopeName, " called."));
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      return self;
    }
  }, {
    key: "findAll",
    value: function findAll(options) {
      var tableNames, t, selectOptions, results;
      return regeneratorRuntime.async(function findAll$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              if (!(options !== void 0 && !_.isPlainObject(options))) {
                _context15.next = 2;
                break;
              }

              throw new sequelizeErrors.QueryError("The argument passed to findAll must be an options object, use findByPk if you wish to pass a single primary key value");

            case 2:
              if (!(options !== void 0 && options.attributes)) {
                _context15.next = 5;
                break;
              }

              if (!(!Array.isArray(options.attributes) && !_.isPlainObject(options.attributes))) {
                _context15.next = 5;
                break;
              }

              throw new sequelizeErrors.QueryError("The attributes option must be an array of column names or an object");

            case 5:
              this.warnOnInvalidOptions(options, Object.keys(this.rawAttributes));
              tableNames = {};
              tableNames[this.getTableName(options)] = true;
              options = Utils.cloneDeep(options);

              if (options.transaction === void 0 && this.sequelize.constructor._cls) {
                t = this.sequelize.constructor._cls.get("transaction");

                if (t) {
                  options.transaction = t;
                }
              }

              _.defaults(options, {
                hooks: true
              });

              options.rejectOnEmpty = Object.prototype.hasOwnProperty.call(options, "rejectOnEmpty") ? options.rejectOnEmpty : this.options.rejectOnEmpty;

              this._injectScope(options);

              if (!options.hooks) {
                _context15.next = 16;
                break;
              }

              _context15.next = 16;
              return regeneratorRuntime.awrap(this.runHooks("beforeFind", options));

            case 16:
              this._conformIncludes(options, this);

              this._expandAttributes(options);

              this._expandIncludeAll(options);

              if (!options.hooks) {
                _context15.next = 22;
                break;
              }

              _context15.next = 22;
              return regeneratorRuntime.awrap(this.runHooks("beforeFindAfterExpandIncludeAll", options));

            case 22:
              options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);

              if (options.include) {
                options.hasJoin = true;

                this._validateIncludedElements(options, tableNames);

                if (options.attributes && !options.raw && this.primaryKeyAttribute && !options.attributes.includes(this.primaryKeyAttribute) && (!options.group || !options.hasSingleAssociation || options.hasMultiAssociation)) {
                  options.attributes = [this.primaryKeyAttribute].concat(options.attributes);
                }
              }

              if (!options.attributes) {
                options.attributes = Object.keys(this.rawAttributes);
                options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);
              }

              this.options.whereCollection = options.where || null;
              Utils.mapFinderOptions(options, this);
              options = this._paranoidClause(this, options);

              if (!options.hooks) {
                _context15.next = 31;
                break;
              }

              _context15.next = 31;
              return regeneratorRuntime.awrap(this.runHooks("beforeFindAfterOptions", options));

            case 31:
              selectOptions = __spreadProps(__spreadValues({}, options), {
                tableNames: Object.keys(tableNames)
              });
              _context15.next = 34;
              return regeneratorRuntime.awrap(this.queryInterface.select(this, this.getTableName(selectOptions), selectOptions));

            case 34:
              results = _context15.sent;

              if (!options.hooks) {
                _context15.next = 38;
                break;
              }

              _context15.next = 38;
              return regeneratorRuntime.awrap(this.runHooks("afterFind", results, options));

            case 38:
              if (!(_.isEmpty(results) && options.rejectOnEmpty)) {
                _context15.next = 44;
                break;
              }

              if (!(typeof options.rejectOnEmpty === "function")) {
                _context15.next = 41;
                break;
              }

              throw new options.rejectOnEmpty();

            case 41:
              if (!(_typeof(options.rejectOnEmpty) === "object")) {
                _context15.next = 43;
                break;
              }

              throw options.rejectOnEmpty;

            case 43:
              throw new sequelizeErrors.EmptyResultError();

            case 44:
              _context15.next = 46;
              return regeneratorRuntime.awrap(Model._findSeparate(results, options));

            case 46:
              return _context15.abrupt("return", _context15.sent);

            case 47:
            case "end":
              return _context15.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "warnOnInvalidOptions",
    value: function warnOnInvalidOptions(options, validColumnNames) {
      if (!_.isPlainObject(options)) {
        return;
      }

      var unrecognizedOptions = Object.keys(options).filter(function (k) {
        return !validQueryKeywords.has(k);
      });

      var unexpectedModelAttributes = _.intersection(unrecognizedOptions, validColumnNames);

      if (!options.where && unexpectedModelAttributes.length > 0) {
        logger.warn("Model attributes (".concat(unexpectedModelAttributes.join(", "), ") passed into finder method options of model ").concat(this.name, ", but the options.where object is empty. Did you forget to use options.where?"));
      }
    }
  }, {
    key: "_injectDependentVirtualAttributes",
    value: function _injectDependentVirtualAttributes(attributes) {
      if (!this._hasVirtualAttributes) return attributes;
      if (!attributes || !Array.isArray(attributes)) return attributes;
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = attributes[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var attribute = _step9.value;

          if (this._virtualAttributes.has(attribute) && this.rawAttributes[attribute].type.fields) {
            attributes = attributes.concat(this.rawAttributes[attribute].type.fields);
          }
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
            _iterator9["return"]();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }

      attributes = _.uniq(attributes);
      return attributes;
    }
  }, {
    key: "_findSeparate",
    value: function _findSeparate(results, options) {
      var original;
      return regeneratorRuntime.async(function _findSeparate$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              if (!(!options.include || options.raw || !results)) {
                _context17.next = 2;
                break;
              }

              return _context17.abrupt("return", results);

            case 2:
              original = results;
              if (options.plain) results = [results];

              if (results.length) {
                _context17.next = 6;
                break;
              }

              return _context17.abrupt("return", original);

            case 6:
              _context17.next = 8;
              return regeneratorRuntime.awrap(Promise.all(options.include.map(function _callee4(include) {
                var map, _iteratorNormalCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, result;

                return regeneratorRuntime.async(function _callee4$(_context16) {
                  while (1) {
                    switch (_context16.prev = _context16.next) {
                      case 0:
                        if (include.separate) {
                          _context16.next = 4;
                          break;
                        }

                        _context16.next = 3;
                        return regeneratorRuntime.awrap(Model._findSeparate(results.reduce(function (memo, result) {
                          var associations = result.get(include.association.as);
                          if (!associations) return memo;
                          if (!Array.isArray(associations)) associations = [associations];

                          for (var i = 0, len = associations.length; i !== len; ++i) {
                            memo.push(associations[i]);
                          }

                          return memo;
                        }, []), __spreadProps(__spreadValues({}, _.omit(options, "include", "attributes", "order", "where", "limit", "offset", "plain", "scope")), {
                          include: include.include || []
                        })));

                      case 3:
                        return _context16.abrupt("return", _context16.sent);

                      case 4:
                        _context16.next = 6;
                        return regeneratorRuntime.awrap(include.association.get(results, __spreadValues(__spreadValues({}, _.omit(options, nonCascadingOptions)), _.omit(include, ["parent", "association", "as", "originalAttributes"]))));

                      case 6:
                        map = _context16.sent;
                        _iteratorNormalCompletion10 = true;
                        _didIteratorError10 = false;
                        _iteratorError10 = undefined;
                        _context16.prev = 10;

                        for (_iterator10 = results[Symbol.iterator](); !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                          result = _step10.value;
                          result.set(include.association.as, map[result.get(include.association.sourceKey)], {
                            raw: true
                          });
                        }

                        _context16.next = 18;
                        break;

                      case 14:
                        _context16.prev = 14;
                        _context16.t0 = _context16["catch"](10);
                        _didIteratorError10 = true;
                        _iteratorError10 = _context16.t0;

                      case 18:
                        _context16.prev = 18;
                        _context16.prev = 19;

                        if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
                          _iterator10["return"]();
                        }

                      case 21:
                        _context16.prev = 21;

                        if (!_didIteratorError10) {
                          _context16.next = 24;
                          break;
                        }

                        throw _iteratorError10;

                      case 24:
                        return _context16.finish(21);

                      case 25:
                        return _context16.finish(18);

                      case 26:
                      case "end":
                        return _context16.stop();
                    }
                  }
                }, null, null, [[10, 14, 18, 26], [19,, 21, 25]]);
              })));

            case 8:
              return _context17.abrupt("return", original);

            case 9:
            case "end":
              return _context17.stop();
          }
        }
      });
    }
  }, {
    key: "findByPk",
    value: function findByPk(param, options) {
      return regeneratorRuntime.async(function findByPk$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              if (![null, void 0].includes(param)) {
                _context18.next = 2;
                break;
              }

              return _context18.abrupt("return", null);

            case 2:
              options = Utils.cloneDeep(options) || {};

              if (!(typeof param === "number" || typeof param === "bigint" || typeof param === "string" || Buffer.isBuffer(param))) {
                _context18.next = 7;
                break;
              }

              options.where = _defineProperty({}, this.primaryKeyAttribute, param);
              _context18.next = 8;
              break;

            case 7:
              throw new Error("Argument passed to findByPk is invalid: ".concat(param));

            case 8:
              _context18.next = 10;
              return regeneratorRuntime.awrap(this.findOne(options));

            case 10:
              return _context18.abrupt("return", _context18.sent);

            case 11:
            case "end":
              return _context18.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "findOne",
    value: function findOne(options) {
      var _this18 = this;

      var t, uniqueSingleColumns;
      return regeneratorRuntime.async(function findOne$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              if (!(options !== void 0 && !_.isPlainObject(options))) {
                _context19.next = 2;
                break;
              }

              throw new Error("The argument passed to findOne must be an options object, use findByPk if you wish to pass a single primary key value");

            case 2:
              options = Utils.cloneDeep(options);

              if (options.transaction === void 0 && this.sequelize.constructor._cls) {
                t = this.sequelize.constructor._cls.get("transaction");

                if (t) {
                  options.transaction = t;
                }
              }

              if (options.limit === void 0) {
                uniqueSingleColumns = _.chain(this.uniqueKeys).values().filter(function (c) {
                  return c.fields.length === 1;
                }).map("column").value();

                if (!options.where || !_.some(options.where, function (value, key) {
                  return (key === _this18.primaryKeyAttribute || uniqueSingleColumns.includes(key)) && (Utils.isPrimitive(value) || Buffer.isBuffer(value));
                })) {
                  options.limit = 1;
                }
              }

              _context19.next = 7;
              return regeneratorRuntime.awrap(this.findAll(_.defaults(options, {
                plain: true
              })));

            case 7:
              return _context19.abrupt("return", _context19.sent);

            case 8:
            case "end":
              return _context19.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "aggregate",
    value: function aggregate(attribute, aggregateFunction, options) {
      var prevAttributes, attrOptions, field, aggregateColumn, _options, group, value;

      return regeneratorRuntime.async(function aggregate$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              options = Utils.cloneDeep(options);
              prevAttributes = options.attributes;

              this._injectScope(options);

              options.attributes = prevAttributes;

              this._conformIncludes(options, this);

              if (options.include) {
                this._expandIncludeAll(options);

                this._validateIncludedElements(options);
              }

              attrOptions = this.rawAttributes[attribute];
              field = attrOptions && attrOptions.field || attribute;
              aggregateColumn = this.sequelize.col(field);

              if (options.distinct) {
                aggregateColumn = this.sequelize.fn("DISTINCT", aggregateColumn);
              }

              _options = options, group = _options.group;

              if (Array.isArray(group) && Array.isArray(group[0])) {
                noDoubleNestedGroup();
                group = _.flatten(group);
              }

              options.attributes = _.unionBy(options.attributes, group, [[this.sequelize.fn(aggregateFunction, aggregateColumn), aggregateFunction]], function (a) {
                return Array.isArray(a) ? a[1] : a;
              });

              if (!options.dataType) {
                if (attrOptions) {
                  options.dataType = attrOptions.type;
                } else {
                  options.dataType = new DataTypes.FLOAT();
                }
              } else {
                options.dataType = this.sequelize.normalizeDataType(options.dataType);
              }

              Utils.mapOptionFieldNames(options, this);
              options = this._paranoidClause(this, options);
              _context20.next = 18;
              return regeneratorRuntime.awrap(this.queryInterface.rawSelect(this.getTableName(options), options, aggregateFunction, this));

            case 18:
              value = _context20.sent;
              return _context20.abrupt("return", value);

            case 20:
            case "end":
              return _context20.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "count",
    value: function count(options) {
      var t, col, result;
      return regeneratorRuntime.async(function count$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              options = Utils.cloneDeep(options);
              options = _.defaults(options, {
                hooks: true
              });

              if (options.transaction === void 0 && this.sequelize.constructor._cls) {
                t = this.sequelize.constructor._cls.get("transaction");

                if (t) {
                  options.transaction = t;
                }
              }

              options.raw = true;

              if (!options.hooks) {
                _context21.next = 7;
                break;
              }

              _context21.next = 7;
              return regeneratorRuntime.awrap(this.runHooks("beforeCount", options));

            case 7:
              col = options.col || "*";

              if (options.include) {
                col = "".concat(this.name, ".").concat(options.col || this.primaryKeyField);
              }

              if (options.distinct && col === "*") {
                col = this.primaryKeyField;
              }

              options.plain = !options.group;
              options.dataType = new DataTypes.INTEGER();
              options.includeIgnoreAttributes = false;
              options.limit = null;
              options.offset = null;
              options.order = null;
              _context21.next = 18;
              return regeneratorRuntime.awrap(this.aggregate(col, "count", options));

            case 18:
              result = _context21.sent;

              if (!Array.isArray(result)) {
                _context21.next = 21;
                break;
              }

              return _context21.abrupt("return", result.map(function (item) {
                return __spreadProps(__spreadValues({}, item), {
                  count: Number(item.count)
                });
              }));

            case 21:
              return _context21.abrupt("return", result);

            case 22:
            case "end":
              return _context21.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "findAndCountAll",
    value: function findAndCountAll(options) {
      var countOptions, _ref6, _ref7, count, rows;

      return regeneratorRuntime.async(function findAndCountAll$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              if (!(options !== void 0 && !_.isPlainObject(options))) {
                _context22.next = 2;
                break;
              }

              throw new Error("The argument passed to findAndCountAll must be an options object, use findByPk if you wish to pass a single primary key value");

            case 2:
              countOptions = Utils.cloneDeep(options);

              if (countOptions.attributes) {
                countOptions.attributes = void 0;
              }

              _context22.next = 6;
              return regeneratorRuntime.awrap(Promise.all([this.count(countOptions), this.findAll(options)]));

            case 6:
              _ref6 = _context22.sent;
              _ref7 = _slicedToArray(_ref6, 2);
              count = _ref7[0];
              rows = _ref7[1];
              return _context22.abrupt("return", {
                count: count,
                rows: count === 0 ? [] : rows
              });

            case 11:
            case "end":
              return _context22.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "max",
    value: function max(field, options) {
      return regeneratorRuntime.async(function max$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              _context23.next = 2;
              return regeneratorRuntime.awrap(this.aggregate(field, "max", options));

            case 2:
              return _context23.abrupt("return", _context23.sent);

            case 3:
            case "end":
              return _context23.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "min",
    value: function min(field, options) {
      return regeneratorRuntime.async(function min$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              _context24.next = 2;
              return regeneratorRuntime.awrap(this.aggregate(field, "min", options));

            case 2:
              return _context24.abrupt("return", _context24.sent);

            case 3:
            case "end":
              return _context24.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "sum",
    value: function sum(field, options) {
      return regeneratorRuntime.async(function sum$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              _context25.next = 2;
              return regeneratorRuntime.awrap(this.aggregate(field, "sum", options));

            case 2:
              return _context25.abrupt("return", _context25.sent);

            case 3:
            case "end":
              return _context25.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "build",
    value: function build(values, options) {
      if (Array.isArray(values)) {
        return this.bulkBuild(values, options);
      }

      return new this(values, options);
    }
  }, {
    key: "bulkBuild",
    value: function bulkBuild(valueSets, options) {
      var _this19 = this;

      options = __spreadValues({
        isNewRecord: true
      }, options);

      if (!options.includeValidated) {
        this._conformIncludes(options, this);

        if (options.include) {
          this._expandIncludeAll(options);

          this._validateIncludedElements(options);
        }
      }

      if (options.attributes) {
        options.attributes = options.attributes.map(function (attribute) {
          return Array.isArray(attribute) ? attribute[1] : attribute;
        });
      }

      return valueSets.map(function (values) {
        return _this19.build(values, options);
      });
    }
  }, {
    key: "create",
    value: function create(values, options) {
      return regeneratorRuntime.async(function create$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              options = Utils.cloneDeep(options || {});
              _context26.next = 3;
              return regeneratorRuntime.awrap(this.build(values, {
                isNewRecord: true,
                attributes: options.fields,
                include: options.include,
                raw: options.raw,
                silent: options.silent
              }).save(options));

            case 3:
              return _context26.abrupt("return", _context26.sent);

            case 4:
            case "end":
              return _context26.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "findOrBuild",
    value: function findOrBuild(options) {
      var values,
          instance,
          _args27 = arguments;
      return regeneratorRuntime.async(function findOrBuild$(_context27) {
        while (1) {
          switch (_context27.prev = _context27.next) {
            case 0:
              if (!(!options || !options.where || _args27.length > 1)) {
                _context27.next = 2;
                break;
              }

              throw new Error("Missing where attribute in the options parameter passed to findOrBuild. Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)");

            case 2:
              _context27.next = 4;
              return regeneratorRuntime.awrap(this.findOne(options));

            case 4:
              instance = _context27.sent;

              if (!(instance === null)) {
                _context27.next = 10;
                break;
              }

              values = __spreadValues({}, options.defaults);

              if (_.isPlainObject(options.where)) {
                values = Utils.defaults(values, options.where);
              }

              instance = this.build(values, options);
              return _context27.abrupt("return", [instance, true]);

            case 10:
              return _context27.abrupt("return", [instance, false]);

            case 11:
            case "end":
              return _context27.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "findOrCreate",
    value: function findOrCreate(options) {
      var _this20 = this;

      var defaults,
          unknownDefaults,
          t,
          internalTransaction,
          values,
          transaction,
          _t,
          found,
          created,
          flattenedWhere,
          flattenedWhereKeys,
          whereFields,
          defaultFields,
          errFieldKeys,
          errFieldsWhereIntersects,
          otherCreated,
          _args28 = arguments;

      return regeneratorRuntime.async(function findOrCreate$(_context28) {
        while (1) {
          switch (_context28.prev = _context28.next) {
            case 0:
              if (!(!options || !options.where || _args28.length > 1)) {
                _context28.next = 2;
                break;
              }

              throw new Error("Missing where attribute in the options parameter passed to findOrCreate. Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)");

            case 2:
              options = __spreadValues({}, options);

              if (options.defaults) {
                defaults = Object.keys(options.defaults);
                unknownDefaults = defaults.filter(function (name) {
                  return !_this20.rawAttributes[name];
                });

                if (unknownDefaults.length) {
                  logger.warn("Unknown attributes (".concat(unknownDefaults, ") passed to defaults option of findOrCreate"));
                }
              }

              if (options.transaction === void 0 && this.sequelize.constructor._cls) {
                t = this.sequelize.constructor._cls.get("transaction");

                if (t) {
                  options.transaction = t;
                }
              }

              internalTransaction = !options.transaction;
              _context28.prev = 6;
              _context28.next = 9;
              return regeneratorRuntime.awrap(this.sequelize.transaction(options));

            case 9:
              _t = _context28.sent;
              transaction = _t;
              options.transaction = _t;
              _context28.next = 14;
              return regeneratorRuntime.awrap(this.findOne(Utils.defaults({
                transaction: transaction
              }, options)));

            case 14:
              found = _context28.sent;

              if (!(found !== null)) {
                _context28.next = 17;
                break;
              }

              return _context28.abrupt("return", [found, false]);

            case 17:
              values = __spreadValues({}, options.defaults);

              if (_.isPlainObject(options.where)) {
                values = Utils.defaults(values, options.where);
              }

              options.exception = true;
              options.returning = true;
              _context28.prev = 21;
              _context28.next = 24;
              return regeneratorRuntime.awrap(this.create(values, options));

            case 24:
              created = _context28.sent;

              if (!(created.get(this.primaryKeyAttribute, {
                raw: true
              }) === null)) {
                _context28.next = 27;
                break;
              }

              throw new sequelizeErrors.UniqueConstraintError();

            case 27:
              return _context28.abrupt("return", [created, true]);

            case 30:
              _context28.prev = 30;
              _context28.t0 = _context28["catch"](21);

              if (_context28.t0 instanceof sequelizeErrors.UniqueConstraintError) {
                _context28.next = 34;
                break;
              }

              throw _context28.t0;

            case 34:
              flattenedWhere = Utils.flattenObjectDeep(options.where);
              flattenedWhereKeys = Object.keys(flattenedWhere).map(function (name) {
                return _.last(name.split("."));
              });
              whereFields = flattenedWhereKeys.map(function (name) {
                return _.get(_this20.rawAttributes, "".concat(name, ".field"), name);
              });
              defaultFields = options.defaults && Object.keys(options.defaults).filter(function (name) {
                return _this20.rawAttributes[name];
              }).map(function (name) {
                return _this20.rawAttributes[name].field || name;
              });
              errFieldKeys = Object.keys(_context28.t0.fields);
              errFieldsWhereIntersects = Utils.intersects(errFieldKeys, whereFields);

              if (!(defaultFields && !errFieldsWhereIntersects && Utils.intersects(errFieldKeys, defaultFields))) {
                _context28.next = 42;
                break;
              }

              throw _context28.t0;

            case 42:
              if (errFieldsWhereIntersects) {
                _.each(_context28.t0.fields, function (value, key) {
                  var name = _this20.fieldRawAttributesMap[key].fieldName;

                  if (value.toString() !== options.where[name].toString()) {
                    throw new Error("".concat(_this20.name, "#findOrCreate: value used for ").concat(name, " was not equal for both the find and the create calls, '").concat(options.where[name], "' vs '").concat(value, "'"));
                  }
                });
              }

              _context28.next = 45;
              return regeneratorRuntime.awrap(this.findOne(Utils.defaults({
                transaction: internalTransaction ? null : transaction
              }, options)));

            case 45:
              otherCreated = _context28.sent;

              if (!(otherCreated === null)) {
                _context28.next = 48;
                break;
              }

              throw _context28.t0;

            case 48:
              return _context28.abrupt("return", [otherCreated, false]);

            case 49:
              _context28.prev = 49;

              if (!(internalTransaction && transaction)) {
                _context28.next = 53;
                break;
              }

              _context28.next = 53;
              return regeneratorRuntime.awrap(transaction.commit());

            case 53:
              return _context28.finish(49);

            case 54:
            case "end":
              return _context28.stop();
          }
        }
      }, null, this, [[6,, 49, 54], [21, 30]]);
    }
  }, {
    key: "findCreateFind",
    value: function findCreateFind(options) {
      var values, found, createOptions, created, foundAgain;
      return regeneratorRuntime.async(function findCreateFind$(_context29) {
        while (1) {
          switch (_context29.prev = _context29.next) {
            case 0:
              if (!(!options || !options.where)) {
                _context29.next = 2;
                break;
              }

              throw new Error("Missing where attribute in the options parameter passed to findCreateFind.");

            case 2:
              values = __spreadValues({}, options.defaults);

              if (_.isPlainObject(options.where)) {
                values = Utils.defaults(values, options.where);
              }

              _context29.next = 6;
              return regeneratorRuntime.awrap(this.findOne(options));

            case 6:
              found = _context29.sent;

              if (!found) {
                _context29.next = 9;
                break;
              }

              return _context29.abrupt("return", [found, false]);

            case 9:
              _context29.prev = 9;
              createOptions = __spreadValues({}, options);

              if (this.sequelize.options.dialect === "postgres" && options.transaction) {
                createOptions.ignoreDuplicates = true;
              }

              _context29.next = 14;
              return regeneratorRuntime.awrap(this.create(values, createOptions));

            case 14:
              created = _context29.sent;
              return _context29.abrupt("return", [created, true]);

            case 18:
              _context29.prev = 18;
              _context29.t0 = _context29["catch"](9);

              if (_context29.t0 instanceof sequelizeErrors.UniqueConstraintError || _context29.t0 instanceof sequelizeErrors.EmptyResultError) {
                _context29.next = 22;
                break;
              }

              throw _context29.t0;

            case 22:
              _context29.next = 24;
              return regeneratorRuntime.awrap(this.findOne(options));

            case 24:
              foundAgain = _context29.sent;
              return _context29.abrupt("return", [foundAgain, false]);

            case 26:
            case "end":
              return _context29.stop();
          }
        }
      }, null, this, [[9, 18]]);
    }
  }, {
    key: "upsert",
    value: function upsert(values, options) {
      var t, createdAtAttr, updatedAtAttr, hasPrimary, instance, changed, updatedDataValues, insertValues, updateValues, now, field, _field, result, _result, record;

      return regeneratorRuntime.async(function upsert$(_context30) {
        while (1) {
          switch (_context30.prev = _context30.next) {
            case 0:
              options = __spreadValues({
                hooks: true,
                returning: true,
                validate: true
              }, Utils.cloneDeep(options));

              if (options.transaction === void 0 && this.sequelize.constructor._cls) {
                t = this.sequelize.constructor._cls.get("transaction");

                if (t) {
                  options.transaction = t;
                }
              }

              createdAtAttr = this._timestampAttributes.createdAt;
              updatedAtAttr = this._timestampAttributes.updatedAt;
              hasPrimary = this.primaryKeyField in values || this.primaryKeyAttribute in values;
              instance = this.build(values);
              options.model = this;
              options.instance = instance;
              changed = Array.from(instance._changed);

              if (!options.fields) {
                options.fields = changed;
              }

              if (!options.validate) {
                _context30.next = 13;
                break;
              }

              _context30.next = 13;
              return regeneratorRuntime.awrap(instance.validate(options));

            case 13:
              updatedDataValues = _.pick(instance.dataValues, changed);
              insertValues = Utils.mapValueFieldNames(instance.dataValues, Object.keys(instance.rawAttributes), this);
              updateValues = Utils.mapValueFieldNames(updatedDataValues, options.fields, this);
              now = Utils.now(this.sequelize.options.dialect);

              if (createdAtAttr && !insertValues[createdAtAttr]) {
                field = this.rawAttributes[createdAtAttr].field || createdAtAttr;
                insertValues[field] = this._getDefaultTimestamp(createdAtAttr) || now;
              }

              if (updatedAtAttr && !insertValues[updatedAtAttr]) {
                _field = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;
                insertValues[_field] = updateValues[_field] = this._getDefaultTimestamp(updatedAtAttr) || now;
              }

              if (this.sequelize.options.dialect === "db2") {
                this.uniqno = this.sequelize.dialect.queryGenerator.addUniqueFields(insertValues, this.rawAttributes, this.uniqno);
              }

              if (!hasPrimary && this.primaryKeyAttribute && !this.rawAttributes[this.primaryKeyAttribute].defaultValue) {
                delete insertValues[this.primaryKeyField];
                delete updateValues[this.primaryKeyField];
              }

              if (!options.hooks) {
                _context30.next = 24;
                break;
              }

              _context30.next = 24;
              return regeneratorRuntime.awrap(this.runHooks("beforeUpsert", values, options));

            case 24:
              _context30.next = 26;
              return regeneratorRuntime.awrap(this.queryInterface.upsert(this.getTableName(options), insertValues, updateValues, instance.where(), options));

            case 26:
              result = _context30.sent;
              _result = _slicedToArray(result, 1), record = _result[0];
              record.isNewRecord = false;

              if (!options.hooks) {
                _context30.next = 33;
                break;
              }

              _context30.next = 32;
              return regeneratorRuntime.awrap(this.runHooks("afterUpsert", result, options));

            case 32:
              return _context30.abrupt("return", result);

            case 33:
              return _context30.abrupt("return", result);

            case 34:
            case "end":
              return _context30.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "bulkCreate",
    value: function bulkCreate(records) {
      var _this21 = this;

      var options,
          dialect,
          now,
          t,
          instances,
          recursiveBulkCreate,
          _args36 = arguments;
      return regeneratorRuntime.async(function bulkCreate$(_context36) {
        while (1) {
          switch (_context36.prev = _context36.next) {
            case 0:
              options = _args36.length > 1 && _args36[1] !== undefined ? _args36[1] : {};

              if (records.length) {
                _context36.next = 3;
                break;
              }

              return _context36.abrupt("return", []);

            case 3:
              dialect = this.sequelize.options.dialect;
              now = Utils.now(this.sequelize.options.dialect);
              options = Utils.cloneDeep(options);

              if (options.transaction === void 0 && this.sequelize.constructor._cls) {
                t = this.sequelize.constructor._cls.get("transaction");

                if (t) {
                  options.transaction = t;
                }
              }

              options.model = this;

              if (!options.includeValidated) {
                this._conformIncludes(options, this);

                if (options.include) {
                  this._expandIncludeAll(options);

                  this._validateIncludedElements(options);
                }
              }

              instances = records.map(function (values) {
                return _this21.build(values, {
                  isNewRecord: true,
                  include: options.include
                });
              });

              recursiveBulkCreate = function recursiveBulkCreate(instances2, options2) {
                var model, createdAtAttr, updatedAtAttr, errors, validateOptions, fieldMappedAttributes, attr, upsertKeys, _iteratorNormalCompletion13, _didIteratorError13, _iteratorError13, _iterator13, _step13, i, firstUniqueKey, results;

                return regeneratorRuntime.async(function recursiveBulkCreate$(_context35) {
                  while (1) {
                    switch (_context35.prev = _context35.next) {
                      case 0:
                        options2 = __spreadValues({
                          validate: false,
                          hooks: true,
                          individualHooks: false,
                          ignoreDuplicates: false
                        }, options2);

                        if (options2.returning === void 0) {
                          if (options2.association) {
                            options2.returning = false;
                          } else {
                            options2.returning = true;
                          }
                        }

                        if (!(options2.ignoreDuplicates && !_this21.sequelize.dialect.supports.inserts.ignoreDuplicates && !_this21.sequelize.dialect.supports.inserts.onConflictDoNothing)) {
                          _context35.next = 4;
                          break;
                        }

                        throw new Error("".concat(dialect, " does not support the ignoreDuplicates option."));

                      case 4:
                        if (!(options2.updateOnDuplicate && dialect !== "mysql" && dialect !== "mariadb" && dialect !== "sqlite" && dialect !== "postgres")) {
                          _context35.next = 6;
                          break;
                        }

                        throw new Error("".concat(dialect, " does not support the updateOnDuplicate option."));

                      case 6:
                        model = options2.model;
                        options2.fields = options2.fields || Object.keys(model.rawAttributes);
                        createdAtAttr = model._timestampAttributes.createdAt;
                        updatedAtAttr = model._timestampAttributes.updatedAt;

                        if (!(options2.updateOnDuplicate !== void 0)) {
                          _context35.next = 16;
                          break;
                        }

                        if (!(Array.isArray(options2.updateOnDuplicate) && options2.updateOnDuplicate.length)) {
                          _context35.next = 15;
                          break;
                        }

                        options2.updateOnDuplicate = _.intersection(_.without(Object.keys(model.tableAttributes), createdAtAttr), options2.updateOnDuplicate);
                        _context35.next = 16;
                        break;

                      case 15:
                        throw new Error("updateOnDuplicate option only supports non-empty array.");

                      case 16:
                        if (!options2.hooks) {
                          _context35.next = 19;
                          break;
                        }

                        _context35.next = 19;
                        return regeneratorRuntime.awrap(model.runHooks("beforeBulkCreate", instances2, options2));

                      case 19:
                        if (!options2.validate) {
                          _context35.next = 28;
                          break;
                        }

                        errors = [];
                        validateOptions = __spreadValues({}, options2);
                        validateOptions.hooks = options2.individualHooks;
                        _context35.next = 25;
                        return regeneratorRuntime.awrap(Promise.all(instances2.map(function _callee5(instance) {
                          return regeneratorRuntime.async(function _callee5$(_context31) {
                            while (1) {
                              switch (_context31.prev = _context31.next) {
                                case 0:
                                  _context31.prev = 0;
                                  _context31.next = 3;
                                  return regeneratorRuntime.awrap(instance.validate(validateOptions));

                                case 3:
                                  _context31.next = 8;
                                  break;

                                case 5:
                                  _context31.prev = 5;
                                  _context31.t0 = _context31["catch"](0);
                                  errors.push(new sequelizeErrors.BulkRecordError(_context31.t0, instance));

                                case 8:
                                case "end":
                                  return _context31.stop();
                              }
                            }
                          }, null, null, [[0, 5]]);
                        })));

                      case 25:
                        delete options2.skip;

                        if (!errors.length) {
                          _context35.next = 28;
                          break;
                        }

                        throw new sequelizeErrors.AggregateError(errors);

                      case 28:
                        if (!options2.individualHooks) {
                          _context35.next = 33;
                          break;
                        }

                        _context35.next = 31;
                        return regeneratorRuntime.awrap(Promise.all(instances2.map(function _callee6(instance) {
                          var individualOptions;
                          return regeneratorRuntime.async(function _callee6$(_context32) {
                            while (1) {
                              switch (_context32.prev = _context32.next) {
                                case 0:
                                  individualOptions = __spreadProps(__spreadValues({}, options2), {
                                    validate: false,
                                    hooks: true
                                  });
                                  delete individualOptions.fields;
                                  delete individualOptions.individualHooks;
                                  delete individualOptions.ignoreDuplicates;
                                  _context32.next = 6;
                                  return regeneratorRuntime.awrap(instance.save(individualOptions));

                                case 6:
                                case "end":
                                  return _context32.stop();
                              }
                            }
                          });
                        })));

                      case 31:
                        _context35.next = 73;
                        break;

                      case 33:
                        if (!(options2.include && options2.include.length)) {
                          _context35.next = 36;
                          break;
                        }

                        _context35.next = 36;
                        return regeneratorRuntime.awrap(Promise.all(options2.include.filter(function (include) {
                          return include.association instanceof BelongsTo;
                        }).map(function _callee7(include) {
                          var associationInstances, associationInstanceIndexToInstanceMap, _iteratorNormalCompletion11, _didIteratorError11, _iteratorError11, _iterator11, _step11, _instance, _associationInstance, includeOptions, createdAssociationInstances, idx, associationInstance, instance;

                          return regeneratorRuntime.async(function _callee7$(_context33) {
                            while (1) {
                              switch (_context33.prev = _context33.next) {
                                case 0:
                                  associationInstances = [];
                                  associationInstanceIndexToInstanceMap = [];
                                  _iteratorNormalCompletion11 = true;
                                  _didIteratorError11 = false;
                                  _iteratorError11 = undefined;
                                  _context33.prev = 5;

                                  for (_iterator11 = instances2[Symbol.iterator](); !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                                    _instance = _step11.value;
                                    _associationInstance = _instance.get(include.as);

                                    if (_associationInstance) {
                                      associationInstances.push(_associationInstance);
                                      associationInstanceIndexToInstanceMap.push(_instance);
                                    }
                                  }

                                  _context33.next = 13;
                                  break;

                                case 9:
                                  _context33.prev = 9;
                                  _context33.t0 = _context33["catch"](5);
                                  _didIteratorError11 = true;
                                  _iteratorError11 = _context33.t0;

                                case 13:
                                  _context33.prev = 13;
                                  _context33.prev = 14;

                                  if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
                                    _iterator11["return"]();
                                  }

                                case 16:
                                  _context33.prev = 16;

                                  if (!_didIteratorError11) {
                                    _context33.next = 19;
                                    break;
                                  }

                                  throw _iteratorError11;

                                case 19:
                                  return _context33.finish(16);

                                case 20:
                                  return _context33.finish(13);

                                case 21:
                                  if (associationInstances.length) {
                                    _context33.next = 23;
                                    break;
                                  }

                                  return _context33.abrupt("return");

                                case 23:
                                  includeOptions = _(Utils.cloneDeep(include)).omit(["association"]).defaults({
                                    transaction: options2.transaction,
                                    logging: options2.logging
                                  }).value();
                                  _context33.next = 26;
                                  return regeneratorRuntime.awrap(recursiveBulkCreate(associationInstances, includeOptions));

                                case 26:
                                  createdAssociationInstances = _context33.sent;
                                  _context33.t1 = regeneratorRuntime.keys(createdAssociationInstances);

                                case 28:
                                  if ((_context33.t2 = _context33.t1()).done) {
                                    _context33.next = 36;
                                    break;
                                  }

                                  idx = _context33.t2.value;
                                  associationInstance = createdAssociationInstances[idx];
                                  instance = associationInstanceIndexToInstanceMap[idx];
                                  _context33.next = 34;
                                  return regeneratorRuntime.awrap(include.association.set(instance, associationInstance, {
                                    save: false,
                                    logging: options2.logging
                                  }));

                                case 34:
                                  _context33.next = 28;
                                  break;

                                case 36:
                                case "end":
                                  return _context33.stop();
                              }
                            }
                          }, null, null, [[5, 9, 13, 21], [14,, 16, 20]]);
                        })));

                      case 36:
                        records = instances2.map(function (instance) {
                          var values = instance.dataValues;

                          if (createdAtAttr && !values[createdAtAttr]) {
                            values[createdAtAttr] = now;

                            if (!options2.fields.includes(createdAtAttr)) {
                              options2.fields.push(createdAtAttr);
                            }
                          }

                          if (updatedAtAttr && !values[updatedAtAttr]) {
                            values[updatedAtAttr] = now;

                            if (!options2.fields.includes(updatedAtAttr)) {
                              options2.fields.push(updatedAtAttr);
                            }
                          }

                          var out = Utils.mapValueFieldNames(values, options2.fields, model);
                          var _iteratorNormalCompletion12 = true;
                          var _didIteratorError12 = false;
                          var _iteratorError12 = undefined;

                          try {
                            for (var _iterator12 = model._virtualAttributes[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                              var key = _step12.value;
                              delete out[key];
                            }
                          } catch (err) {
                            _didIteratorError12 = true;
                            _iteratorError12 = err;
                          } finally {
                            try {
                              if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
                                _iterator12["return"]();
                              }
                            } finally {
                              if (_didIteratorError12) {
                                throw _iteratorError12;
                              }
                            }
                          }

                          return out;
                        });
                        fieldMappedAttributes = {};

                        for (attr in model.tableAttributes) {
                          fieldMappedAttributes[model.rawAttributes[attr].field || attr] = model.rawAttributes[attr];
                        }

                        if (!options2.updateOnDuplicate) {
                          _context35.next = 68;
                          break;
                        }

                        options2.updateOnDuplicate = options2.updateOnDuplicate.map(function (attr) {
                          return model.rawAttributes[attr].field || attr;
                        });

                        if (!options2.conflictAttributes) {
                          _context35.next = 45;
                          break;
                        }

                        options2.upsertKeys = options2.conflictAttributes.map(function (attrName) {
                          return model.rawAttributes[attrName].field || attrName;
                        });
                        _context35.next = 68;
                        break;

                      case 45:
                        upsertKeys = [];
                        _iteratorNormalCompletion13 = true;
                        _didIteratorError13 = false;
                        _iteratorError13 = undefined;
                        _context35.prev = 49;

                        for (_iterator13 = model._indexes[Symbol.iterator](); !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                          i = _step13.value;

                          if (i.unique && !i.where) {
                            upsertKeys.push.apply(upsertKeys, _toConsumableArray(i.fields));
                          }
                        }

                        _context35.next = 57;
                        break;

                      case 53:
                        _context35.prev = 53;
                        _context35.t0 = _context35["catch"](49);
                        _didIteratorError13 = true;
                        _iteratorError13 = _context35.t0;

                      case 57:
                        _context35.prev = 57;
                        _context35.prev = 58;

                        if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
                          _iterator13["return"]();
                        }

                      case 60:
                        _context35.prev = 60;

                        if (!_didIteratorError13) {
                          _context35.next = 63;
                          break;
                        }

                        throw _iteratorError13;

                      case 63:
                        return _context35.finish(60);

                      case 64:
                        return _context35.finish(57);

                      case 65:
                        firstUniqueKey = Object.values(model.uniqueKeys).find(function (c) {
                          return c.fields.length > 0;
                        });

                        if (firstUniqueKey && firstUniqueKey.fields) {
                          upsertKeys.push.apply(upsertKeys, _toConsumableArray(firstUniqueKey.fields));
                        }

                        options2.upsertKeys = upsertKeys.length > 0 ? upsertKeys : Object.values(model.primaryKeys).map(function (x) {
                          return x.field;
                        });

                      case 68:
                        if (options2.returning && Array.isArray(options2.returning)) {
                          options2.returning = options2.returning.map(function (attr) {
                            return _.get(model.rawAttributes[attr], "field", attr);
                          });
                        }

                        _context35.next = 71;
                        return regeneratorRuntime.awrap(model.queryInterface.bulkInsert(model.getTableName(options2), records, options2, fieldMappedAttributes));

                      case 71:
                        results = _context35.sent;

                        if (Array.isArray(results)) {
                          results.forEach(function (result, i) {
                            var instance = instances2[i];

                            var _loop = function _loop(key) {
                              if (!instance || key === model.primaryKeyAttribute && instance.get(model.primaryKeyAttribute) && ["mysql", "mariadb", "sqlite"].includes(dialect)) {
                                return "continue";
                              }

                              if (Object.prototype.hasOwnProperty.call(result, key)) {
                                var record = result[key];

                                var _attr = _.find(model.rawAttributes, function (attribute) {
                                  return attribute.fieldName === key || attribute.field === key;
                                });

                                instance.dataValues[_attr && _attr.fieldName || key] = record;
                              }
                            };

                            for (var key in result) {
                              var _ret = _loop(key);

                              if (_ret === "continue") continue;
                            }
                          });
                        }

                      case 73:
                        if (!(options2.include && options2.include.length)) {
                          _context35.next = 76;
                          break;
                        }

                        _context35.next = 76;
                        return regeneratorRuntime.awrap(Promise.all(options2.include.filter(function (include) {
                          return !(include.association instanceof BelongsTo || include.parent && include.parent.association instanceof BelongsToMany);
                        }).map(function _callee8(include) {
                          var associationInstances, associationInstanceIndexToInstanceMap, _iteratorNormalCompletion14, _didIteratorError14, _iteratorError14, _iterator14, _step14, _instance2, associated, _iteratorNormalCompletion15, _didIteratorError15, _iteratorError15, _iterator15, _step15, _associationInstance2, includeOptions, createdAssociationInstances, valueSets, idx, _spreadValues2, associationInstance, instance, values, _i7, _Object$keys6, _attr2, throughOptions, throughInstances;

                          return regeneratorRuntime.async(function _callee8$(_context34) {
                            while (1) {
                              switch (_context34.prev = _context34.next) {
                                case 0:
                                  associationInstances = [];
                                  associationInstanceIndexToInstanceMap = [];
                                  _iteratorNormalCompletion14 = true;
                                  _didIteratorError14 = false;
                                  _iteratorError14 = undefined;
                                  _context34.prev = 5;
                                  _iterator14 = instances2[Symbol.iterator]();

                                case 7:
                                  if (_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done) {
                                    _context34.next = 33;
                                    break;
                                  }

                                  _instance2 = _step14.value;
                                  associated = _instance2.get(include.as);
                                  if (!Array.isArray(associated)) associated = [associated];
                                  _iteratorNormalCompletion15 = true;
                                  _didIteratorError15 = false;
                                  _iteratorError15 = undefined;
                                  _context34.prev = 14;

                                  for (_iterator15 = associated[Symbol.iterator](); !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                                    _associationInstance2 = _step15.value;

                                    if (_associationInstance2) {
                                      if (!(include.association instanceof BelongsToMany)) {
                                        _associationInstance2.set(include.association.foreignKey, _instance2.get(include.association.sourceKey || _instance2.constructor.primaryKeyAttribute, {
                                          raw: true
                                        }), {
                                          raw: true
                                        });

                                        Object.assign(_associationInstance2, include.association.scope);
                                      }

                                      associationInstances.push(_associationInstance2);
                                      associationInstanceIndexToInstanceMap.push(_instance2);
                                    }
                                  }

                                  _context34.next = 22;
                                  break;

                                case 18:
                                  _context34.prev = 18;
                                  _context34.t0 = _context34["catch"](14);
                                  _didIteratorError15 = true;
                                  _iteratorError15 = _context34.t0;

                                case 22:
                                  _context34.prev = 22;
                                  _context34.prev = 23;

                                  if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
                                    _iterator15["return"]();
                                  }

                                case 25:
                                  _context34.prev = 25;

                                  if (!_didIteratorError15) {
                                    _context34.next = 28;
                                    break;
                                  }

                                  throw _iteratorError15;

                                case 28:
                                  return _context34.finish(25);

                                case 29:
                                  return _context34.finish(22);

                                case 30:
                                  _iteratorNormalCompletion14 = true;
                                  _context34.next = 7;
                                  break;

                                case 33:
                                  _context34.next = 39;
                                  break;

                                case 35:
                                  _context34.prev = 35;
                                  _context34.t1 = _context34["catch"](5);
                                  _didIteratorError14 = true;
                                  _iteratorError14 = _context34.t1;

                                case 39:
                                  _context34.prev = 39;
                                  _context34.prev = 40;

                                  if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
                                    _iterator14["return"]();
                                  }

                                case 42:
                                  _context34.prev = 42;

                                  if (!_didIteratorError14) {
                                    _context34.next = 45;
                                    break;
                                  }

                                  throw _iteratorError14;

                                case 45:
                                  return _context34.finish(42);

                                case 46:
                                  return _context34.finish(39);

                                case 47:
                                  if (associationInstances.length) {
                                    _context34.next = 49;
                                    break;
                                  }

                                  return _context34.abrupt("return");

                                case 49:
                                  includeOptions = _(Utils.cloneDeep(include)).omit(["association"]).defaults({
                                    transaction: options2.transaction,
                                    logging: options2.logging
                                  }).value();
                                  _context34.next = 52;
                                  return regeneratorRuntime.awrap(recursiveBulkCreate(associationInstances, includeOptions));

                                case 52:
                                  createdAssociationInstances = _context34.sent;

                                  if (!(include.association instanceof BelongsToMany)) {
                                    _context34.next = 79;
                                    break;
                                  }

                                  valueSets = [];
                                  _context34.t2 = regeneratorRuntime.keys(createdAssociationInstances);

                                case 56:
                                  if ((_context34.t3 = _context34.t2()).done) {
                                    _context34.next = 74;
                                    break;
                                  }

                                  idx = _context34.t3.value;
                                  associationInstance = createdAssociationInstances[idx];
                                  instance = associationInstanceIndexToInstanceMap[idx];
                                  values = __spreadValues((_spreadValues2 = {}, _defineProperty(_spreadValues2, include.association.foreignKey, instance.get(instance.constructor.primaryKeyAttribute, {
                                    raw: true
                                  })), _defineProperty(_spreadValues2, include.association.otherKey, associationInstance.get(associationInstance.constructor.primaryKeyAttribute, {
                                    raw: true
                                  })), _spreadValues2), include.association.through.scope);

                                  if (!associationInstance[include.association.through.model.name]) {
                                    _context34.next = 71;
                                    break;
                                  }

                                  _i7 = 0, _Object$keys6 = Object.keys(include.association.through.model.rawAttributes);

                                case 63:
                                  if (!(_i7 < _Object$keys6.length)) {
                                    _context34.next = 71;
                                    break;
                                  }

                                  _attr2 = _Object$keys6[_i7];

                                  if (!(include.association.through.model.rawAttributes[_attr2]._autoGenerated || _attr2 === include.association.foreignKey || _attr2 === include.association.otherKey || typeof associationInstance[include.association.through.model.name][_attr2] === "undefined")) {
                                    _context34.next = 67;
                                    break;
                                  }

                                  return _context34.abrupt("continue", 68);

                                case 67:
                                  values[_attr2] = associationInstance[include.association.through.model.name][_attr2];

                                case 68:
                                  _i7++;
                                  _context34.next = 63;
                                  break;

                                case 71:
                                  valueSets.push(values);
                                  _context34.next = 56;
                                  break;

                                case 74:
                                  throughOptions = _(Utils.cloneDeep(include)).omit(["association", "attributes"]).defaults({
                                    transaction: options2.transaction,
                                    logging: options2.logging
                                  }).value();
                                  throughOptions.model = include.association.throughModel;
                                  throughInstances = include.association.throughModel.bulkBuild(valueSets, throughOptions);
                                  _context34.next = 79;
                                  return regeneratorRuntime.awrap(recursiveBulkCreate(throughInstances, throughOptions));

                                case 79:
                                case "end":
                                  return _context34.stop();
                              }
                            }
                          }, null, null, [[5, 35, 39, 47], [14, 18, 22, 30], [23,, 25, 29], [40,, 42, 46]]);
                        })));

                      case 76:
                        instances2.forEach(function (instance) {
                          for (var _attr3 in model.rawAttributes) {
                            if (model.rawAttributes[_attr3].field && instance.dataValues[model.rawAttributes[_attr3].field] !== void 0 && model.rawAttributes[_attr3].field !== _attr3) {
                              instance.dataValues[_attr3] = instance.dataValues[model.rawAttributes[_attr3].field];
                              delete instance.dataValues[model.rawAttributes[_attr3].field];
                            }

                            instance._previousDataValues[_attr3] = instance.dataValues[_attr3];
                            instance.changed(_attr3, false);
                          }

                          instance.isNewRecord = false;
                        });

                        if (!options2.hooks) {
                          _context35.next = 80;
                          break;
                        }

                        _context35.next = 80;
                        return regeneratorRuntime.awrap(model.runHooks("afterBulkCreate", instances2, options2));

                      case 80:
                        return _context35.abrupt("return", instances2);

                      case 81:
                      case "end":
                        return _context35.stop();
                    }
                  }
                }, null, null, [[49, 53, 57, 65], [58,, 60, 64]]);
              };

              _context36.next = 13;
              return regeneratorRuntime.awrap(recursiveBulkCreate(instances, options));

            case 13:
              return _context36.abrupt("return", _context36.sent);

            case 14:
            case "end":
              return _context36.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "truncate",
    value: function truncate(options) {
      return regeneratorRuntime.async(function truncate$(_context37) {
        while (1) {
          switch (_context37.prev = _context37.next) {
            case 0:
              options = Utils.cloneDeep(options) || {};
              options.truncate = true;
              _context37.next = 4;
              return regeneratorRuntime.awrap(this.destroy(options));

            case 4:
              return _context37.abrupt("return", _context37.sent);

            case 5:
            case "end":
              return _context37.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "destroy",
    value: function destroy(options) {
      var _this22 = this;

      var t, instances, result, attrValueHash, deletedAtAttribute, field, where;
      return regeneratorRuntime.async(function destroy$(_context38) {
        while (1) {
          switch (_context38.prev = _context38.next) {
            case 0:
              options = Utils.cloneDeep(options);

              if (options.transaction === void 0 && this.sequelize.constructor._cls) {
                t = this.sequelize.constructor._cls.get("transaction");

                if (t) {
                  options.transaction = t;
                }
              }

              this._injectScope(options);

              if (!(!options || !(options.where || options.truncate))) {
                _context38.next = 5;
                break;
              }

              throw new Error("Missing where or truncate attribute in the options parameter of model.destroy.");

            case 5:
              if (!(!options.truncate && !_.isPlainObject(options.where) && !Array.isArray(options.where) && !(options.where instanceof Utils.SequelizeMethod))) {
                _context38.next = 7;
                break;
              }

              throw new Error("Expected plain object, array or sequelize method in the options.where parameter of model.destroy.");

            case 7:
              options = _.defaults(options, {
                hooks: true,
                individualHooks: false,
                force: false,
                cascade: false,
                restartIdentity: false
              });
              options.type = QueryTypes.BULKDELETE;
              Utils.mapOptionFieldNames(options, this);
              options.model = this;

              if (!options.hooks) {
                _context38.next = 14;
                break;
              }

              _context38.next = 14;
              return regeneratorRuntime.awrap(this.runHooks("beforeBulkDestroy", options));

            case 14:
              if (!options.individualHooks) {
                _context38.next = 20;
                break;
              }

              _context38.next = 17;
              return regeneratorRuntime.awrap(this.findAll({
                where: options.where,
                transaction: options.transaction,
                logging: options.logging,
                benchmark: options.benchmark
              }));

            case 17:
              instances = _context38.sent;
              _context38.next = 20;
              return regeneratorRuntime.awrap(Promise.all(instances.map(function (instance) {
                return _this22.runHooks("beforeDestroy", instance, options);
              })));

            case 20:
              if (!(this._timestampAttributes.deletedAt && !options.force)) {
                _context38.next = 32;
                break;
              }

              options.type = QueryTypes.BULKUPDATE;
              attrValueHash = {};
              deletedAtAttribute = this.rawAttributes[this._timestampAttributes.deletedAt];
              field = this.rawAttributes[this._timestampAttributes.deletedAt].field;
              where = _defineProperty({}, field, Object.prototype.hasOwnProperty.call(deletedAtAttribute, "defaultValue") ? deletedAtAttribute.defaultValue : null);
              attrValueHash[field] = Utils.now(this.sequelize.options.dialect);
              _context38.next = 29;
              return regeneratorRuntime.awrap(this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, Object.assign(where, options.where), options, this.rawAttributes));

            case 29:
              result = _context38.sent;
              _context38.next = 35;
              break;

            case 32:
              _context38.next = 34;
              return regeneratorRuntime.awrap(this.queryInterface.bulkDelete(this.getTableName(options), options.where, options, this));

            case 34:
              result = _context38.sent;

            case 35:
              if (!options.individualHooks) {
                _context38.next = 38;
                break;
              }

              _context38.next = 38;
              return regeneratorRuntime.awrap(Promise.all(instances.map(function (instance) {
                return _this22.runHooks("afterDestroy", instance, options);
              })));

            case 38:
              if (!options.hooks) {
                _context38.next = 41;
                break;
              }

              _context38.next = 41;
              return regeneratorRuntime.awrap(this.runHooks("afterBulkDestroy", options));

            case 41:
              return _context38.abrupt("return", result);

            case 42:
            case "end":
              return _context38.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "restore",
    value: function restore(options) {
      var _this23 = this;

      var t, instances, attrValueHash, deletedAtCol, deletedAtAttribute, deletedAtDefaultValue, result;
      return regeneratorRuntime.async(function restore$(_context39) {
        while (1) {
          switch (_context39.prev = _context39.next) {
            case 0:
              if (this._timestampAttributes.deletedAt) {
                _context39.next = 2;
                break;
              }

              throw new Error("Model is not paranoid");

            case 2:
              options = __spreadValues({
                hooks: true,
                individualHooks: false
              }, options);

              if (options.transaction === void 0 && this.sequelize.constructor._cls) {
                t = this.sequelize.constructor._cls.get("transaction");

                if (t) {
                  options.transaction = t;
                }
              }

              options.type = QueryTypes.RAW;
              options.model = this;
              Utils.mapOptionFieldNames(options, this);

              if (!options.hooks) {
                _context39.next = 10;
                break;
              }

              _context39.next = 10;
              return regeneratorRuntime.awrap(this.runHooks("beforeBulkRestore", options));

            case 10:
              if (!options.individualHooks) {
                _context39.next = 16;
                break;
              }

              _context39.next = 13;
              return regeneratorRuntime.awrap(this.findAll({
                where: options.where,
                transaction: options.transaction,
                logging: options.logging,
                benchmark: options.benchmark,
                paranoid: false
              }));

            case 13:
              instances = _context39.sent;
              _context39.next = 16;
              return regeneratorRuntime.awrap(Promise.all(instances.map(function (instance) {
                return _this23.runHooks("beforeRestore", instance, options);
              })));

            case 16:
              attrValueHash = {};
              deletedAtCol = this._timestampAttributes.deletedAt;
              deletedAtAttribute = this.rawAttributes[deletedAtCol];
              deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, "defaultValue") ? deletedAtAttribute.defaultValue : null;
              attrValueHash[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;
              options.omitNull = false;
              _context39.next = 24;
              return regeneratorRuntime.awrap(this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, options.where, options, this.rawAttributes));

            case 24:
              result = _context39.sent;

              if (!options.individualHooks) {
                _context39.next = 28;
                break;
              }

              _context39.next = 28;
              return regeneratorRuntime.awrap(Promise.all(instances.map(function (instance) {
                return _this23.runHooks("afterRestore", instance, options);
              })));

            case 28:
              if (!options.hooks) {
                _context39.next = 31;
                break;
              }

              _context39.next = 31;
              return regeneratorRuntime.awrap(this.runHooks("afterBulkRestore", options));

            case 31:
              return _context39.abrupt("return", result);

            case 32:
            case "end":
              return _context39.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "update",
    value: function update(values, options) {
      var _this24 = this;

      var t, _i8, _Object$keys7, key, updatedAtAttr, valuesUse, build, attributes, instances, updateDoneRowByRow, changedValues, different, keys, result, affectedRows;

      return regeneratorRuntime.async(function update$(_context42) {
        while (1) {
          switch (_context42.prev = _context42.next) {
            case 0:
              options = Utils.cloneDeep(options);

              if (options.transaction === void 0 && this.sequelize.constructor._cls) {
                t = this.sequelize.constructor._cls.get("transaction");

                if (t) {
                  options.transaction = t;
                }
              }

              this._injectScope(options);

              this._optionsMustContainWhere(options);

              options = this._paranoidClause(this, _.defaults(options, {
                validate: true,
                hooks: true,
                individualHooks: false,
                returning: false,
                force: false,
                sideEffects: true
              }));
              options.type = QueryTypes.BULKUPDATE;
              values = _.omitBy(values, function (value) {
                return value === void 0;
              });

              if (options.fields && options.fields instanceof Array) {
                for (_i8 = 0, _Object$keys7 = Object.keys(values); _i8 < _Object$keys7.length; _i8++) {
                  key = _Object$keys7[_i8];

                  if (!options.fields.includes(key)) {
                    delete values[key];
                  }
                }
              } else {
                updatedAtAttr = this._timestampAttributes.updatedAt;
                options.fields = _.intersection(Object.keys(values), Object.keys(this.tableAttributes));

                if (updatedAtAttr && !options.fields.includes(updatedAtAttr)) {
                  options.fields.push(updatedAtAttr);
                }
              }

              if (this._timestampAttributes.updatedAt && !options.silent) {
                values[this._timestampAttributes.updatedAt] = this._getDefaultTimestamp(this._timestampAttributes.updatedAt) || Utils.now(this.sequelize.options.dialect);
              }

              options.model = this;

              if (!options.validate) {
                _context42.next = 20;
                break;
              }

              build = this.build(values);
              build.set(this._timestampAttributes.updatedAt, values[this._timestampAttributes.updatedAt], {
                raw: true
              });

              if (options.sideEffects) {
                Object.assign(values, _.pick(build.get(), build.changed()));
                options.fields = _.union(options.fields, Object.keys(values));
              }

              options.skip = _.difference(Object.keys(this.rawAttributes), Object.keys(values));
              _context42.next = 17;
              return regeneratorRuntime.awrap(build.validate(options));

            case 17:
              attributes = _context42.sent;
              options.skip = void 0;

              if (attributes && attributes.dataValues) {
                values = _.pick(attributes.dataValues, Object.keys(values));
              }

            case 20:
              if (!options.hooks) {
                _context42.next = 26;
                break;
              }

              options.attributes = values;
              _context42.next = 24;
              return regeneratorRuntime.awrap(this.runHooks("beforeBulkUpdate", options));

            case 24:
              values = options.attributes;
              delete options.attributes;

            case 26:
              valuesUse = values;
              updateDoneRowByRow = false;

              if (!options.individualHooks) {
                _context42.next = 46;
                break;
              }

              _context42.next = 31;
              return regeneratorRuntime.awrap(this.findAll({
                where: options.where,
                transaction: options.transaction,
                logging: options.logging,
                benchmark: options.benchmark,
                paranoid: options.paranoid
              }));

            case 31:
              instances = _context42.sent;

              if (!instances.length) {
                _context42.next = 46;
                break;
              }

              different = false;
              _context42.next = 36;
              return regeneratorRuntime.awrap(Promise.all(instances.map(function _callee9(instance) {
                var thisChangedValues;
                return regeneratorRuntime.async(function _callee9$(_context40) {
                  while (1) {
                    switch (_context40.prev = _context40.next) {
                      case 0:
                        Object.assign(instance.dataValues, values);

                        _.forIn(valuesUse, function (newValue, attr) {
                          if (newValue !== instance._previousDataValues[attr]) {
                            instance.setDataValue(attr, newValue);
                          }
                        });

                        _context40.next = 4;
                        return regeneratorRuntime.awrap(_this24.runHooks("beforeUpdate", instance, options));

                      case 4:
                        if (!different) {
                          thisChangedValues = {};

                          _.forIn(instance.dataValues, function (newValue, attr) {
                            if (newValue !== instance._previousDataValues[attr]) {
                              thisChangedValues[attr] = newValue;
                            }
                          });

                          if (!changedValues) {
                            changedValues = thisChangedValues;
                          } else {
                            different = !_.isEqual(changedValues, thisChangedValues);
                          }
                        }

                        return _context40.abrupt("return", instance);

                      case 6:
                      case "end":
                        return _context40.stop();
                    }
                  }
                });
              })));

            case 36:
              instances = _context42.sent;

              if (different) {
                _context42.next = 42;
                break;
              }

              keys = Object.keys(changedValues);

              if (keys.length) {
                valuesUse = changedValues;
                options.fields = _.union(options.fields, keys);
              }

              _context42.next = 46;
              break;

            case 42:
              _context42.next = 44;
              return regeneratorRuntime.awrap(Promise.all(instances.map(function _callee10(instance) {
                var individualOptions;
                return regeneratorRuntime.async(function _callee10$(_context41) {
                  while (1) {
                    switch (_context41.prev = _context41.next) {
                      case 0:
                        individualOptions = __spreadProps(__spreadValues({}, options), {
                          hooks: false,
                          validate: false
                        });
                        delete individualOptions.individualHooks;
                        return _context41.abrupt("return", instance.save(individualOptions));

                      case 3:
                      case "end":
                        return _context41.stop();
                    }
                  }
                });
              })));

            case 44:
              instances = _context42.sent;
              updateDoneRowByRow = true;

            case 46:
              if (!updateDoneRowByRow) {
                _context42.next = 50;
                break;
              }

              result = [instances.length, instances];
              _context42.next = 61;
              break;

            case 50:
              if (!(_.isEmpty(valuesUse) || Object.keys(valuesUse).length === 1 && valuesUse[this._timestampAttributes.updatedAt])) {
                _context42.next = 54;
                break;
              }

              result = [0];
              _context42.next = 61;
              break;

            case 54:
              valuesUse = Utils.mapValueFieldNames(valuesUse, options.fields, this);
              options = Utils.mapOptionFieldNames(options, this);
              options.hasTrigger = this.options ? this.options.hasTrigger : false;
              _context42.next = 59;
              return regeneratorRuntime.awrap(this.queryInterface.bulkUpdate(this.getTableName(options), valuesUse, options.where, options, this.tableAttributes));

            case 59:
              affectedRows = _context42.sent;

              if (options.returning) {
                result = [affectedRows.length, affectedRows];
                instances = affectedRows;
              } else {
                result = [affectedRows];
              }

            case 61:
              if (!options.individualHooks) {
                _context42.next = 65;
                break;
              }

              _context42.next = 64;
              return regeneratorRuntime.awrap(Promise.all(instances.map(function (instance) {
                return _this24.runHooks("afterUpdate", instance, options);
              })));

            case 64:
              result[1] = instances;

            case 65:
              if (!options.hooks) {
                _context42.next = 70;
                break;
              }

              options.attributes = values;
              _context42.next = 69;
              return regeneratorRuntime.awrap(this.runHooks("afterBulkUpdate", options));

            case 69:
              delete options.attributes;

            case 70:
              return _context42.abrupt("return", result);

            case 71:
            case "end":
              return _context42.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "describe",
    value: function describe(schema, options) {
      return regeneratorRuntime.async(function describe$(_context43) {
        while (1) {
          switch (_context43.prev = _context43.next) {
            case 0:
              _context43.next = 2;
              return regeneratorRuntime.awrap(this.queryInterface.describeTable(this.tableName, __spreadValues({
                schema: schema || this._schema || void 0
              }, options)));

            case 2:
              return _context43.abrupt("return", _context43.sent);

            case 3:
            case "end":
              return _context43.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_getDefaultTimestamp",
    value: function _getDefaultTimestamp(attr) {
      if (!!this.rawAttributes[attr] && !!this.rawAttributes[attr].defaultValue) {
        return Utils.toDefaultValue(this.rawAttributes[attr].defaultValue, this.sequelize.options.dialect);
      }

      return void 0;
    }
  }, {
    key: "_expandAttributes",
    value: function _expandAttributes(options) {
      if (!_.isPlainObject(options.attributes)) {
        return;
      }

      var attributes = Object.keys(this.rawAttributes);

      if (options.attributes.exclude) {
        attributes = attributes.filter(function (elem) {
          return !options.attributes.exclude.includes(elem);
        });
      }

      if (options.attributes.include) {
        attributes = attributes.concat(options.attributes.include);
      }

      options.attributes = attributes;
    }
  }, {
    key: "_injectScope",
    value: function _injectScope(options) {
      var scope = Utils.cloneDeep(this._scope);

      this._defaultsOptions(options, scope);
    }
  }, {
    key: Symbol["for"]("nodejs.util.inspect.custom"),
    value: function value() {
      return this.name;
    }
  }, {
    key: "hasAlias",
    value: function hasAlias(alias) {
      return Object.prototype.hasOwnProperty.call(this.associations, alias);
    }
  }, {
    key: "increment",
    value: function increment(fields, options) {
      var _this25 = this;

      var isSubtraction, where, incrementAmountsByField, _iteratorNormalCompletion16, _didIteratorError16, _iteratorError16, _iterator16, _step16, field, extraAttributesToBeUpdated, updatedAtAttr, attrName, tableName, affectedRows;

      return regeneratorRuntime.async(function increment$(_context44) {
        while (1) {
          switch (_context44.prev = _context44.next) {
            case 0:
              options = options || {};
              if (typeof fields === "string") fields = [fields];

              if (Array.isArray(fields)) {
                fields = fields.map(function (f) {
                  if (_this25.rawAttributes[f] && _this25.rawAttributes[f].field && _this25.rawAttributes[f].field !== f) {
                    return _this25.rawAttributes[f].field;
                  }

                  return f;
                });
              } else if (fields && _typeof(fields) === "object") {
                fields = Object.keys(fields).reduce(function (rawFields, f) {
                  if (_this25.rawAttributes[f] && _this25.rawAttributes[f].field && _this25.rawAttributes[f].field !== f) {
                    rawFields[_this25.rawAttributes[f].field] = fields[f];
                  } else {
                    rawFields[f] = fields[f];
                  }

                  return rawFields;
                }, {});
              }

              this._injectScope(options);

              this._optionsMustContainWhere(options);

              options = Utils.defaults({}, options, {
                by: 1,
                where: {},
                increment: true
              });
              isSubtraction = !options.increment;
              Utils.mapOptionFieldNames(options, this);
              where = __spreadValues({}, options.where);
              incrementAmountsByField = {};

              if (!Array.isArray(fields)) {
                _context44.next = 33;
                break;
              }

              incrementAmountsByField = {};
              _iteratorNormalCompletion16 = true;
              _didIteratorError16 = false;
              _iteratorError16 = undefined;
              _context44.prev = 15;

              for (_iterator16 = fields[Symbol.iterator](); !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                field = _step16.value;
                incrementAmountsByField[field] = options.by;
              }

              _context44.next = 23;
              break;

            case 19:
              _context44.prev = 19;
              _context44.t0 = _context44["catch"](15);
              _didIteratorError16 = true;
              _iteratorError16 = _context44.t0;

            case 23:
              _context44.prev = 23;
              _context44.prev = 24;

              if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
                _iterator16["return"]();
              }

            case 26:
              _context44.prev = 26;

              if (!_didIteratorError16) {
                _context44.next = 29;
                break;
              }

              throw _iteratorError16;

            case 29:
              return _context44.finish(26);

            case 30:
              return _context44.finish(23);

            case 31:
              _context44.next = 34;
              break;

            case 33:
              incrementAmountsByField = fields;

            case 34:
              if (this._versionAttribute) {
                incrementAmountsByField[this._versionAttribute] = isSubtraction ? -1 : 1;
              }

              extraAttributesToBeUpdated = {};
              updatedAtAttr = this._timestampAttributes.updatedAt;

              if (!options.silent && updatedAtAttr && !incrementAmountsByField[updatedAtAttr]) {
                attrName = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;
                extraAttributesToBeUpdated[attrName] = this._getDefaultTimestamp(updatedAtAttr) || Utils.now(this.sequelize.options.dialect);
              }

              tableName = this.getTableName(options);

              if (!isSubtraction) {
                _context44.next = 45;
                break;
              }

              _context44.next = 42;
              return regeneratorRuntime.awrap(this.queryInterface.decrement(this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options));

            case 42:
              affectedRows = _context44.sent;
              _context44.next = 48;
              break;

            case 45:
              _context44.next = 47;
              return regeneratorRuntime.awrap(this.queryInterface.increment(this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options));

            case 47:
              affectedRows = _context44.sent;

            case 48:
              if (!options.returning) {
                _context44.next = 50;
                break;
              }

              return _context44.abrupt("return", [affectedRows, affectedRows.length]);

            case 50:
              return _context44.abrupt("return", [affectedRows]);

            case 51:
            case "end":
              return _context44.stop();
          }
        }
      }, null, this, [[15, 19, 23, 31], [24,, 26, 30]]);
    }
  }, {
    key: "decrement",
    value: function decrement(fields, options) {
      return regeneratorRuntime.async(function decrement$(_context45) {
        while (1) {
          switch (_context45.prev = _context45.next) {
            case 0:
              return _context45.abrupt("return", this.increment(fields, __spreadProps(__spreadValues({
                by: 1
              }, options), {
                increment: false
              })));

            case 1:
            case "end":
              return _context45.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_optionsMustContainWhere",
    value: function _optionsMustContainWhere(options) {
      assert(options && options.where, "Missing where attribute in the options parameter");
      assert(_.isPlainObject(options.where) || Array.isArray(options.where) || options.where instanceof Utils.SequelizeMethod, "Expected plain object, array or sequelize method in the options.where parameter");
    }
  }, {
    key: "hasMany",
    value: function hasMany(target, options) {}
  }, {
    key: "belongsToMany",
    value: function belongsToMany(target, options) {}
  }, {
    key: "hasOne",
    value: function hasOne(target, options) {}
  }, {
    key: "belongsTo",
    value: function belongsTo(target, options) {}
  }]);

  return Model;
}();

function unpackAnd(where) {
  if (!_.isObject(where)) {
    return where;
  }

  var keys = Utils.getComplexKeys(where);

  if (keys.length === 0) {
    return;
  }

  if (keys.length !== 1 || keys[0] !== Op.and) {
    return where;
  }

  var andParts = where[Op.and];
  return andParts;
}

function combineWheresWithAnd(whereA, whereB) {
  var unpackedA = unpackAnd(whereA);

  if (unpackedA === void 0) {
    return whereB;
  }

  var unpackedB = unpackAnd(whereB);

  if (unpackedB === void 0) {
    return whereA;
  }

  return _defineProperty({}, Op.and, _.flatten([unpackedA, unpackedB]));
}

Object.assign(Model, associationsMixin);
Hooks.applyTo(Model, true);
module.exports = Model;