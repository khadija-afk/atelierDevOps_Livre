'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Types = require('../constants/types');

var Packet = require('../packets/packet');

var binaryReader = new Array(256);

var BinaryRow =
/*#__PURE__*/
function () {
  function BinaryRow(columns) {
    _classCallCheck(this, BinaryRow);

    this.columns = columns || [];
  }

  _createClass(BinaryRow, null, [{
    key: "toPacket",
    value: function toPacket(columns, encoding) {
      // throw new Error('Not implemented');
      var sequenceId = 0; // TODO remove, this is calculated now in connecton

      var length = 0;
      columns.forEach(function (val) {
        if (val === null || typeof val === 'undefined') {
          ++length;
          return;
        }

        length += Packet.lengthCodedStringLength(val.toString(10), encoding);
      });
      length = length + 2;
      var buffer = Buffer.allocUnsafe(length + 4);
      var packet = new Packet(sequenceId, buffer, 0, length + 4);
      packet.offset = 4;
      packet.writeInt8(0);
      var bitmap = 0;
      var bitValue = 1;
      columns.forEach(function (parameter) {
        if (parameter.type === Types.NULL) {
          bitmap += bitValue;
        }

        bitValue *= 2;

        if (bitValue === 256) {
          packet.writeInt8(bitmap);
          bitmap = 0;
          bitValue = 1;
        }
      });

      if (bitValue !== 1) {
        packet.writeInt8(bitmap);
      }

      columns.forEach(function (val) {
        if (val === null) {
          packet.writeNull();
          return;
        }

        if (typeof val === 'undefined') {
          packet.writeInt8(0);
          return;
        }

        packet.writeLengthCodedString(val.toString(10), encoding);
      });
      return packet;
    } // TODO: complete list of types...

  }, {
    key: "fromPacket",
    value: function fromPacket(fields, packet) {
      var columns = new Array(fields.length);
      packet.readInt8(); // TODO check it's 0

      var nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8); // TODO: read and interpret null bitmap

      packet.skip(nullBitmapLength);

      for (var i = 0; i < columns.length; ++i) {
        columns[i] = binaryReader[fields[i].columnType].apply(packet);
      }

      return new BinaryRow(columns);
    }
  }]);

  return BinaryRow;
}(); // TODO: replace with constants.MYSQL_TYPE_*


binaryReader[Types.DECIMAL] = Packet.prototype.readLengthCodedString;
binaryReader[1] = Packet.prototype.readInt8; // tiny

binaryReader[2] = Packet.prototype.readInt16; // short

binaryReader[3] = Packet.prototype.readInt32; // long

binaryReader[4] = Packet.prototype.readFloat; // float

binaryReader[5] = Packet.prototype.readDouble; // double

binaryReader[6] = Packet.prototype.assertInvalid; // null, should be skipped vie null bitmap

binaryReader[7] = Packet.prototype.readTimestamp; // timestamp, http://dev.mysql.com/doc/internals/en/prepared-statements.html#packet-ProtocolBinary::MYSQL_TYPE_TIMESTAMP

binaryReader[8] = Packet.prototype.readInt64; // long long

binaryReader[9] = Packet.prototype.readInt32; // int24

binaryReader[10] = Packet.prototype.readTimestamp; // date

binaryReader[11] = Packet.prototype.readTime; // time, http://dev.mysql.com/doc/internals/en/prepared-statements.html#packet-ProtocolBinary::MYSQL_TYPE_TIME

binaryReader[12] = Packet.prototype.readDateTime; // datetime, http://dev.mysql.com/doc/internals/en/prepared-statements.html#packet-ProtocolBinary::MYSQL_TYPE_DATETIME

binaryReader[13] = Packet.prototype.readInt16; // year

binaryReader[Types.VAR_STRING] = Packet.prototype.readLengthCodedString; // var string

module.exports = BinaryRow;