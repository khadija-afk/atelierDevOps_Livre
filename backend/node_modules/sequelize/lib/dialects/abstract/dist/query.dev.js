"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return a;
};

var _ = require("lodash");

var SqlString = require("../../sql-string");

var QueryTypes = require("../../query-types");

var Dot = require("dottie");

var deprecations = require("../../utils/deprecations");

var uuid = require("uuid").v4;

var _require = require("../../utils.js"),
    safeStringifyJson = _require.safeStringifyJson;

var AbstractQuery =
/*#__PURE__*/
function () {
  function AbstractQuery(connection, sequelize, options) {
    _classCallCheck(this, AbstractQuery);

    this.uuid = uuid();
    this.connection = connection;
    this.instance = options.instance;
    this.model = options.model;
    this.sequelize = sequelize;
    this.options = __spreadValues({
      plain: false,
      raw: false,
      logging: console.log
    }, options);
    this.checkLoggingOption();

    if (options.rawErrors) {
      this.formatError = AbstractQuery.prototype.formatError;
    }
  }

  _createClass(AbstractQuery, [{
    key: "formatError",
    value: function formatError(error, errStack) {
      error.stack = errStack;
      return error;
    }
  }, {
    key: "run",
    value: function run() {
      throw new Error("The run method wasn't overwritten!");
    }
  }, {
    key: "checkLoggingOption",
    value: function checkLoggingOption() {
      if (this.options.logging === true) {
        deprecations.noTrueLogging();
        this.options.logging = console.log;
      }
    }
  }, {
    key: "getInsertIdField",
    value: function getInsertIdField() {
      return "insertId";
    }
  }, {
    key: "getUniqueConstraintErrorMessage",
    value: function getUniqueConstraintErrorMessage(field) {
      var message = field ? "".concat(field, " must be unique") : "Must be unique";

      if (field && this.model) {
        for (var _i = 0, _Object$keys = Object.keys(this.model.uniqueKeys); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];

          if (this.model.uniqueKeys[key].fields.includes(field.replace(/"/g, ""))) {
            if (this.model.uniqueKeys[key].msg) {
              message = this.model.uniqueKeys[key].msg;
            }
          }
        }
      }

      return message;
    }
  }, {
    key: "isRawQuery",
    value: function isRawQuery() {
      return this.options.type === QueryTypes.RAW;
    }
  }, {
    key: "isVersionQuery",
    value: function isVersionQuery() {
      return this.options.type === QueryTypes.VERSION;
    }
  }, {
    key: "isUpsertQuery",
    value: function isUpsertQuery() {
      return this.options.type === QueryTypes.UPSERT;
    }
  }, {
    key: "isInsertQuery",
    value: function isInsertQuery(results, metaData) {
      var result = true;

      if (this.options.type === QueryTypes.INSERT) {
        return true;
      }

      result = result && this.sql.toLowerCase().startsWith("insert into");
      result = result && (!results || Object.prototype.hasOwnProperty.call(results, this.getInsertIdField()));
      result = result && (!metaData || Object.prototype.hasOwnProperty.call(metaData, this.getInsertIdField()));
      return result;
    }
  }, {
    key: "handleInsertQuery",
    value: function handleInsertQuery(results, metaData) {
      if (this.instance) {
        var autoIncrementAttribute = this.model.autoIncrementAttribute;
        var id = null;
        id = id || results && results[this.getInsertIdField()];
        id = id || metaData && metaData[this.getInsertIdField()];
        this.instance[autoIncrementAttribute] = id;
      }
    }
  }, {
    key: "isShowTablesQuery",
    value: function isShowTablesQuery() {
      return this.options.type === QueryTypes.SHOWTABLES;
    }
  }, {
    key: "handleShowTablesQuery",
    value: function handleShowTablesQuery(results) {
      return _.flatten(results.map(function (resultSet) {
        return Object.values(resultSet);
      }));
    }
  }, {
    key: "isShowIndexesQuery",
    value: function isShowIndexesQuery() {
      return this.options.type === QueryTypes.SHOWINDEXES;
    }
  }, {
    key: "isShowConstraintsQuery",
    value: function isShowConstraintsQuery() {
      return this.options.type === QueryTypes.SHOWCONSTRAINTS;
    }
  }, {
    key: "isDescribeQuery",
    value: function isDescribeQuery() {
      return this.options.type === QueryTypes.DESCRIBE;
    }
  }, {
    key: "isSelectQuery",
    value: function isSelectQuery() {
      return this.options.type === QueryTypes.SELECT;
    }
  }, {
    key: "isBulkUpdateQuery",
    value: function isBulkUpdateQuery() {
      return this.options.type === QueryTypes.BULKUPDATE;
    }
  }, {
    key: "isBulkDeleteQuery",
    value: function isBulkDeleteQuery() {
      return this.options.type === QueryTypes.BULKDELETE;
    }
  }, {
    key: "isForeignKeysQuery",
    value: function isForeignKeysQuery() {
      return this.options.type === QueryTypes.FOREIGNKEYS;
    }
  }, {
    key: "isUpdateQuery",
    value: function isUpdateQuery() {
      return this.options.type === QueryTypes.UPDATE;
    }
  }, {
    key: "handleSelectQuery",
    value: function handleSelectQuery(results) {
      var _this = this;

      var result = null;

      if (this.options.fieldMap) {
        var fieldMap = this.options.fieldMap;
        results = results.map(function (result2) {
          return _.reduce(fieldMap, function (result3, name, field) {
            if (result3[field] !== void 0 && name !== field) {
              result3[name] = result3[field];
              delete result3[field];
            }

            return result3;
          }, result2);
        });
      }

      if (this.options.raw) {
        result = results.map(function (result2) {
          var o = {};

          for (var key in result2) {
            if (Object.prototype.hasOwnProperty.call(result2, key)) {
              o[key] = result2[key];
            }
          }

          if (_this.options.nest) {
            o = Dot.transform(o);
          }

          return o;
        });
      } else if (this.options.hasJoin === true) {
        results = AbstractQuery._groupJoinData(results, {
          model: this.model,
          includeMap: this.options.includeMap,
          includeNames: this.options.includeNames
        }, {
          checkExisting: this.options.hasMultiAssociation
        });
        result = this.model.bulkBuild(results, {
          isNewRecord: false,
          include: this.options.include,
          includeNames: this.options.includeNames,
          includeMap: this.options.includeMap,
          includeValidated: true,
          attributes: this.options.originalAttributes || this.options.attributes,
          raw: true
        });
      } else {
        result = this.model.bulkBuild(results, {
          isNewRecord: false,
          raw: true,
          attributes: this.options.originalAttributes || this.options.attributes
        });
      }

      if (this.options.plain) {
        result = result.length === 0 ? null : result[0];
      }

      return result;
    }
  }, {
    key: "isShowOrDescribeQuery",
    value: function isShowOrDescribeQuery() {
      var result = false;
      result = result || this.sql.toLowerCase().startsWith("show");
      result = result || this.sql.toLowerCase().startsWith("describe");
      return result;
    }
  }, {
    key: "isCallQuery",
    value: function isCallQuery() {
      return this.sql.toLowerCase().startsWith("call");
    }
  }, {
    key: "_logQuery",
    value: function _logQuery(sql, debugContext, parameters) {
      var _this2 = this;

      var connection = this.connection,
          options = this.options;
      var benchmark = this.sequelize.options.benchmark || options.benchmark;
      var logQueryParameters = this.sequelize.options.logQueryParameters || options.logQueryParameters;
      var startTime = Date.now();
      var logParameter = "";

      if (logQueryParameters && parameters) {
        var delimiter = sql.endsWith(";") ? "" : ";";
        var paramStr;

        if (Array.isArray(parameters)) {
          paramStr = parameters.map(function (p) {
            return safeStringifyJson(p);
          }).join(", ");
        } else {
          paramStr = safeStringifyJson(parameters);
        }

        logParameter = "".concat(delimiter, " ").concat(paramStr);
      }

      var fmt = "(".concat(connection.uuid || "default", "): ").concat(sql).concat(logParameter);
      var msg = "Executing ".concat(fmt);
      debugContext(msg);

      if (!benchmark) {
        this.sequelize.log("Executing ".concat(fmt), options);
      }

      return function () {
        var afterMsg = "Executed ".concat(fmt);
        debugContext(afterMsg);

        if (benchmark) {
          _this2.sequelize.log(afterMsg, Date.now() - startTime, options);
        }
      };
    }
  }], [{
    key: "formatBindParameters",
    value: function formatBindParameters(sql, values, dialect, replacementFunc, options) {
      if (!values) {
        return [sql, []];
      }

      options = options || {};

      if (typeof replacementFunc !== "function") {
        options = replacementFunc || {};
        replacementFunc = void 0;
      }

      if (!replacementFunc) {
        if (options.skipValueReplace) {
          replacementFunc = function replacementFunc(match, key, values2) {
            if (values2[key] !== void 0) {
              return match;
            }

            return void 0;
          };
        } else {
          replacementFunc = function replacementFunc(match, key, values2, timeZone2, dialect2) {
            if (values2[key] !== void 0) {
              return SqlString.escape(values2[key], timeZone2, dialect2);
            }

            return void 0;
          };
        }
      } else if (options.skipValueReplace) {
        var origReplacementFunc = replacementFunc;

        replacementFunc = function replacementFunc(match, key, values2, timeZone2, dialect2, options2) {
          if (origReplacementFunc(match, key, values2, timeZone2, dialect2, options2) !== void 0) {
            return match;
          }

          return void 0;
        };
      }

      var timeZone = null;
      var list = Array.isArray(values);
      sql = sql.replace(/\B\$(\$|\w+)/g, function (match, key) {
        if (key === "$") {
          return options.skipUnescape ? match : key;
        }

        var replVal;

        if (list) {
          if (key.match(/^[1-9]\d*$/)) {
            key = key - 1;
            replVal = replacementFunc(match, key, values, timeZone, dialect, options);
          }
        } else if (!key.match(/^\d*$/)) {
          replVal = replacementFunc(match, key, values, timeZone, dialect, options);
        }

        if (replVal === void 0) {
          throw new Error("Named bind parameter \"".concat(match, "\" has no value in the given object."));
        }

        return replVal;
      });
      return [sql, []];
    }
  }, {
    key: "_groupJoinData",
    value: function _groupJoinData(rows, includeOptions, options) {
      if (!rows.length) {
        return [];
      }

      var i;
      var length;
      var $i;
      var $length;
      var rowsI;
      var row;
      var rowsLength = rows.length;
      var keys;
      var key;
      var keyI;
      var keyLength;
      var prevKey;
      var values;
      var topValues;
      var topExists;
      var checkExisting = options.checkExisting;
      var itemHash;
      var parentHash;
      var topHash;
      var results = checkExisting ? [] : new Array(rowsLength);
      var resultMap = {};
      var includeMap = {};
      var $keyPrefix;
      var $keyPrefixString;
      var $prevKeyPrefixString;
      var $prevKeyPrefix;
      var $lastKeyPrefix;
      var $current;
      var $parent;
      var previousPiece;

      var buildIncludeMap = function buildIncludeMap(piece) {
        if (Object.prototype.hasOwnProperty.call($current.includeMap, piece)) {
          includeMap[key] = $current = $current.includeMap[piece];

          if (previousPiece) {
            previousPiece = "".concat(previousPiece, ".").concat(piece);
          } else {
            previousPiece = piece;
          }

          includeMap[previousPiece] = $current;
        }
      };

      var keyPrefixStringMemo = {};

      var keyPrefixString = function keyPrefixString(key2, memo) {
        if (!Object.prototype.hasOwnProperty.call(memo, key2)) {
          memo[key2] = key2.substr(0, key2.lastIndexOf("."));
        }

        return memo[key2];
      };

      var removeKeyPrefixMemo = {};

      var removeKeyPrefix = function removeKeyPrefix(key2) {
        if (!Object.prototype.hasOwnProperty.call(removeKeyPrefixMemo, key2)) {
          var index = key2.lastIndexOf(".");
          removeKeyPrefixMemo[key2] = key2.substr(index === -1 ? 0 : index + 1);
        }

        return removeKeyPrefixMemo[key2];
      };

      var keyPrefixMemo = {};

      var keyPrefix = function keyPrefix(key2) {
        if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, key2)) {
          var prefixString = keyPrefixString(key2, keyPrefixStringMemo);

          if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, prefixString)) {
            keyPrefixMemo[prefixString] = prefixString ? prefixString.split(".") : [];
          }

          keyPrefixMemo[key2] = keyPrefixMemo[prefixString];
        }

        return keyPrefixMemo[key2];
      };

      var lastKeyPrefixMemo = {};

      var lastKeyPrefix = function lastKeyPrefix(key2) {
        if (!Object.prototype.hasOwnProperty.call(lastKeyPrefixMemo, key2)) {
          var prefix2 = keyPrefix(key2);
          var length2 = prefix2.length;
          lastKeyPrefixMemo[key2] = !length2 ? "" : prefix2[length2 - 1];
        }

        return lastKeyPrefixMemo[key2];
      };

      var getUniqueKeyAttributes = function getUniqueKeyAttributes(model) {
        var uniqueKeyAttributes2 = _.chain(model.uniqueKeys);

        uniqueKeyAttributes2 = uniqueKeyAttributes2.result("".concat(uniqueKeyAttributes2.findKey(), ".fields")).map(function (field) {
          return _.findKey(model.attributes, function (chr) {
            return chr.field === field;
          });
        }).value();
        return uniqueKeyAttributes2;
      };

      var stringify = function stringify(obj) {
        return obj instanceof Buffer ? obj.toString("hex") : obj;
      };

      var primaryKeyAttributes;
      var uniqueKeyAttributes;
      var prefix;

      for (rowsI = 0; rowsI < rowsLength; rowsI++) {
        row = rows[rowsI];

        if (rowsI === 0) {
          keys = _.sortBy(Object.keys(row), function (item) {
            return [item.split(".").length];
          });
          keyLength = keys.length;
        }

        if (checkExisting) {
          topExists = false;
          $length = includeOptions.model.primaryKeyAttributes.length;
          topHash = "";

          if ($length === 1) {
            topHash = stringify(row[includeOptions.model.primaryKeyAttributes[0]]);
          } else if ($length > 1) {
            for ($i = 0; $i < $length; $i++) {
              topHash += stringify(row[includeOptions.model.primaryKeyAttributes[$i]]);
            }
          } else if (!_.isEmpty(includeOptions.model.uniqueKeys)) {
            uniqueKeyAttributes = getUniqueKeyAttributes(includeOptions.model);

            for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {
              topHash += row[uniqueKeyAttributes[$i]];
            }
          }
        }

        topValues = values = {};
        $prevKeyPrefix = void 0;

        for (keyI = 0; keyI < keyLength; keyI++) {
          key = keys[keyI];
          $keyPrefixString = keyPrefixString(key, keyPrefixStringMemo);
          $keyPrefix = keyPrefix(key);

          if (rowsI === 0 && !Object.prototype.hasOwnProperty.call(includeMap, key)) {
            if (!$keyPrefix.length) {
              includeMap[key] = includeMap[""] = includeOptions;
            } else {
              $current = includeOptions;
              previousPiece = void 0;
              $keyPrefix.forEach(buildIncludeMap);
            }
          }

          if ($prevKeyPrefix !== void 0 && $prevKeyPrefix !== $keyPrefix) {
            if (checkExisting) {
              length = $prevKeyPrefix.length;
              $parent = null;
              parentHash = null;

              if (length) {
                for (i = 0; i < length; i++) {
                  prefix = $parent ? "".concat($parent, ".").concat($prevKeyPrefix[i]) : $prevKeyPrefix[i];
                  primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;
                  $length = primaryKeyAttributes.length;
                  itemHash = prefix;

                  if ($length === 1) {
                    itemHash += stringify(row["".concat(prefix, ".").concat(primaryKeyAttributes[0])]);
                  } else if ($length > 1) {
                    for ($i = 0; $i < $length; $i++) {
                      itemHash += stringify(row["".concat(prefix, ".").concat(primaryKeyAttributes[$i])]);
                    }
                  } else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {
                    uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);

                    for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {
                      itemHash += row["".concat(prefix, ".").concat(uniqueKeyAttributes[$i])];
                    }
                  }

                  if (!parentHash) {
                    parentHash = topHash;
                  }

                  itemHash = parentHash + itemHash;
                  $parent = prefix;

                  if (i < length - 1) {
                    parentHash = itemHash;
                  }
                }
              } else {
                itemHash = topHash;
              }

              if (itemHash === topHash) {
                if (!resultMap[itemHash]) {
                  resultMap[itemHash] = values;
                } else {
                  topExists = true;
                }
              } else if (!resultMap[itemHash]) {
                $parent = resultMap[parentHash];
                $lastKeyPrefix = lastKeyPrefix(prevKey);

                if (includeMap[prevKey].association.isSingleAssociation) {
                  if ($parent) {
                    $parent[$lastKeyPrefix] = resultMap[itemHash] = values;
                  }
                } else {
                  if (!$parent[$lastKeyPrefix]) {
                    $parent[$lastKeyPrefix] = [];
                  }

                  $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);
                }
              }

              values = {};
            } else {
              $current = topValues;
              length = $keyPrefix.length;

              if (length) {
                for (i = 0; i < length; i++) {
                  if (i === length - 1) {
                    values = $current[$keyPrefix[i]] = {};
                  }

                  $current = $current[$keyPrefix[i]] || {};
                }
              }
            }
          }

          values[removeKeyPrefix(key)] = row[key];
          prevKey = key;
          $prevKeyPrefix = $keyPrefix;
          $prevKeyPrefixString = $keyPrefixString;
        }

        if (checkExisting) {
          length = $prevKeyPrefix.length;
          $parent = null;
          parentHash = null;

          if (length) {
            for (i = 0; i < length; i++) {
              prefix = $parent ? "".concat($parent, ".").concat($prevKeyPrefix[i]) : $prevKeyPrefix[i];
              primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;
              $length = primaryKeyAttributes.length;
              itemHash = prefix;

              if ($length === 1) {
                itemHash += stringify(row["".concat(prefix, ".").concat(primaryKeyAttributes[0])]);
              } else if ($length > 0) {
                for ($i = 0; $i < $length; $i++) {
                  itemHash += stringify(row["".concat(prefix, ".").concat(primaryKeyAttributes[$i])]);
                }
              } else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {
                uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);

                for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {
                  itemHash += row["".concat(prefix, ".").concat(uniqueKeyAttributes[$i])];
                }
              }

              if (!parentHash) {
                parentHash = topHash;
              }

              itemHash = parentHash + itemHash;
              $parent = prefix;

              if (i < length - 1) {
                parentHash = itemHash;
              }
            }
          } else {
            itemHash = topHash;
          }

          if (itemHash === topHash) {
            if (!resultMap[itemHash]) {
              resultMap[itemHash] = values;
            } else {
              topExists = true;
            }
          } else if (!resultMap[itemHash]) {
            $parent = resultMap[parentHash];
            $lastKeyPrefix = lastKeyPrefix(prevKey);

            if (includeMap[prevKey].association.isSingleAssociation) {
              if ($parent) {
                $parent[$lastKeyPrefix] = resultMap[itemHash] = values;
              }
            } else {
              if (!$parent[$lastKeyPrefix]) {
                $parent[$lastKeyPrefix] = [];
              }

              $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);
            }
          }

          if (!topExists) {
            results.push(topValues);
          }
        } else {
          results[rowsI] = topValues;
        }
      }

      return results;
    }
  }]);

  return AbstractQuery;
}();

module.exports = AbstractQuery;
module.exports.AbstractQuery = AbstractQuery;
module.exports["default"] = AbstractQuery;