"use strict";

var _ = require("lodash");

var validator = _.cloneDeep(require("validator"));

var moment = require("moment");

var extensions = {
  extend: function extend(name, fn) {
    this[name] = fn;
    return this;
  },
  notEmpty: function notEmpty(str) {
    return !str.match(/^[\s\t\r\n]*$/);
  },
  len: function len(str, min, max) {
    return this.isLength(str, min, max);
  },
  isUrl: function isUrl(str) {
    return this.isURL(str);
  },
  isIPv6: function isIPv6(str) {
    return this.isIP(str, 6);
  },
  isIPv4: function isIPv4(str) {
    return this.isIP(str, 4);
  },
  notIn: function notIn(str, values) {
    return !this.isIn(str, values);
  },
  regex: function regex(str, pattern, modifiers) {
    str += "";

    if (Object.prototype.toString.call(pattern).slice(8, -1) !== "RegExp") {
      pattern = new RegExp(pattern, modifiers);
    }

    return str.match(pattern);
  },
  notRegex: function notRegex(str, pattern, modifiers) {
    return !this.regex(str, pattern, modifiers);
  },
  isDecimal: function isDecimal(str) {
    return str !== "" && !!str.match(/^(?:-?(?:[0-9]+))?(?:\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);
  },
  min: function min(str, val) {
    var number = parseFloat(str);
    return isNaN(number) || number >= val;
  },
  max: function max(str, val) {
    var number = parseFloat(str);
    return isNaN(number) || number <= val;
  },
  not: function not(str, pattern, modifiers) {
    return this.notRegex(str, pattern, modifiers);
  },
  contains: function contains(str, elem) {
    return !!elem && str.includes(elem);
  },
  notContains: function notContains(str, elem) {
    return !this.contains(str, elem);
  },
  is: function is(str, pattern, modifiers) {
    return this.regex(str, pattern, modifiers);
  }
};
exports.extensions = extensions;

validator.isImmutable = function (value, validatorArgs, field, modelInstance) {
  return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];
};

validator.notNull = function (val) {
  return val !== null && val !== void 0;
};

_.forEach(extensions, function (extend, key) {
  validator[key] = extend;
});

validator.isNull = validator.isEmpty;

validator.isDate = function (dateString) {
  var parsed = Date.parse(dateString);

  if (isNaN(parsed)) {
    return false;
  }

  var date = new Date(parsed);
  return moment(date.toISOString()).isValid();
};

exports.validator = validator;