"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return a;
};

var _ = require("lodash");

var Utils = require("../../utils");

var DataTypes = require("../../data-types");

var TableHints = require("../../table-hints");

var AbstractQueryGenerator = require("../abstract/query-generator");

var randomBytes = require("crypto").randomBytes;

var semver = require("semver");

var Op = require("../../operators");

var throwMethodUndefined = function throwMethodUndefined(methodName) {
  throw new Error("The method \"".concat(methodName, "\" is not defined! Please add it to your sql dialect."));
};

var MSSQLQueryGenerator =
/*#__PURE__*/
function (_AbstractQueryGenerat) {
  _inherits(MSSQLQueryGenerator, _AbstractQueryGenerat);

  function MSSQLQueryGenerator() {
    _classCallCheck(this, MSSQLQueryGenerator);

    return _possibleConstructorReturn(this, _getPrototypeOf(MSSQLQueryGenerator).apply(this, arguments));
  }

  _createClass(MSSQLQueryGenerator, [{
    key: "createDatabaseQuery",
    value: function createDatabaseQuery(databaseName, options) {
      options = __spreadValues({
        collate: null
      }, options);
      var collation = options.collate ? "COLLATE ".concat(this.escape(options.collate)) : "";
      return ["IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =", wrapSingleQuote(databaseName), ")", "BEGIN", "CREATE DATABASE", this.quoteIdentifier(databaseName), "".concat(collation, ";"), "END;"].join(" ");
    }
  }, {
    key: "dropDatabaseQuery",
    value: function dropDatabaseQuery(databaseName) {
      return ["IF EXISTS (SELECT * FROM sys.databases WHERE name =", wrapSingleQuote(databaseName), ")", "BEGIN", "DROP DATABASE", this.quoteIdentifier(databaseName), ";", "END;"].join(" ");
    }
  }, {
    key: "createSchema",
    value: function createSchema(schema) {
      return ["IF NOT EXISTS (SELECT schema_name", "FROM information_schema.schemata", "WHERE schema_name =", wrapSingleQuote(schema), ")", "BEGIN", "EXEC sp_executesql N'CREATE SCHEMA", this.quoteIdentifier(schema), ";'", "END;"].join(" ");
    }
  }, {
    key: "dropSchema",
    value: function dropSchema(schema) {
      var quotedSchema = wrapSingleQuote(schema);
      return ["IF EXISTS (SELECT schema_name", "FROM information_schema.schemata", "WHERE schema_name =", quotedSchema, ")", "BEGIN", "DECLARE @id INT, @ms_sql NVARCHAR(2000);", "DECLARE @cascade TABLE (", "id INT NOT NULL IDENTITY PRIMARY KEY,", "ms_sql NVARCHAR(2000) NOT NULL );", "INSERT INTO @cascade ( ms_sql )", "SELECT CASE WHEN o.type IN ('F','PK')", "THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'", "ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END", "FROM sys.objects o", "JOIN sys.schemas s on o.schema_id = s.schema_id", "LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id", "WHERE o.type IN ('F', 'PK', 'U') AND s.name = ", quotedSchema, "ORDER BY o.type ASC;", "SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;", "WHILE @id IS NOT NULL", "BEGIN", "BEGIN TRY EXEC sp_executesql @ms_sql; END TRY", "BEGIN CATCH BREAK; THROW; END CATCH;", "DELETE FROM @cascade WHERE id = @id;", "SELECT @id = NULL, @ms_sql = NULL;", "SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;", "END", "EXEC sp_executesql N'DROP SCHEMA", this.quoteIdentifier(schema), ";'", "END;"].join(" ");
    }
  }, {
    key: "showSchemasQuery",
    value: function showSchemasQuery() {
      return ['SELECT "name" as "schema_name" FROM sys.schemas as s', 'WHERE "s"."name" NOT IN (', "'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'", ")", "AND", '"s"."name" NOT LIKE', "'db_%'"].join(" ");
    }
  }, {
    key: "versionQuery",
    value: function versionQuery() {
      return ["DECLARE @ms_ver NVARCHAR(20);", "SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));", "SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'"].join(" ");
    }
  }, {
    key: "createTableQuery",
    value: function createTableQuery(tableName, attributes, options) {
      var _this = this;

      var primaryKeys = [],
          foreignKeys = {},
          attributesClauseParts = [];
      var commentStr = "";

      for (var attr in attributes) {
        if (Object.prototype.hasOwnProperty.call(attributes, attr)) {
          var dataType = attributes[attr];
          var match = void 0;

          if (dataType.includes("COMMENT ")) {
            var commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);
            var commentText = commentMatch[2].replace("COMMENT", "").trim();
            commentStr += this.commentTemplate(commentText, tableName, attr);
            dataType = commentMatch[1];
          }

          if (dataType.includes("PRIMARY KEY")) {
            primaryKeys.push(attr);

            if (dataType.includes("REFERENCES")) {
              match = dataType.match(/^(.+) (REFERENCES.*)$/);
              attributesClauseParts.push("".concat(this.quoteIdentifier(attr), " ").concat(match[1].replace("PRIMARY KEY", "")));
              foreignKeys[attr] = match[2];
            } else {
              attributesClauseParts.push("".concat(this.quoteIdentifier(attr), " ").concat(dataType.replace("PRIMARY KEY", "")));
            }
          } else if (dataType.includes("REFERENCES")) {
            match = dataType.match(/^(.+) (REFERENCES.*)$/);
            attributesClauseParts.push("".concat(this.quoteIdentifier(attr), " ").concat(match[1]));
            foreignKeys[attr] = match[2];
          } else {
            attributesClauseParts.push("".concat(this.quoteIdentifier(attr), " ").concat(dataType));
          }
        }
      }

      var pkString = primaryKeys.map(function (pk) {
        return _this.quoteIdentifier(pk);
      }).join(", ");

      if (options.uniqueKeys) {
        _.each(options.uniqueKeys, function (columns, indexName) {
          if (columns.customIndex) {
            if (typeof indexName !== "string") {
              indexName = "uniq_".concat(tableName, "_").concat(columns.fields.join("_"));
            }

            attributesClauseParts.push("CONSTRAINT ".concat(_this.quoteIdentifier(indexName), " UNIQUE (").concat(columns.fields.map(function (field) {
              return _this.quoteIdentifier(field);
            }).join(", "), ")"));
          }
        });
      }

      if (pkString.length > 0) {
        attributesClauseParts.push("PRIMARY KEY (".concat(pkString, ")"));
      }

      for (var fkey in foreignKeys) {
        if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
          attributesClauseParts.push("FOREIGN KEY (".concat(this.quoteIdentifier(fkey), ") ").concat(foreignKeys[fkey]));
        }
      }

      var quotedTableName = this.quoteTable(tableName);
      return Utils.joinSQLFragments(["IF OBJECT_ID('".concat(quotedTableName, "', 'U') IS NULL"), "CREATE TABLE ".concat(quotedTableName, " (").concat(attributesClauseParts.join(", "), ")"), ";", commentStr]);
    }
  }, {
    key: "describeTableQuery",
    value: function describeTableQuery(tableName, schema) {
      var sql = ["SELECT", "c.COLUMN_NAME AS 'Name',", "c.DATA_TYPE AS 'Type',", "c.CHARACTER_MAXIMUM_LENGTH AS 'Length',", "c.IS_NULLABLE as 'IsNull',", "COLUMN_DEFAULT AS 'Default',", "pk.CONSTRAINT_TYPE AS 'Constraint',", "COLUMNPROPERTY(OBJECT_ID('[' + c.TABLE_SCHEMA + '].[' + c.TABLE_NAME + ']'), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',", "CAST(prop.value AS NVARCHAR) AS 'Comment'", "FROM", "INFORMATION_SCHEMA.TABLES t", "INNER JOIN", "INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA", "LEFT JOIN (SELECT tc.table_schema, tc.table_name, ", "cu.column_name, tc.CONSTRAINT_TYPE ", "FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ", "JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu ", "ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ", "and tc.constraint_name=cu.constraint_name ", "and tc.CONSTRAINT_TYPE='PRIMARY KEY') pk ", "ON pk.table_schema=c.table_schema ", "AND pk.table_name=c.table_name ", "AND pk.column_name=c.column_name ", "INNER JOIN sys.columns AS sc", "ON sc.object_id = OBJECT_ID('[' + t.TABLE_SCHEMA + '].[' + t.TABLE_NAME + ']') AND sc.name = c.column_name", "LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id", "AND prop.minor_id = sc.column_id", "AND prop.name = 'MS_Description'", "WHERE t.TABLE_NAME =", wrapSingleQuote(tableName)].join(" ");

      if (schema) {
        sql += "AND t.TABLE_SCHEMA =".concat(wrapSingleQuote(schema));
      }

      return sql;
    }
  }, {
    key: "renameTableQuery",
    value: function renameTableQuery(before, after) {
      return "EXEC sp_rename ".concat(this.quoteTable(before), ", ").concat(this.quoteTable(after), ";");
    }
  }, {
    key: "showTablesQuery",
    value: function showTablesQuery() {
      return "SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';";
    }
  }, {
    key: "tableExistsQuery",
    value: function tableExistsQuery(table) {
      var tableName = table.tableName || table;
      var schemaName = table.schema || "dbo";
      return "SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ".concat(this.escape(tableName), " AND TABLE_SCHEMA = ").concat(this.escape(schemaName));
    }
  }, {
    key: "dropTableQuery",
    value: function dropTableQuery(tableName) {
      var quoteTbl = this.quoteTable(tableName);
      return Utils.joinSQLFragments(["IF OBJECT_ID('".concat(quoteTbl, "', 'U') IS NOT NULL"), "DROP TABLE", quoteTbl, ";"]);
    }
  }, {
    key: "addColumnQuery",
    value: function addColumnQuery(table, key, dataType) {
      dataType.field = key;
      var commentStr = "";

      if (dataType.comment && _.isString(dataType.comment)) {
        commentStr = this.commentTemplate(dataType.comment, table, key);
        delete dataType["comment"];
      }

      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(table), "ADD", this.quoteIdentifier(key), this.attributeToSQL(dataType, {
        context: "addColumn"
      }), ";", commentStr]);
    }
  }, {
    key: "commentTemplate",
    value: function commentTemplate(comment, table, column) {
      return " EXEC sp_addextendedproperty @name = N'MS_Description', @value = ".concat(this.escape(comment), ", @level0type = N'Schema', @level0name = 'dbo', @level1type = N'Table', @level1name = ").concat(this.quoteIdentifier(table), ", @level2type = N'Column', @level2name = ").concat(this.quoteIdentifier(column), ";");
    }
  }, {
    key: "removeColumnQuery",
    value: function removeColumnQuery(tableName, attributeName) {
      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(tableName), "DROP COLUMN", this.quoteIdentifier(attributeName), ";"]);
    }
  }, {
    key: "changeColumnQuery",
    value: function changeColumnQuery(tableName, attributes) {
      var attrString = [],
          constraintString = [];
      var commentString = "";

      for (var attributeName in attributes) {
        var quotedAttrName = this.quoteIdentifier(attributeName);
        var definition = attributes[attributeName];

        if (definition.includes("COMMENT ")) {
          var commentMatch = definition.match(/^(.+) (COMMENT.*)$/);
          var commentText = commentMatch[2].replace("COMMENT", "").trim();
          commentString += this.commentTemplate(commentText, tableName, attributeName);
          definition = commentMatch[1];
        }

        if (definition.includes("REFERENCES")) {
          constraintString.push("FOREIGN KEY (".concat(quotedAttrName, ") ").concat(definition.replace(/.+?(?=REFERENCES)/, "")));
        } else {
          attrString.push("".concat(quotedAttrName, " ").concat(definition));
        }
      }

      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(tableName), attrString.length && "ALTER COLUMN ".concat(attrString.join(", ")), constraintString.length && "ADD ".concat(constraintString.join(", ")), ";", commentString]);
    }
  }, {
    key: "renameColumnQuery",
    value: function renameColumnQuery(tableName, attrBefore, attributes) {
      var newName = Object.keys(attributes)[0];
      return Utils.joinSQLFragments(["EXEC sp_rename", "'".concat(this.quoteTable(tableName), ".").concat(attrBefore, "',"), "'".concat(newName, "',"), "'COLUMN'", ";"]);
    }
  }, {
    key: "bulkInsertQuery",
    value: function bulkInsertQuery(tableName, attrValueHashes, options, attributes) {
      var _this2 = this;

      var quotedTable = this.quoteTable(tableName);
      options = options || {};
      attributes = attributes || {};
      var tuples = [];
      var allAttributes = [];
      var allQueries = [];
      var needIdentityInsertWrapper = false,
          outputFragment = "";

      if (options.returning) {
        var returnValues = this.generateReturnValues(attributes, options);
        outputFragment = returnValues.outputFragment;
      }

      var emptyQuery = "INSERT INTO ".concat(quotedTable).concat(outputFragment, " DEFAULT VALUES");
      attrValueHashes.forEach(function (attrValueHash) {
        var fields = Object.keys(attrValueHash);
        var firstAttr = attributes[fields[0]];

        if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {
          allQueries.push(emptyQuery);
          return;
        }

        _.forOwn(attrValueHash, function (value, key) {
          if (value !== null && attributes[key] && attributes[key].autoIncrement) {
            needIdentityInsertWrapper = true;
          }

          if (!allAttributes.includes(key)) {
            if (value === null && attributes[key] && attributes[key].autoIncrement) return;
            allAttributes.push(key);
          }
        });
      });

      if (allAttributes.length > 0) {
        attrValueHashes.forEach(function (attrValueHash) {
          tuples.push("(".concat(allAttributes.map(function (key) {
            return _this2.escape(attrValueHash[key]);
          }).join(","), ")"));
        });
        var quotedAttributes = allAttributes.map(function (attr) {
          return _this2.quoteIdentifier(attr);
        }).join(",");
        allQueries.push(function (tupleStr) {
          return "INSERT INTO ".concat(quotedTable, " (").concat(quotedAttributes, ")").concat(outputFragment, " VALUES ").concat(tupleStr, ";");
        });
      }

      var commands = [];
      var offset = 0;
      var batch = Math.floor(250 / (allAttributes.length + 1)) + 1;

      var _loop = function _loop() {
        var tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));
        var generatedQuery = allQueries.map(function (v) {
          return typeof v === "string" ? v : v(tupleStr);
        }).join(";");

        if (needIdentityInsertWrapper) {
          generatedQuery = "SET IDENTITY_INSERT ".concat(quotedTable, " ON; ").concat(generatedQuery, "; SET IDENTITY_INSERT ").concat(quotedTable, " OFF;");
        }

        commands.push(generatedQuery);
        offset += batch;
      };

      while (offset < Math.max(tuples.length, 1)) {
        _loop();
      }

      return commands.join(";");
    }
  }, {
    key: "updateQuery",
    value: function updateQuery(tableName, attrValueHash, where, options, attributes) {
      var sql = _get(_getPrototypeOf(MSSQLQueryGenerator.prototype), "updateQuery", this).call(this, tableName, attrValueHash, where, options, attributes);

      if (options.limit) {
        var updateArgs = "UPDATE TOP(".concat(this.escape(options.limit), ")");
        sql.query = sql.query.replace("UPDATE", updateArgs);
      }

      return sql;
    }
  }, {
    key: "upsertQuery",
    value: function upsertQuery(tableName, insertValues, updateValues, where, model) {
      var _this3 = this;

      var targetTableAlias = this.quoteTable("".concat(tableName, "_target"));
      var sourceTableAlias = this.quoteTable("".concat(tableName, "_source"));
      var primaryKeysAttrs = [];
      var identityAttrs = [];
      var uniqueAttrs = [];
      var tableNameQuoted = this.quoteTable(tableName);
      var needIdentityInsertWrapper = false;

      for (var key in model.rawAttributes) {
        if (model.rawAttributes[key].primaryKey) {
          primaryKeysAttrs.push(model.rawAttributes[key].field || key);
        }

        if (model.rawAttributes[key].unique) {
          uniqueAttrs.push(model.rawAttributes[key].field || key);
        }

        if (model.rawAttributes[key].autoIncrement) {
          identityAttrs.push(model.rawAttributes[key].field || key);
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = model._indexes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var index = _step2.value;

          if (index.unique && index.fields) {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = index.fields[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var field = _step3.value;
                var fieldName = typeof field === "string" ? field : field.name || field.attribute;

                if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {
                  uniqueAttrs.push(fieldName);
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                  _iterator3["return"]();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var updateKeys = Object.keys(updateValues);
      var insertKeys = Object.keys(insertValues);
      var insertKeysQuoted = insertKeys.map(function (key) {
        return _this3.quoteIdentifier(key);
      }).join(", ");
      var insertValuesEscaped = insertKeys.map(function (key) {
        return _this3.escape(insertValues[key]);
      }).join(", ");
      var sourceTableQuery = "VALUES(".concat(insertValuesEscaped, ")");
      var joinCondition;
      identityAttrs.forEach(function (key) {
        if (insertValues[key] && insertValues[key] !== null) {
          needIdentityInsertWrapper = true;
        }
      });
      var clauses = where[Op.or].filter(function (clause) {
        var valid = true;

        for (var _key in clause) {
          if (typeof clause[_key] === "undefined" || clause[_key] == null) {
            valid = false;
            break;
          }
        }

        return valid;
      });

      var getJoinSnippet = function getJoinSnippet(array) {
        return array.map(function (key) {
          key = _this3.quoteIdentifier(key);
          return "".concat(targetTableAlias, ".").concat(key, " = ").concat(sourceTableAlias, ".").concat(key);
        });
      };

      if (clauses.length === 0) {
        throw new Error("Primary Key or Unique key should be passed to upsert query");
      } else {
        for (var _key2 in clauses) {
          var keys = Object.keys(clauses[_key2]);

          if (primaryKeysAttrs.includes(keys[0])) {
            joinCondition = getJoinSnippet(primaryKeysAttrs).join(" AND ");
            break;
          }
        }

        if (!joinCondition) {
          joinCondition = getJoinSnippet(uniqueAttrs).join(" AND ");
        }
      }

      var filteredUpdateClauses = updateKeys.filter(function (key) {
        return !identityAttrs.includes(key);
      }).map(function (key) {
        var value = _this3.escape(updateValues[key]);

        key = _this3.quoteIdentifier(key);
        return "".concat(targetTableAlias, ".").concat(key, " = ").concat(value);
      });
      var updateSnippet = filteredUpdateClauses.length > 0 ? "WHEN MATCHED THEN UPDATE SET ".concat(filteredUpdateClauses.join(", ")) : "";
      var insertSnippet = "(".concat(insertKeysQuoted, ") VALUES(").concat(insertValuesEscaped, ")");
      var query = "MERGE INTO ".concat(tableNameQuoted, " WITH(HOLDLOCK) AS ").concat(targetTableAlias, " USING (").concat(sourceTableQuery, ") AS ").concat(sourceTableAlias, "(").concat(insertKeysQuoted, ") ON ").concat(joinCondition);
      query += " ".concat(updateSnippet, " WHEN NOT MATCHED THEN INSERT ").concat(insertSnippet, " OUTPUT $action, INSERTED.*;");

      if (needIdentityInsertWrapper) {
        query = "SET IDENTITY_INSERT ".concat(tableNameQuoted, " ON; ").concat(query, " SET IDENTITY_INSERT ").concat(tableNameQuoted, " OFF;");
      }

      return query;
    }
  }, {
    key: "truncateTableQuery",
    value: function truncateTableQuery(tableName) {
      return "TRUNCATE TABLE ".concat(this.quoteTable(tableName));
    }
  }, {
    key: "deleteQuery",
    value: function deleteQuery(tableName, where) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var model = arguments.length > 3 ? arguments[3] : undefined;
      var table = this.quoteTable(tableName);
      var whereClause = this.getWhereConditions(where, null, model, options);
      return Utils.joinSQLFragments(["DELETE", options.limit && "TOP(".concat(this.escape(options.limit), ")"), "FROM", table, whereClause && "WHERE ".concat(whereClause), ";", "SELECT @@ROWCOUNT AS AFFECTEDROWS", ";"]);
    }
  }, {
    key: "showIndexesQuery",
    value: function showIndexesQuery(tableName) {
      return "EXEC sys.sp_helpindex @objname = N'".concat(this.quoteTable(tableName), "';");
    }
  }, {
    key: "showConstraintsQuery",
    value: function showConstraintsQuery(tableName) {
      return "EXEC sp_helpconstraint @objname = ".concat(this.escape(this.quoteTable(tableName)), ";");
    }
  }, {
    key: "removeIndexQuery",
    value: function removeIndexQuery(tableName, indexNameOrAttributes) {
      var indexName = indexNameOrAttributes;

      if (typeof indexName !== "string") {
        indexName = Utils.underscore("".concat(tableName, "_").concat(indexNameOrAttributes.join("_")));
      }

      return "DROP INDEX ".concat(this.quoteIdentifiers(indexName), " ON ").concat(this.quoteIdentifiers(tableName));
    }
  }, {
    key: "attributeToSQL",
    value: function attributeToSQL(attribute, options) {
      var _this4 = this;

      if (!_.isPlainObject(attribute)) {
        attribute = {
          type: attribute
        };
      }

      if (attribute.references) {
        if (attribute.Model && attribute.Model.tableName === attribute.references.model) {
          this.sequelize.log("MSSQL does not support self referencial constraints, we will remove it but we recommend restructuring your query");
          attribute.onDelete = "";
          attribute.onUpdate = "";
        }
      }

      var template;

      if (attribute.type instanceof DataTypes.ENUM) {
        if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;
        template = attribute.type.toSql();
        template += " CHECK (".concat(this.quoteIdentifier(attribute.field), " IN(").concat(attribute.values.map(function (value) {
          return _this4.escape(value);
        }).join(", "), "))");
        return template;
      }

      template = attribute.type.toString();

      if (attribute.allowNull === false) {
        template += " NOT NULL";
      } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {
        template += " NULL";
      }

      if (attribute.autoIncrement) {
        template += " IDENTITY(1,1)";
      }

      if (attribute.type !== "TEXT" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {
        template += " DEFAULT ".concat(this.escape(attribute.defaultValue));
      }

      if (attribute.unique === true) {
        template += " UNIQUE";
      }

      if (attribute.primaryKey) {
        template += " PRIMARY KEY";
      }

      if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {
        template += " REFERENCES ".concat(this.quoteTable(attribute.references.model));

        if (attribute.references.key) {
          template += " (".concat(this.quoteIdentifier(attribute.references.key), ")");
        } else {
          template += " (".concat(this.quoteIdentifier("id"), ")");
        }

        if (attribute.onDelete) {
          template += " ON DELETE ".concat(attribute.onDelete.toUpperCase());
        }

        if (attribute.onUpdate) {
          template += " ON UPDATE ".concat(attribute.onUpdate.toUpperCase());
        }
      }

      if (attribute.comment && typeof attribute.comment === "string") {
        template += " COMMENT ".concat(attribute.comment);
      }

      return template;
    }
  }, {
    key: "attributesToSQL",
    value: function attributesToSQL(attributes, options) {
      var result = {},
          existingConstraints = [];
      var key, attribute;

      for (key in attributes) {
        attribute = attributes[key];

        if (attribute.references) {
          if (existingConstraints.includes(attribute.references.model.toString())) {
            attribute.onDelete = "";
            attribute.onUpdate = "";
          } else {
            existingConstraints.push(attribute.references.model.toString());
            attribute.onUpdate = "";
          }
        }

        if (key && !attribute.field) attribute.field = key;
        result[attribute.field || key] = this.attributeToSQL(attribute, options);
      }

      return result;
    }
  }, {
    key: "createTrigger",
    value: function createTrigger() {
      throwMethodUndefined("createTrigger");
    }
  }, {
    key: "dropTrigger",
    value: function dropTrigger() {
      throwMethodUndefined("dropTrigger");
    }
  }, {
    key: "renameTrigger",
    value: function renameTrigger() {
      throwMethodUndefined("renameTrigger");
    }
  }, {
    key: "createFunction",
    value: function createFunction() {
      throwMethodUndefined("createFunction");
    }
  }, {
    key: "dropFunction",
    value: function dropFunction() {
      throwMethodUndefined("dropFunction");
    }
  }, {
    key: "renameFunction",
    value: function renameFunction() {
      throwMethodUndefined("renameFunction");
    }
  }, {
    key: "_getForeignKeysQueryPrefix",
    value: function _getForeignKeysQueryPrefix(catalogName) {
      return "SELECT constraint_name = OBJ.NAME, constraintName = OBJ.NAME, ".concat(catalogName ? "constraintCatalog = '".concat(catalogName, "', ") : "", "constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), tableName = TB.NAME, tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ").concat(catalogName ? "tableCatalog = '".concat(catalogName, "', ") : "", "columnName = COL.NAME, referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ").concat(catalogName ? "referencedCatalog = '".concat(catalogName, "', ") : "", "referencedTableName = RTB.NAME, referencedColumnName = RCOL.NAME FROM sys.foreign_key_columns FKC INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID");
    }
  }, {
    key: "getForeignKeysQuery",
    value: function getForeignKeysQuery(table, catalogName) {
      var tableName = table.tableName || table;
      var sql = "".concat(this._getForeignKeysQueryPrefix(catalogName), " WHERE TB.NAME =").concat(wrapSingleQuote(tableName));

      if (table.schema) {
        sql += " AND SCHEMA_NAME(TB.SCHEMA_ID) =".concat(wrapSingleQuote(table.schema));
      }

      return sql;
    }
  }, {
    key: "getForeignKeyQuery",
    value: function getForeignKeyQuery(table, attributeName) {
      var tableName = table.tableName || table;
      return Utils.joinSQLFragments([this._getForeignKeysQueryPrefix(), "WHERE", "TB.NAME =".concat(wrapSingleQuote(tableName)), "AND", "COL.NAME =".concat(wrapSingleQuote(attributeName)), table.schema && "AND SCHEMA_NAME(TB.SCHEMA_ID) =".concat(wrapSingleQuote(table.schema))]);
    }
  }, {
    key: "getPrimaryKeyConstraintQuery",
    value: function getPrimaryKeyConstraintQuery(table, attributeName) {
      var tableName = wrapSingleQuote(table.tableName || table);
      return Utils.joinSQLFragments(["SELECT K.TABLE_NAME AS tableName,", "K.COLUMN_NAME AS columnName,", "K.CONSTRAINT_NAME AS constraintName", "FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C", "JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K", "ON C.TABLE_NAME = K.TABLE_NAME", "AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG", "AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA", "AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME", "WHERE C.CONSTRAINT_TYPE = 'PRIMARY KEY'", "AND K.COLUMN_NAME = ".concat(wrapSingleQuote(attributeName)), "AND K.TABLE_NAME = ".concat(tableName), ";"]);
    }
  }, {
    key: "dropForeignKeyQuery",
    value: function dropForeignKeyQuery(tableName, foreignKey) {
      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(tableName), "DROP", this.quoteIdentifier(foreignKey)]);
    }
  }, {
    key: "getDefaultConstraintQuery",
    value: function getDefaultConstraintQuery(tableName, attributeName) {
      var quotedTable = this.quoteTable(tableName);
      return Utils.joinSQLFragments(["SELECT name FROM sys.default_constraints", "WHERE PARENT_OBJECT_ID = OBJECT_ID('".concat(quotedTable, "', 'U')"), "AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('".concat(attributeName, "')"), "AND object_id = OBJECT_ID('".concat(quotedTable, "', 'U'))"), ";"]);
    }
  }, {
    key: "dropConstraintQuery",
    value: function dropConstraintQuery(tableName, constraintName) {
      return Utils.joinSQLFragments(["ALTER TABLE", this.quoteTable(tableName), "DROP CONSTRAINT", this.quoteIdentifier(constraintName), ";"]);
    }
  }, {
    key: "setIsolationLevelQuery",
    value: function setIsolationLevelQuery() {}
  }, {
    key: "generateTransactionId",
    value: function generateTransactionId() {
      return randomBytes(10).toString("hex");
    }
  }, {
    key: "startTransactionQuery",
    value: function startTransactionQuery(transaction) {
      if (transaction.parent) {
        return "SAVE TRANSACTION ".concat(this.quoteIdentifier(transaction.name), ";");
      }

      return "BEGIN TRANSACTION;";
    }
  }, {
    key: "commitTransactionQuery",
    value: function commitTransactionQuery(transaction) {
      if (transaction.parent) {
        return;
      }

      return "COMMIT TRANSACTION;";
    }
  }, {
    key: "rollbackTransactionQuery",
    value: function rollbackTransactionQuery(transaction) {
      if (transaction.parent) {
        return "ROLLBACK TRANSACTION ".concat(this.quoteIdentifier(transaction.name), ";");
      }

      return "ROLLBACK TRANSACTION;";
    }
  }, {
    key: "selectFromTableFragment",
    value: function selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {
      this._throwOnEmptyAttributes(attributes, {
        modelName: model && model.name,
        as: mainTableAs
      });

      var dbVersion = this.sequelize.options.databaseVersion;
      var isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, "11.0.0");

      if (isSQLServer2008 && options.offset) {
        var offset = options.offset || 0;
        var isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;
        var orders = {
          mainQueryOrder: []
        };

        if (options.order) {
          orders = this.getQueryOrders(options, model, isSubQuery);
        }

        if (orders.mainQueryOrder.length === 0) {
          orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));
        }

        var tmpTable = mainTableAs || "OffsetTable";

        if (options.include) {
          var subQuery = options.subQuery === void 0 ? options.limit && options.hasMultiAssociation : options.subQuery;
          var mainTable = {
            name: mainTableAs,
            quotedName: null,
            as: null,
            model: model
          };
          var topLevelInfo = {
            names: mainTable,
            options: options,
            subQuery: subQuery
          };
          var mainJoinQueries = [];
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = options.include[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var include = _step4.value;

              if (include.separate) {
                continue;
              }

              var joinQueries = this.generateInclude(include, {
                externalAs: mainTableAs,
                internalAs: mainTableAs
              }, topLevelInfo);
              mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          return Utils.joinSQLFragments(["SELECT TOP 100 PERCENT", attributes.join(", "), "FROM (", ["SELECT", options.limit && "TOP ".concat(options.limit), "* FROM (", ["SELECT ROW_NUMBER() OVER (", ["ORDER BY", orders.mainQueryOrder.join(", ")], ") as row_num, ".concat(tmpTable, ".* FROM ("), ["SELECT DISTINCT", "".concat(tmpTable, ".* FROM ").concat(tables, " AS ").concat(tmpTable), mainJoinQueries, where && "WHERE ".concat(where)], ") AS ".concat(tmpTable)], ") AS ".concat(tmpTable, " WHERE row_num > ").concat(offset)], ") AS ".concat(tmpTable)]);
        }

        return Utils.joinSQLFragments(["SELECT TOP 100 PERCENT", attributes.join(", "), "FROM (", ["SELECT", options.limit && "TOP ".concat(options.limit), "* FROM (", ["SELECT ROW_NUMBER() OVER (", ["ORDER BY", orders.mainQueryOrder.join(", ")], ") as row_num, * FROM ".concat(tables, " AS ").concat(tmpTable), where && "WHERE ".concat(where)], ") AS ".concat(tmpTable, " WHERE row_num > ").concat(offset)], ") AS ".concat(tmpTable)]);
      }

      return Utils.joinSQLFragments(["SELECT", isSQLServer2008 && options.limit && "TOP ".concat(options.limit), attributes.join(", "), "FROM ".concat(tables), mainTableAs && "AS ".concat(mainTableAs), options.tableHint && TableHints[options.tableHint] && "WITH (".concat(TableHints[options.tableHint], ")")]);
    }
  }, {
    key: "addLimitAndOffset",
    value: function addLimitAndOffset(options, model) {
      if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, "11.0.0")) {
        return "";
      }

      var offset = options.offset || 0;
      var isSubQuery = options.subQuery === void 0 ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation : options.subQuery;
      var fragment = "";
      var orders = {};

      if (options.order) {
        orders = this.getQueryOrders(options, model, isSubQuery);
      }

      if (options.limit || options.offset) {
        if (!options.order || options.order.length === 0 || options.include && orders.subQueryOrder.length === 0) {
          var primaryKey = model.primaryKeyField;
          var tablePkFragment = "".concat(this.quoteTable(options.tableAs || model.name), ".").concat(this.quoteIdentifier(primaryKey));
          var aliasedAttribute = (options.attributes || []).find(function (attr) {
            return Array.isArray(attr) && attr[1] && (attr[0] === primaryKey || attr[1] === primaryKey);
          });

          if (aliasedAttribute) {
            var modelName = this.quoteIdentifier(options.tableAs || model.name);

            var alias = this._getAliasForField(modelName, aliasedAttribute[1], options);

            primaryKey = new Utils.Col(alias || aliasedAttribute[1]);
          }

          if (!options.order || !options.order.length) {
            fragment += " ORDER BY ".concat(tablePkFragment);
          } else {
            var orderFieldNames = (options.order || []).map(function (order) {
              var value = Array.isArray(order) ? order[0] : order;

              if (value instanceof Utils.Col) {
                return value.col;
              }

              if (value instanceof Utils.Literal) {
                return value.val;
              }

              return value;
            });
            var primaryKeyFieldAlreadyPresent = orderFieldNames.some(function (fieldName) {
              return fieldName === (primaryKey.col || primaryKey);
            });

            if (!primaryKeyFieldAlreadyPresent) {
              fragment += options.order && !isSubQuery ? ", " : " ORDER BY ";
              fragment += tablePkFragment;
            }
          }
        }

        if (options.offset || options.limit) {
          fragment += " OFFSET ".concat(this.escape(offset), " ROWS");
        }

        if (options.limit) {
          fragment += " FETCH NEXT ".concat(this.escape(options.limit), " ROWS ONLY");
        }
      }

      return fragment;
    }
  }, {
    key: "booleanValue",
    value: function booleanValue(value) {
      return value ? 1 : 0;
    }
  }, {
    key: "quoteIdentifier",
    value: function quoteIdentifier(identifier, force) {
      return "[".concat(identifier.replace(/[[\]']+/g, ""), "]");
    }
  }]);

  return MSSQLQueryGenerator;
}(AbstractQueryGenerator);

function wrapSingleQuote(identifier) {
  return Utils.addTicks(Utils.removeTicks(identifier, "'"), "'");
}

module.exports = MSSQLQueryGenerator;