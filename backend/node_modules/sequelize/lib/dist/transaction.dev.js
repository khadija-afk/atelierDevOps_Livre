"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return a;
};

var Transaction =
/*#__PURE__*/
function () {
  function Transaction(sequelize, options) {
    _classCallCheck(this, Transaction);

    this.sequelize = sequelize;
    this.savepoints = [];
    this._afterCommitHooks = [];
    var generateTransactionId = this.sequelize.dialect.queryGenerator.generateTransactionId;
    this.options = __spreadValues({
      type: sequelize.options.transactionType,
      isolationLevel: sequelize.options.isolationLevel,
      readOnly: false
    }, options);
    this.parent = this.options.transaction;

    if (this.parent) {
      this.id = this.parent.id;
      this.parent.savepoints.push(this);
      this.name = "".concat(this.id, "-sp-").concat(this.parent.savepoints.length);
    } else {
      this.id = this.name = generateTransactionId();
    }

    delete this.options.transaction;
  }

  _createClass(Transaction, [{
    key: "commit",
    value: function commit() {
      var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, hook;

      return regeneratorRuntime.async(function commit$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this.finished) {
                _context.next = 2;
                break;
              }

              throw new Error("Transaction cannot be committed because it has been finished with state: ".concat(this.finished));

            case 2:
              _context.prev = 2;
              _context.next = 5;
              return regeneratorRuntime.awrap(this.sequelize.getQueryInterface().commitTransaction(this, this.options));

            case 5:
              this.cleanup();
              _context.next = 14;
              break;

            case 8:
              _context.prev = 8;
              _context.t0 = _context["catch"](2);
              console.warn("Committing transaction ".concat(this.id, " failed with error ").concat(JSON.stringify(_context.t0.message), ". We are killing its connection as it is now in an undetermined state."));
              _context.next = 13;
              return regeneratorRuntime.awrap(this.forceCleanup());

            case 13:
              throw _context.t0;

            case 14:
              _context.prev = 14;
              this.finished = "commit";
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context.prev = 19;
              _iterator2 = this._afterCommitHooks[Symbol.iterator]();

            case 21:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context.next = 28;
                break;
              }

              hook = _step2.value;
              _context.next = 25;
              return regeneratorRuntime.awrap(hook.apply(this, [this]));

            case 25:
              _iteratorNormalCompletion2 = true;
              _context.next = 21;
              break;

            case 28:
              _context.next = 34;
              break;

            case 30:
              _context.prev = 30;
              _context.t1 = _context["catch"](19);
              _didIteratorError2 = true;
              _iteratorError2 = _context.t1;

            case 34:
              _context.prev = 34;
              _context.prev = 35;

              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }

            case 37:
              _context.prev = 37;

              if (!_didIteratorError2) {
                _context.next = 40;
                break;
              }

              throw _iteratorError2;

            case 40:
              return _context.finish(37);

            case 41:
              return _context.finish(34);

            case 42:
              return _context.finish(14);

            case 43:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[2, 8, 14, 43], [19, 30, 34, 42], [35,, 37, 41]]);
    }
  }, {
    key: "rollback",
    value: function rollback() {
      return regeneratorRuntime.async(function rollback$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!this.finished) {
                _context2.next = 2;
                break;
              }

              throw new Error("Transaction cannot be rolled back because it has been finished with state: ".concat(this.finished));

            case 2:
              if (this.connection) {
                _context2.next = 4;
                break;
              }

              throw new Error("Transaction cannot be rolled back because it never started");

            case 4:
              _context2.prev = 4;
              _context2.next = 7;
              return regeneratorRuntime.awrap(this.sequelize.getQueryInterface().rollbackTransaction(this, this.options));

            case 7:
              this.cleanup();
              _context2.next = 16;
              break;

            case 10:
              _context2.prev = 10;
              _context2.t0 = _context2["catch"](4);
              console.warn("Rolling back transaction ".concat(this.id, " failed with error ").concat(JSON.stringify(_context2.t0.message), ". We are killing its connection as it is now in an undetermined state."));
              _context2.next = 15;
              return regeneratorRuntime.awrap(this.forceCleanup());

            case 15:
              throw _context2.t0;

            case 16:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[4, 10]]);
    }
  }, {
    key: "prepareEnvironment",
    value: function prepareEnvironment() {
      var useCLS,
          connectionPromise,
          acquireOptions,
          result,
          connection,
          _args3 = arguments;
      return regeneratorRuntime.async(function prepareEnvironment$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              useCLS = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : true;

              if (this.parent) {
                connectionPromise = Promise.resolve(this.parent.connection);
              } else {
                acquireOptions = {
                  uuid: this.id
                };

                if (this.options.readOnly) {
                  acquireOptions.type = "SELECT";
                }

                connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);
              }

              _context3.next = 4;
              return regeneratorRuntime.awrap(connectionPromise);

            case 4:
              connection = _context3.sent;
              this.connection = connection;
              this.connection.uuid = this.id;
              _context3.prev = 7;
              _context3.next = 10;
              return regeneratorRuntime.awrap(this.begin());

            case 10:
              _context3.next = 12;
              return regeneratorRuntime.awrap(this.setDeferrable());

            case 12:
              result = _context3.sent;
              _context3.next = 24;
              break;

            case 15:
              _context3.prev = 15;
              _context3.t0 = _context3["catch"](7);
              _context3.prev = 17;
              _context3.next = 20;
              return regeneratorRuntime.awrap(this.rollback());

            case 20:
              result = _context3.sent;

            case 21:
              _context3.prev = 21;
              throw _context3.t0;

            case 24:
              if (useCLS && this.sequelize.constructor._cls) {
                this.sequelize.constructor._cls.set("transaction", this);
              }

              return _context3.abrupt("return", result);

            case 26:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this, [[7, 15], [17,, 21, 24]]);
    }
  }, {
    key: "setDeferrable",
    value: function setDeferrable() {
      return regeneratorRuntime.async(function setDeferrable$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!this.options.deferrable) {
                _context4.next = 4;
                break;
              }

              _context4.next = 3;
              return regeneratorRuntime.awrap(this.sequelize.getQueryInterface().deferConstraints(this, this.options));

            case 3:
              return _context4.abrupt("return", _context4.sent);

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "begin",
    value: function begin() {
      var queryInterface;
      return regeneratorRuntime.async(function begin$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              queryInterface = this.sequelize.getQueryInterface();

              if (!this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction) {
                _context5.next = 5;
                break;
              }

              _context5.next = 4;
              return regeneratorRuntime.awrap(queryInterface.startTransaction(this, this.options));

            case 4:
              return _context5.abrupt("return", queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options));

            case 5:
              _context5.next = 7;
              return regeneratorRuntime.awrap(queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options));

            case 7:
              return _context5.abrupt("return", queryInterface.startTransaction(this, this.options));

            case 8:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      if (this.parent || this.connection.uuid === void 0) {
        return;
      }

      this._clearCls();

      this.sequelize.connectionManager.releaseConnection(this.connection);
      this.connection.uuid = void 0;
    }
  }, {
    key: "forceCleanup",
    value: function forceCleanup() {
      return regeneratorRuntime.async(function forceCleanup$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (!(this.parent || this.connection.uuid === void 0)) {
                _context6.next = 2;
                break;
              }

              return _context6.abrupt("return");

            case 2:
              this._clearCls();

              _context6.next = 5;
              return regeneratorRuntime.awrap(this.sequelize.connectionManager.destroyConnection(this.connection));

            case 5:
              this.connection.uuid = void 0;

            case 6:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_clearCls",
    value: function _clearCls() {
      var cls = this.sequelize.constructor._cls;

      if (cls) {
        if (cls.get("transaction") === this) {
          cls.set("transaction", null);
        }
      }
    }
  }, {
    key: "afterCommit",
    value: function afterCommit(fn) {
      if (!fn || typeof fn !== "function") {
        throw new Error('"fn" must be a function');
      }

      this._afterCommitHooks.push(fn);
    }
  }, {
    key: "LOCK",
    get: function get() {
      return Transaction.LOCK;
    }
  }], [{
    key: "TYPES",
    get: function get() {
      return {
        DEFERRED: "DEFERRED",
        IMMEDIATE: "IMMEDIATE",
        EXCLUSIVE: "EXCLUSIVE"
      };
    }
  }, {
    key: "ISOLATION_LEVELS",
    get: function get() {
      return {
        READ_UNCOMMITTED: "READ UNCOMMITTED",
        READ_COMMITTED: "READ COMMITTED",
        REPEATABLE_READ: "REPEATABLE READ",
        SERIALIZABLE: "SERIALIZABLE"
      };
    }
  }, {
    key: "LOCK",
    get: function get() {
      return {
        UPDATE: "UPDATE",
        SHARE: "SHARE",
        KEY_SHARE: "KEY SHARE",
        NO_KEY_UPDATE: "NO KEY UPDATE"
      };
    }
  }]);

  return Transaction;
}();

module.exports = Transaction;
module.exports.Transaction = Transaction;
module.exports["default"] = Transaction;