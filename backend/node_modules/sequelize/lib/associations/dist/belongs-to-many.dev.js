"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return a;
};

var __spreadProps = function __spreadProps(a, b) {
  return __defProps(a, __getOwnPropDescs(b));
};

var Utils = require("./../utils");

var Helpers = require("./helpers");

var _ = require("lodash");

var Association = require("./base");

var BelongsTo = require("./belongs-to");

var HasMany = require("./has-many");

var HasOne = require("./has-one");

var AssociationError = require("../errors").AssociationError;

var EmptyResultError = require("../errors").EmptyResultError;

var Op = require("../operators");

var BelongsToMany =
/*#__PURE__*/
function (_Association) {
  _inherits(BelongsToMany, _Association);

  function BelongsToMany(source, target, options) {
    var _this;

    _classCallCheck(this, BelongsToMany);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BelongsToMany).call(this, source, target, options));

    if (_this.options.through === void 0 || _this.options.through === true || _this.options.through === null) {
      throw new AssociationError("".concat(source.name, ".belongsToMany(").concat(target.name, ") requires through option, pass either a string or a model"));
    }

    if (!_this.options.through.model) {
      _this.options.through = {
        model: options.through
      };
    }

    _this.associationType = "BelongsToMany";
    _this.targetAssociation = null;
    _this.sequelize = source.sequelize;
    _this.through = __spreadValues({}, _this.options.through);
    _this.isMultiAssociation = true;
    _this.doubleLinked = false;

    if (!_this.as && _this.isSelfAssociation) {
      throw new AssociationError("'as' must be defined for many-to-many self-associations");
    }

    if (_this.as) {
      _this.isAliased = true;

      if (_.isPlainObject(_this.as)) {
        _this.options.name = _this.as;
        _this.as = _this.as.plural;
      } else {
        _this.options.name = {
          plural: _this.as,
          singular: Utils.singularize(_this.as)
        };
      }
    } else {
      _this.as = _this.target.options.name.plural;
      _this.options.name = _this.target.options.name;
    }

    _this.combinedTableName = Utils.combineTableNames(_this.source.tableName, _this.isSelfAssociation ? _this.as || _this.target.tableName : _this.target.tableName);

    if (_this.isSelfAssociation) {
      _this.targetAssociation = _assertThisInitialized(_this);
    }

    _.each(_this.target.associations, function (association) {
      if (association.associationType !== "BelongsToMany") return;
      if (association.target !== _this.source) return;

      if (_this.options.through.model === association.options.through.model) {
        _this.paired = association;
        association.paired = _assertThisInitialized(_this);
      }
    });

    _this.sourceKey = _this.options.sourceKey || _this.source.primaryKeyAttribute;
    _this.sourceKeyField = _this.source.rawAttributes[_this.sourceKey].field || _this.sourceKey;

    if (_this.options.targetKey) {
      _this.targetKey = _this.options.targetKey;
      _this.targetKeyField = _this.target.rawAttributes[_this.targetKey].field || _this.targetKey;
    } else {
      _this.targetKeyDefault = true;
      _this.targetKey = _this.target.primaryKeyAttribute;
      _this.targetKeyField = _this.target.rawAttributes[_this.targetKey].field || _this.targetKey;
    }

    _this._createForeignAndOtherKeys();

    if (typeof _this.through.model === "string") {
      if (!_this.sequelize.isDefined(_this.through.model)) {
        _this.through.model = _this.sequelize.define(_this.through.model, {}, Object.assign(_this.options, {
          tableName: _this.through.model,
          indexes: [],
          paranoid: _this.through.paranoid ? _this.through.paranoid : false,
          validate: {}
        }));
      } else {
        _this.through.model = _this.sequelize.model(_this.through.model);
      }
    }

    Object.assign(_this.options, _.pick(_this.through.model.options, ["timestamps", "createdAt", "updatedAt", "deletedAt", "paranoid"]));

    if (_this.paired) {
      var needInjectPaired = false;

      if (_this.targetKeyDefault) {
        _this.targetKey = _this.paired.sourceKey;
        _this.targetKeyField = _this.paired.sourceKeyField;

        _this._createForeignAndOtherKeys();
      }

      if (_this.paired.targetKeyDefault) {
        if (_this.paired.targetKey !== _this.sourceKey) {
          delete _this.through.model.rawAttributes[_this.paired.otherKey];
          _this.paired.targetKey = _this.sourceKey;
          _this.paired.targetKeyField = _this.sourceKeyField;

          _this.paired._createForeignAndOtherKeys();

          needInjectPaired = true;
        }
      }

      if (_this.otherKeyDefault) {
        _this.otherKey = _this.paired.foreignKey;
      }

      if (_this.paired.otherKeyDefault) {
        if (_this.paired.otherKey !== _this.foreignKey) {
          delete _this.through.model.rawAttributes[_this.paired.otherKey];
          _this.paired.otherKey = _this.foreignKey;
          needInjectPaired = true;
        }
      }

      if (needInjectPaired) {
        _this.paired._injectAttributes();
      }
    }

    if (_this.through) {
      _this.throughModel = _this.through.model;
    }

    _this.options.tableName = _this.combinedName = _this.through.model === Object(_this.through.model) ? _this.through.model.tableName : _this.through.model;
    _this.associationAccessor = _this.as;

    var plural = _.upperFirst(_this.options.name.plural);

    var singular = _.upperFirst(_this.options.name.singular);

    _this.accessors = {
      get: "get".concat(plural),
      set: "set".concat(plural),
      addMultiple: "add".concat(plural),
      add: "add".concat(singular),
      create: "create".concat(singular),
      remove: "remove".concat(singular),
      removeMultiple: "remove".concat(plural),
      hasSingle: "has".concat(singular),
      hasAll: "has".concat(plural),
      count: "count".concat(plural)
    };
    return _this;
  }

  _createClass(BelongsToMany, [{
    key: "_createForeignAndOtherKeys",
    value: function _createForeignAndOtherKeys() {
      if (_.isObject(this.options.foreignKey)) {
        this.foreignKeyAttribute = this.options.foreignKey;
        this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
      } else {
        this.foreignKeyAttribute = {};
        this.foreignKey = this.options.foreignKey || Utils.camelize([this.source.options.name.singular, this.sourceKey].join("_"));
      }

      if (_.isObject(this.options.otherKey)) {
        this.otherKeyAttribute = this.options.otherKey;
        this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;
      } else {
        if (!this.options.otherKey) {
          this.otherKeyDefault = true;
        }

        this.otherKeyAttribute = {};
        this.otherKey = this.options.otherKey || Utils.camelize([this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular, this.targetKey].join("_"));
      }
    }
  }, {
    key: "_injectAttributes",
    value: function _injectAttributes() {
      var _this2 = this;

      this.identifier = this.foreignKey;
      this.foreignIdentifier = this.otherKey;

      _.each(this.through.model.rawAttributes, function (attribute, attributeName) {
        if (attribute.primaryKey === true && attribute._autoGenerated === true) {
          if ([_this2.foreignKey, _this2.otherKey].includes(attributeName)) {
            attribute.primaryKey = false;
          } else {
            delete _this2.through.model.rawAttributes[attributeName];
          }

          _this2.primaryKeyDeleted = true;
        }
      });

      var sourceKey = this.source.rawAttributes[this.sourceKey];
      var sourceKeyType = sourceKey.type;
      var sourceKeyField = this.sourceKeyField;
      var targetKey = this.target.rawAttributes[this.targetKey];
      var targetKeyType = targetKey.type;
      var targetKeyField = this.targetKeyField;

      var sourceAttribute = __spreadValues({
        type: sourceKeyType
      }, this.foreignKeyAttribute);

      var targetAttribute = __spreadValues({
        type: targetKeyType
      }, this.otherKeyAttribute);

      if (this.primaryKeyDeleted === true) {
        targetAttribute.primaryKey = sourceAttribute.primaryKey = true;
      } else if (this.through.unique !== false) {
        var uniqueKey;

        if (typeof this.options.uniqueKey === "string" && this.options.uniqueKey !== "") {
          uniqueKey = this.options.uniqueKey;
        } else {
          uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, "unique"].join("_");
        }

        targetAttribute.unique = sourceAttribute.unique = uniqueKey;
      }

      if (!this.through.model.rawAttributes[this.foreignKey]) {
        this.through.model.rawAttributes[this.foreignKey] = {
          _autoGenerated: true
        };
      }

      if (!this.through.model.rawAttributes[this.otherKey]) {
        this.through.model.rawAttributes[this.otherKey] = {
          _autoGenerated: true
        };
      }

      if (this.options.constraints !== false) {
        sourceAttribute.references = {
          model: this.source.getTableName(),
          key: sourceKeyField
        };
        sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;
        sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;
        if (!sourceAttribute.onDelete) sourceAttribute.onDelete = "CASCADE";
        if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = "CASCADE";
        targetAttribute.references = {
          model: this.target.getTableName(),
          key: targetKeyField
        };
        targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;
        targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;
        if (!targetAttribute.onDelete) targetAttribute.onDelete = "CASCADE";
        if (!targetAttribute.onUpdate) targetAttribute.onUpdate = "CASCADE";
      }

      Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);
      Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);
      this.through.model.refreshAttributes();
      this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;
      this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;

      if (this.options.sequelize.options.dialect === "db2" && this.source.rawAttributes[this.sourceKey].primaryKey !== true) {
        this.source.rawAttributes[this.sourceKey].unique = true;
      }

      if (this.paired && !this.paired.foreignIdentifierField) {
        this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;
      }

      this.toSource = new BelongsTo(this.through.model, this.source, {
        foreignKey: this.foreignKey
      });
      this.manyFromSource = new HasMany(this.source, this.through.model, {
        foreignKey: this.foreignKey
      });
      this.oneFromSource = new HasOne(this.source, this.through.model, {
        foreignKey: this.foreignKey,
        sourceKey: this.sourceKey,
        as: this.through.model.name
      });
      this.toTarget = new BelongsTo(this.through.model, this.target, {
        foreignKey: this.otherKey
      });
      this.manyFromTarget = new HasMany(this.target, this.through.model, {
        foreignKey: this.otherKey
      });
      this.oneFromTarget = new HasOne(this.target, this.through.model, {
        foreignKey: this.otherKey,
        sourceKey: this.targetKey,
        as: this.through.model.name
      });

      if (this.paired && this.paired.otherKeyDefault) {
        this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {
          foreignKey: this.paired.otherKey
        });
        this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {
          foreignKey: this.paired.otherKey,
          sourceKey: this.paired.targetKey,
          as: this.paired.through.model.name
        });
      }

      Helpers.checkNamingCollision(this);
      return this;
    }
  }, {
    key: "mixin",
    value: function mixin(obj) {
      var methods = ["get", "count", "hasSingle", "hasAll", "set", "add", "addMultiple", "remove", "removeMultiple", "create"];
      var aliases = {
        hasSingle: "has",
        hasAll: "has",
        addMultiple: "add",
        removeMultiple: "remove"
      };
      Helpers.mixinMethods(this, obj, methods, aliases);
    }
  }, {
    key: "get",
    value: function get(instance, options) {
      var through, scopeWhere, throughWhere, model;
      return regeneratorRuntime.async(function get$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              options = Utils.cloneDeep(options) || {};
              through = this.through;

              if (this.scope) {
                scopeWhere = __spreadValues({}, this.scope);
              }

              options.where = _defineProperty({}, Op.and, [scopeWhere, options.where]);

              if (Object(through.model) === through.model) {
                throughWhere = {};
                throughWhere[this.foreignKey] = instance.get(this.sourceKey);

                if (through.scope) {
                  Object.assign(throughWhere, through.scope);
                }

                if (options.through && options.through.where) {
                  throughWhere = _defineProperty({}, Op.and, [throughWhere, options.through.where]);
                }

                options.include = options.include || [];
                options.include.push({
                  association: this.oneFromTarget,
                  attributes: options.joinTableAttributes,
                  required: true,
                  paranoid: _.get(options.through, "paranoid", true),
                  where: throughWhere
                });
              }

              model = this.target;

              if (Object.prototype.hasOwnProperty.call(options, "scope")) {
                if (!options.scope) {
                  model = model.unscoped();
                } else {
                  model = model.scope(options.scope);
                }
              }

              if (Object.prototype.hasOwnProperty.call(options, "schema")) {
                model = model.schema(options.schema, options.schemaDelimiter);
              }

              return _context.abrupt("return", model.findAll(options));

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "count",
    value: function count(instance, options) {
      var sequelize, result;
      return regeneratorRuntime.async(function count$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              sequelize = this.target.sequelize;
              options = Utils.cloneDeep(options);
              options.attributes = [[sequelize.fn("COUNT", sequelize.col([this.target.name, this.targetKeyField].join("."))), "count"]];
              options.joinTableAttributes = [];
              options.raw = true;
              options.plain = true;
              _context2.next = 8;
              return regeneratorRuntime.awrap(this.get(instance, options));

            case 8:
              result = _context2.sent;
              return _context2.abrupt("return", parseInt(result.count, 10));

            case 10:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "has",
    value: function has(sourceInstance, instances, options) {
      var _this3 = this;

      var instancePrimaryKeys, associatedObjects;
      return regeneratorRuntime.async(function has$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!Array.isArray(instances)) {
                instances = [instances];
              }

              options = __spreadProps(__spreadValues({
                raw: true
              }, options), {
                scope: false,
                attributes: [this.targetKey],
                joinTableAttributes: []
              });
              instancePrimaryKeys = instances.map(function (instance) {
                if (instance instanceof _this3.target) {
                  return instance.where();
                }

                return _defineProperty({}, _this3.targetKey, instance);
              });
              options.where = _defineProperty({}, Op.and, [_defineProperty({}, Op.or, instancePrimaryKeys), options.where]);
              _context3.next = 6;
              return regeneratorRuntime.awrap(this.get(sourceInstance, options));

            case 6:
              associatedObjects = _context3.sent;
              return _context3.abrupt("return", _.differenceWith(instancePrimaryKeys, associatedObjects, function (a, b) {
                return _.isEqual(a[_this3.targetKey], b[_this3.targetKey]);
              }).length === 0);

            case 8:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "set",
    value: function set(sourceInstance, newAssociatedObjects, options) {
      var _this4 = this;

      var sourceKey, targetKey, identifier, foreignIdentifier, where, updateAssociations, currentRows;
      return regeneratorRuntime.async(function set$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              options = options || {};
              sourceKey = this.sourceKey;
              targetKey = this.targetKey;
              identifier = this.identifier;
              foreignIdentifier = this.foreignIdentifier;

              if (newAssociatedObjects === null) {
                newAssociatedObjects = [];
              } else {
                newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);
              }

              where = __spreadValues(_defineProperty({}, identifier, sourceInstance.get(sourceKey)), this.through.scope);

              updateAssociations = function updateAssociations(currentRows) {
                var obsoleteAssociations = [];
                var promises = [];
                var defaultAttributes = options.through || {};
                var unassociatedObjects = newAssociatedObjects.filter(function (obj) {
                  return !currentRows.some(function (currentRow) {
                    return currentRow[foreignIdentifier] === obj.get(targetKey);
                  });
                });
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                  var _loop = function _loop() {
                    var currentRow = _step2.value;
                    var newObj = newAssociatedObjects.find(function (obj) {
                      return currentRow[foreignIdentifier] === obj.get(targetKey);
                    });

                    if (!newObj) {
                      obsoleteAssociations.push(currentRow);
                    } else {
                      var throughAttributes = newObj[_this4.through.model.name];

                      if (throughAttributes instanceof _this4.through.model) {
                        throughAttributes = {};
                      }

                      var attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);

                      if (Object.keys(attributes).length) {
                        var _where;

                        promises.push(_this4.through.model.update(attributes, Object.assign(options, {
                          where: (_where = {}, _defineProperty(_where, identifier, sourceInstance.get(sourceKey)), _defineProperty(_where, foreignIdentifier, newObj.get(targetKey)), _where)
                        })));
                      }
                    }
                  };

                  for (var _iterator2 = currentRows[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    _loop();
                  }
                } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                      _iterator2["return"]();
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2;
                    }
                  }
                }

                if (obsoleteAssociations.length > 0) {
                  var _spreadValues2;

                  promises.push(_this4.through.model.destroy(__spreadProps(__spreadValues({}, options), {
                    where: __spreadValues((_spreadValues2 = {}, _defineProperty(_spreadValues2, identifier, sourceInstance.get(sourceKey)), _defineProperty(_spreadValues2, foreignIdentifier, obsoleteAssociations.map(function (obsoleteAssociation) {
                      return obsoleteAssociation[foreignIdentifier];
                    })), _spreadValues2), _this4.through.scope)
                  })));
                }

                if (unassociatedObjects.length > 0) {
                  var bulk = unassociatedObjects.map(function (unassociatedObject) {
                    var _spreadProps;

                    return __spreadValues(__spreadProps(__spreadValues(__spreadValues({}, defaultAttributes), unassociatedObject[_this4.through.model.name]), (_spreadProps = {}, _defineProperty(_spreadProps, identifier, sourceInstance.get(sourceKey)), _defineProperty(_spreadProps, foreignIdentifier, unassociatedObject.get(targetKey)), _spreadProps)), _this4.through.scope);
                  });
                  promises.push(_this4.through.model.bulkCreate(bulk, __spreadValues({
                    validate: true
                  }, options)));
                }

                return Promise.all(promises);
              };

              _context4.prev = 8;
              _context4.next = 11;
              return regeneratorRuntime.awrap(this.through.model.findAll(__spreadProps(__spreadValues({}, options), {
                where: where,
                raw: true
              })));

            case 11:
              currentRows = _context4.sent;
              _context4.next = 14;
              return regeneratorRuntime.awrap(updateAssociations(currentRows));

            case 14:
              return _context4.abrupt("return", _context4.sent);

            case 17:
              _context4.prev = 17;
              _context4.t0 = _context4["catch"](8);

              if (!(_context4.t0 instanceof EmptyResultError)) {
                _context4.next = 21;
                break;
              }

              return _context4.abrupt("return", updateAssociations([]));

            case 21:
              throw _context4.t0;

            case 22:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this, [[8, 17]]);
    }
  }, {
    key: "add",
    value: function add(sourceInstance, newInstances, options) {
      var _spreadValues3;

      var association, sourceKey, targetKey, identifier, foreignIdentifier, defaultAttributes, where, updateAssociations, currentRows, _ref3, _ref4, associations;

      return regeneratorRuntime.async(function add$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (newInstances) {
                _context5.next = 2;
                break;
              }

              return _context5.abrupt("return", Promise.resolve());

            case 2:
              options = __spreadValues({}, options);
              association = this;
              sourceKey = association.sourceKey;
              targetKey = association.targetKey;
              identifier = association.identifier;
              foreignIdentifier = association.foreignIdentifier;
              defaultAttributes = options.through || {};
              newInstances = association.toInstanceArray(newInstances);
              where = __spreadValues((_spreadValues3 = {}, _defineProperty(_spreadValues3, identifier, sourceInstance.get(sourceKey)), _defineProperty(_spreadValues3, foreignIdentifier, newInstances.map(function (newInstance) {
                return newInstance.get(targetKey);
              })), _spreadValues3), association.through.scope);

              updateAssociations = function updateAssociations(currentRows) {
                var promises = [];
                var unassociatedObjects = [];
                var changedAssociations = [];
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                  var _loop2 = function _loop2() {
                    var obj = _step3.value;
                    var existingAssociation = currentRows && currentRows.find(function (current) {
                      return current[foreignIdentifier] === obj.get(targetKey);
                    });

                    if (!existingAssociation) {
                      unassociatedObjects.push(obj);
                    } else {
                      var throughAttributes = obj[association.through.model.name];

                      var attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);

                      if (Object.keys(attributes).some(function (attribute) {
                        return attributes[attribute] !== existingAssociation[attribute];
                      })) {
                        changedAssociations.push(obj);
                      }
                    }
                  };

                  for (var _iterator3 = newInstances[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    _loop2();
                  }
                } catch (err) {
                  _didIteratorError3 = true;
                  _iteratorError3 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                      _iterator3["return"]();
                    }
                  } finally {
                    if (_didIteratorError3) {
                      throw _iteratorError3;
                    }
                  }
                }

                if (unassociatedObjects.length > 0) {
                  var bulk = unassociatedObjects.map(function (unassociatedObject) {
                    var throughAttributes = unassociatedObject[association.through.model.name];

                    var attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);

                    attributes[identifier] = sourceInstance.get(sourceKey);
                    attributes[foreignIdentifier] = unassociatedObject.get(targetKey);
                    Object.assign(attributes, association.through.scope);
                    return attributes;
                  });
                  promises.push(association.through.model.bulkCreate(bulk, __spreadValues({
                    validate: true
                  }, options)));
                }

                for (var _i = 0, _changedAssociations = changedAssociations; _i < _changedAssociations.length; _i++) {
                  var _where2;

                  var assoc = _changedAssociations[_i];
                  var throughAttributes = assoc[association.through.model.name];

                  var attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);

                  if (throughAttributes instanceof association.through.model) {
                    throughAttributes = {};
                  }

                  promises.push(association.through.model.update(attributes, Object.assign(options, {
                    where: (_where2 = {}, _defineProperty(_where2, identifier, sourceInstance.get(sourceKey)), _defineProperty(_where2, foreignIdentifier, assoc.get(targetKey)), _where2)
                  })));
                }

                return Promise.all(promises);
              };

              _context5.prev = 12;
              _context5.next = 15;
              return regeneratorRuntime.awrap(association.through.model.findAll(__spreadProps(__spreadValues({}, options), {
                where: where,
                raw: true
              })));

            case 15:
              currentRows = _context5.sent;
              _context5.next = 18;
              return regeneratorRuntime.awrap(updateAssociations(currentRows));

            case 18:
              _ref3 = _context5.sent;
              _ref4 = _slicedToArray(_ref3, 1);
              associations = _ref4[0];
              return _context5.abrupt("return", associations);

            case 24:
              _context5.prev = 24;
              _context5.t0 = _context5["catch"](12);

              if (!(_context5.t0 instanceof EmptyResultError)) {
                _context5.next = 28;
                break;
              }

              return _context5.abrupt("return", updateAssociations());

            case 28:
              throw _context5.t0;

            case 29:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this, [[12, 24]]);
    }
  }, {
    key: "remove",
    value: function remove(sourceInstance, oldAssociatedObjects, options) {
      var _where3;

      var association = this;
      options = options || {};
      oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);
      var where = (_where3 = {}, _defineProperty(_where3, association.identifier, sourceInstance.get(association.sourceKey)), _defineProperty(_where3, association.foreignIdentifier, oldAssociatedObjects.map(function (newInstance) {
        return newInstance.get(association.targetKey);
      })), _where3);
      return association.through.model.destroy(__spreadProps(__spreadValues({}, options), {
        where: where
      }));
    }
  }, {
    key: "create",
    value: function create(sourceInstance, values, options) {
      var association, newAssociatedObject;
      return regeneratorRuntime.async(function create$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              association = this;
              options = options || {};
              values = values || {};

              if (Array.isArray(options)) {
                options = {
                  fields: options
                };
              }

              if (association.scope) {
                Object.assign(values, association.scope);

                if (options.fields) {
                  options.fields = options.fields.concat(Object.keys(association.scope));
                }
              }

              _context6.next = 7;
              return regeneratorRuntime.awrap(association.target.create(values, options));

            case 7:
              newAssociatedObject = _context6.sent;
              _context6.next = 10;
              return regeneratorRuntime.awrap(sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ["fields"])));

            case 10:
              return _context6.abrupt("return", newAssociatedObject);

            case 11:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "verifyAssociationAlias",
    value: function verifyAssociationAlias(alias) {
      if (typeof alias === "string") {
        return this.as === alias;
      }

      if (alias && alias.plural) {
        return this.as === alias.plural;
      }

      return !this.isAliased;
    }
  }]);

  return BelongsToMany;
}(Association);

module.exports = BelongsToMany;
module.exports.BelongsToMany = BelongsToMany;
module.exports["default"] = BelongsToMany;