'use strict'; // https://mysqlserverteam.com/mysql-8-0-4-new-default-authentication-plugin-caching_sha2_password/

var PLUGIN_NAME = 'caching_sha2_password';

var crypto = require('crypto');

var _require = require('../auth_41'),
    xor = _require.xor,
    xorRotating = _require.xorRotating;

var REQUEST_SERVER_KEY_PACKET = Buffer.from([2]);
var FAST_AUTH_SUCCESS_PACKET = Buffer.from([3]);
var PERFORM_FULL_AUTHENTICATION_PACKET = Buffer.from([4]);
var STATE_INITIAL = 0;
var STATE_TOKEN_SENT = 1;
var STATE_WAIT_SERVER_KEY = 2;
var STATE_FINAL = -1;

function sha256(msg) {
  var hash = crypto.createHash('sha256');
  hash.update(msg);
  return hash.digest();
}

function calculateToken(password, scramble) {
  if (!password) {
    return Buffer.alloc(0);
  }

  var stage1 = sha256(Buffer.from(password));
  var stage2 = sha256(stage1);
  var stage3 = sha256(Buffer.concat([stage2, scramble]));
  return xor(stage1, stage3);
}

function encrypt(password, scramble, key) {
  var stage1 = xorRotating(Buffer.from("".concat(password, "\0"), 'utf8'), scramble);
  return crypto.publicEncrypt({
    key: key,
    padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
  }, stage1);
}

module.exports = function () {
  var pluginOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (_ref) {
    var connection = _ref.connection;
    var state = 0;
    var scramble = null;
    var password = connection.config.password;

    var authWithKey = function authWithKey(serverKey) {
      var _password = encrypt(password, scramble, serverKey);

      state = STATE_FINAL;
      return _password;
    };

    return function (data) {
      switch (state) {
        case STATE_INITIAL:
          scramble = data.slice(0, 20);
          state = STATE_TOKEN_SENT;
          return calculateToken(password, scramble);

        case STATE_TOKEN_SENT:
          if (FAST_AUTH_SUCCESS_PACKET.equals(data)) {
            state = STATE_FINAL;
            return null;
          }

          if (PERFORM_FULL_AUTHENTICATION_PACKET.equals(data)) {
            var isSecureConnection = typeof pluginOptions.overrideIsSecure === 'undefined' ? connection.config.ssl || connection.config.socketPath : pluginOptions.overrideIsSecure;

            if (isSecureConnection) {
              state = STATE_FINAL;
              return Buffer.from("".concat(password, "\0"), 'utf8');
            } // if client provides key we can save one extra roundrip on first connection


            if (pluginOptions.serverPublicKey) {
              return authWithKey(pluginOptions.serverPublicKey);
            }

            state = STATE_WAIT_SERVER_KEY;
            return REQUEST_SERVER_KEY_PACKET;
          }

          throw new Error("Invalid AuthMoreData packet received by ".concat(PLUGIN_NAME, " plugin in STATE_TOKEN_SENT state."));

        case STATE_WAIT_SERVER_KEY:
          if (pluginOptions.onServerPublicKey) {
            pluginOptions.onServerPublicKey(data);
          }

          return authWithKey(data);

        case STATE_FINAL:
          throw new Error("Unexpected data in AuthMoreData packet received by ".concat(PLUGIN_NAME, " plugin in STATE_FINAL state."));
      }

      throw new Error("Unexpected data in AuthMoreData packet received by ".concat(PLUGIN_NAME, " plugin in state ").concat(state));
    };
  };
};