"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return a;
};

var _ = require("lodash");

var Utils = require("./utils");

var sequelizeError = require("./errors");

var DataTypes = require("./data-types");

var BelongsTo = require("./associations/belongs-to");

var validator = require("./utils/validator-extras").validator;

var _require = require("util"),
    promisify = _require.promisify;

var InstanceValidator =
/*#__PURE__*/
function () {
  function InstanceValidator(modelInstance, options) {
    _classCallCheck(this, InstanceValidator);

    options = __spreadValues({
      hooks: true
    }, options);

    if (options.fields && !options.skip) {
      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);
    } else {
      options.skip = options.skip || [];
    }

    this.options = options;
    this.modelInstance = modelInstance;
    this.validator = validator;
    this.errors = [];
    this.inProgress = false;
  }

  _createClass(InstanceValidator, [{
    key: "_validate",
    value: function _validate() {
      return regeneratorRuntime.async(function _validate$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this.inProgress) {
                _context.next = 2;
                break;
              }

              throw new Error("Validations already in progress.");

            case 2:
              this.inProgress = true;
              _context.next = 5;
              return regeneratorRuntime.awrap(Promise.all([this._perAttributeValidators(), this._customValidators()]));

            case 5:
              if (!this.errors.length) {
                _context.next = 7;
                break;
              }

              throw new sequelizeError.ValidationError(null, this.errors);

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "validate",
    value: function validate() {
      return regeneratorRuntime.async(function validate$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return regeneratorRuntime.awrap(this.options.hooks ? this._validateAndRunHooks() : this._validate());

            case 2:
              return _context2.abrupt("return", _context2.sent);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_validateAndRunHooks",
    value: function _validateAndRunHooks() {
      var runHooks, newError;
      return regeneratorRuntime.async(function _validateAndRunHooks$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);
              _context3.next = 3;
              return regeneratorRuntime.awrap(runHooks("beforeValidate", this.modelInstance, this.options));

            case 3:
              _context3.prev = 3;
              _context3.next = 6;
              return regeneratorRuntime.awrap(this._validate());

            case 6:
              _context3.next = 14;
              break;

            case 8:
              _context3.prev = 8;
              _context3.t0 = _context3["catch"](3);
              _context3.next = 12;
              return regeneratorRuntime.awrap(runHooks("validationFailed", this.modelInstance, this.options, _context3.t0));

            case 12:
              newError = _context3.sent;
              throw newError || _context3.t0;

            case 14:
              _context3.next = 16;
              return regeneratorRuntime.awrap(runHooks("afterValidate", this.modelInstance, this.options));

            case 16:
              return _context3.abrupt("return", this.modelInstance);

            case 17:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this, [[3, 8]]);
    }
  }, {
    key: "_perAttributeValidators",
    value: function _perAttributeValidators() {
      var _this = this;

      var validators;
      return regeneratorRuntime.async(function _perAttributeValidators$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              validators = [];

              _.forIn(this.modelInstance.rawAttributes, function (rawAttribute, field) {
                if (_this.options.skip.includes(field)) {
                  return;
                }

                var value = _this.modelInstance.dataValues[field];

                if (value instanceof Utils.SequelizeMethod) {
                  return;
                }

                if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {
                  _this._validateSchema(rawAttribute, field, value);
                }

                if (Object.prototype.hasOwnProperty.call(_this.modelInstance.validators, field)) {
                  validators.push(_this._singleAttrValidate(value, field, rawAttribute.allowNull));
                }
              });

              _context4.next = 4;
              return regeneratorRuntime.awrap(Promise.all(validators));

            case 4:
              return _context4.abrupt("return", _context4.sent);

            case 5:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_customValidators",
    value: function _customValidators() {
      var _this2 = this;

      var validators;
      return regeneratorRuntime.async(function _customValidators$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              validators = [];

              _.each(this.modelInstance.constructor.options.validate, function (validator2, validatorType) {
                if (_this2.options.skip.includes(validatorType)) {
                  return;
                }

                var valprom = _this2._invokeCustomValidator(validator2, validatorType)["catch"](function () {});

                validators.push(valprom);
              });

              _context5.next = 4;
              return regeneratorRuntime.awrap(Promise.all(validators));

            case 4:
              return _context5.abrupt("return", _context5.sent);

            case 5:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_singleAttrValidate",
    value: function _singleAttrValidate(value, field, allowNull) {
      var _this3 = this;

      var validators;
      return regeneratorRuntime.async(function _singleAttrValidate$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (!((value === null || value === void 0) && !allowNull)) {
                _context6.next = 2;
                break;
              }

              return _context6.abrupt("return");

            case 2:
              validators = [];

              _.forIn(this.modelInstance.validators[field], function (test, validatorType) {
                if (["isUrl", "isURL", "isEmail"].includes(validatorType)) {
                  if (_typeof(test) === "object" && test !== null && test.msg) {
                    test = {
                      msg: test.msg
                    };
                  } else if (test === true) {
                    test = {};
                  }
                }

                if (typeof test === "function") {
                  validators.push(_this3._invokeCustomValidator(test, validatorType, true, value, field));
                  return;
                }

                if (value === null || value === void 0) {
                  return;
                }

                var validatorPromise = _this3._invokeBuiltinValidator(value, test, validatorType, field);

                validatorPromise["catch"](function () {});
                validators.push(validatorPromise);
              });

              return _context6.abrupt("return", Promise.all(validators.map(function (validator2) {
                return validator2["catch"](function (rejection) {
                  var isBuiltIn = !!rejection.validatorName;

                  _this3._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);
                });
              })));

            case 5:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_invokeCustomValidator",
    value: function _invokeCustomValidator(validator2, validatorType, optAttrDefined, optValue, optField) {
      var isAsync, validatorArity, asyncArity, errorKey, invokeArgs;
      return regeneratorRuntime.async(function _invokeCustomValidator$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              isAsync = false;
              validatorArity = validator2.length;
              asyncArity = 1;
              errorKey = validatorType;

              if (optAttrDefined) {
                asyncArity = 2;
                invokeArgs = optValue;
                errorKey = optField;
              }

              if (validatorArity === asyncArity) {
                isAsync = true;
              }

              if (!isAsync) {
                _context7.next = 20;
                break;
              }

              _context7.prev = 7;

              if (!optAttrDefined) {
                _context7.next = 12;
                break;
              }

              _context7.next = 11;
              return regeneratorRuntime.awrap(promisify(validator2.bind(this.modelInstance, invokeArgs))());

            case 11:
              return _context7.abrupt("return", _context7.sent);

            case 12:
              _context7.next = 14;
              return regeneratorRuntime.awrap(promisify(validator2.bind(this.modelInstance))());

            case 14:
              return _context7.abrupt("return", _context7.sent);

            case 17:
              _context7.prev = 17;
              _context7.t0 = _context7["catch"](7);
              return _context7.abrupt("return", this._pushError(false, errorKey, _context7.t0, optValue, validatorType));

            case 20:
              _context7.prev = 20;
              _context7.next = 23;
              return regeneratorRuntime.awrap(validator2.call(this.modelInstance, invokeArgs));

            case 23:
              return _context7.abrupt("return", _context7.sent);

            case 26:
              _context7.prev = 26;
              _context7.t1 = _context7["catch"](20);
              return _context7.abrupt("return", this._pushError(false, errorKey, _context7.t1, optValue, validatorType));

            case 29:
            case "end":
              return _context7.stop();
          }
        }
      }, null, this, [[7, 17], [20, 26]]);
    }
  }, {
    key: "_invokeBuiltinValidator",
    value: function _invokeBuiltinValidator(value, test, validatorType, field) {
      var valueString, validatorArgs;
      return regeneratorRuntime.async(function _invokeBuiltinValidator$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              valueString = String(value);

              if (!(typeof validator[validatorType] !== "function")) {
                _context8.next = 3;
                break;
              }

              throw new Error("Invalid validator function: ".concat(validatorType));

            case 3:
              validatorArgs = this._extractValidatorArgs(test, validatorType, field);

              if (validator[validatorType].apply(validator, [valueString].concat(_toConsumableArray(validatorArgs)))) {
                _context8.next = 6;
                break;
              }

              throw Object.assign(new Error(test.msg || "Validation ".concat(validatorType, " on ").concat(field, " failed")), {
                validatorName: validatorType,
                validatorArgs: validatorArgs
              });

            case 6:
            case "end":
              return _context8.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_extractValidatorArgs",
    value: function _extractValidatorArgs(test, validatorType, field) {
      var validatorArgs = test.args || test;
      var isLocalizedValidator = typeof validatorArgs !== "string" && ["isAlpha", "isAlphanumeric", "isMobilePhone"].includes(validatorType);

      if (!Array.isArray(validatorArgs)) {
        if (validatorType === "isImmutable") {
          validatorArgs = [validatorArgs, field, this.modelInstance];
        } else if (isLocalizedValidator || validatorType === "isIP") {
          validatorArgs = [];
        } else {
          validatorArgs = [validatorArgs];
        }
      } else {
        validatorArgs = validatorArgs.slice(0);
      }

      return validatorArgs;
    }
  }, {
    key: "_validateSchema",
    value: function _validateSchema(rawAttribute, field, value) {
      if (rawAttribute.allowNull === false && (value === null || value === void 0)) {
        var association = Object.values(this.modelInstance.constructor.associations).find(function (association2) {
          return association2 instanceof BelongsTo && association2.foreignKey === rawAttribute.fieldName;
        });

        if (!association || !this.modelInstance.get(association.associationAccessor)) {
          var validators = this.modelInstance.validators[field];

          var errMsg = _.get(validators, "notNull.msg", "".concat(this.modelInstance.constructor.name, ".").concat(field, " cannot be null"));

          this.errors.push(new sequelizeError.ValidationErrorItem(errMsg, "notNull Violation", field, value, this.modelInstance, "is_null"));
        }
      }

      if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {
        if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {
          this.errors.push(new sequelizeError.ValidationErrorItem("".concat(field, " cannot be an array or an object"), "string violation", field, value, this.modelInstance, "not_a_string"));
        }
      }
    }
  }, {
    key: "_pushError",
    value: function _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {
      var message = rawError.message || rawError || "Validation error";
      var error = new sequelizeError.ValidationErrorItem(message, "Validation error", errorKey, value, this.modelInstance, fnName, isBuiltin ? fnName : void 0, isBuiltin ? fnArgs : void 0);
      error[InstanceValidator.RAW_KEY_NAME] = rawError;
      this.errors.push(error);
    }
  }]);

  return InstanceValidator;
}();

InstanceValidator.RAW_KEY_NAME = "original";
module.exports = InstanceValidator;
module.exports.InstanceValidator = InstanceValidator;
module.exports["default"] = InstanceValidator;