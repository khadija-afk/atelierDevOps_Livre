// This file was modified by Oracle on June 1, 2021.
// The changes involve new logic to handle an additional ERR Packet sent by
// the MySQL server when the connection is closed unexpectedly.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.
// This file was modified by Oracle on June 17, 2021.
// The changes involve logic to ensure the socket connection is closed when
// there is a fatal error.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.
// This file was modified by Oracle on September 21, 2021.
// The changes involve passing additional authentication factor passwords
// to the ChangeUser Command instance.
// Modifications copyright (c) 2021, Oracle and/or its affiliates.
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Net = require('net');

var Tls = require('tls');

var Timers = require('timers');

var EventEmitter = require('events').EventEmitter;

var Readable = require('stream').Readable;

var Queue = require('denque');

var SqlString = require('sqlstring');

var LRU = require('lru-cache')["default"];

var PacketParser = require('./packet_parser.js');

var Packets = require('./packets/index.js');

var Commands = require('./commands/index.js');

var ConnectionConfig = require('./connection_config.js');

var CharsetToEncoding = require('./constants/charset_encodings.js');

var _connectionId = 0;
var convertNamedPlaceholders = null;

var Connection =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Connection, _EventEmitter);

  function Connection(opts) {
    var _this;

    _classCallCheck(this, Connection);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connection).call(this));
    _this.config = opts.config; // TODO: fill defaults
    // if no params, connect to /var/lib/mysql/mysql.sock ( /tmp/mysql.sock on OSX )
    // if host is given, connect to host:3306
    // TODO: use `/usr/local/mysql/bin/mysql_config --socket` output? as default socketPath
    // if there is no host/port and no socketPath parameters?

    if (!opts.config.stream) {
      if (opts.config.socketPath) {
        _this.stream = Net.connect(opts.config.socketPath);
      } else {
        _this.stream = Net.connect(opts.config.port, opts.config.host); // Optionally enable keep-alive on the socket.

        if (_this.config.enableKeepAlive) {
          _this.stream.on('connect', function () {
            _this.stream.setKeepAlive(true, _this.config.keepAliveInitialDelay);
          });
        } // Enable TCP_NODELAY flag. This is needed so that the network packets
        // are sent immediately to the server


        _this.stream.setNoDelay(true);
      } // if stream is a function, treat it as "stream agent / factory"

    } else if (typeof opts.config.stream === 'function') {
      _this.stream = opts.config.stream(opts);
    } else {
      _this.stream = opts.config.stream;
    }

    _this._internalId = _connectionId++;
    _this._commands = new Queue();
    _this._command = null;
    _this._paused = false;
    _this._paused_packets = new Queue();
    _this._statements = new LRU({
      max: _this.config.maxPreparedStatements,
      dispose: function dispose(statement) {
        statement.close();
      }
    });
    _this.serverCapabilityFlags = 0;
    _this.authorized = false;
    _this.sequenceId = 0;
    _this.compressedSequenceId = 0;
    _this.threadId = null;
    _this._handshakePacket = null;
    _this._fatalError = null;
    _this._protocolError = null;
    _this._outOfOrderPackets = [];
    _this.clientEncoding = CharsetToEncoding[_this.config.charsetNumber];

    _this.stream.on('error', _this._handleNetworkError.bind(_assertThisInitialized(_this))); // see https://gist.github.com/khoomeister/4985691#use-that-instead-of-bind


    _this.packetParser = new PacketParser(function (p) {
      _this.handlePacket(p);
    });

    _this.stream.on('data', function (data) {
      if (_this.connectTimeout) {
        Timers.clearTimeout(_this.connectTimeout);
        _this.connectTimeout = null;
      }

      _this.packetParser.execute(data);
    });

    _this.stream.on('end', function () {
      // emit the end event so that the pooled connection can close the connection
      _this.emit('end');
    });

    _this.stream.on('close', function () {
      // we need to set this flag everywhere where we want connection to close
      if (_this._closing) {
        return;
      }

      if (!_this._protocolError) {
        // no particular error message before disconnect
        _this._protocolError = new Error('Connection lost: The server closed the connection.');
        _this._protocolError.fatal = true;
        _this._protocolError.code = 'PROTOCOL_CONNECTION_LOST';
      }

      _this._notifyError(_this._protocolError);
    });

    var handshakeCommand;

    if (!_this.config.isServer) {
      handshakeCommand = new Commands.ClientHandshake(_this.config.clientFlags);
      handshakeCommand.on('end', function () {
        // this happens when handshake finishes early either because there was
        // some fatal error or the server sent an error packet instead of
        // an hello packet (for example, 'Too many connections' error)
        if (!handshakeCommand.handshake || _this._fatalError || _this._protocolError) {
          return;
        }

        _this._handshakePacket = handshakeCommand.handshake;
        _this.threadId = handshakeCommand.handshake.connectionId;

        _this.emit('connect', handshakeCommand.handshake);
      });
      handshakeCommand.on('error', function (err) {
        _this._closing = true;

        _this._notifyError(err);
      });

      _this.addCommand(handshakeCommand);
    } // in case there was no initial handshake but we need to read sting, assume it utf-8
    // most common example: "Too many connections" error ( packet is sent immediately on connection attempt, we don't know server encoding yet)
    // will be overwritten with actual encoding value as soon as server handshake packet is received


    _this.serverEncoding = 'utf8';

    if (_this.config.connectTimeout) {
      var timeoutHandler = _this._handleTimeoutError.bind(_assertThisInitialized(_this));

      _this.connectTimeout = Timers.setTimeout(timeoutHandler, _this.config.connectTimeout);
    }

    return _this;
  }

  _createClass(Connection, [{
    key: "promise",
    value: function promise(promiseImpl) {
      var PromiseConnection = require('../promise').PromiseConnection;

      return new PromiseConnection(this, promiseImpl);
    }
  }, {
    key: "_addCommandClosedState",
    value: function _addCommandClosedState(cmd) {
      var err = new Error("Can't add new command when connection is in closed state");
      err.fatal = true;

      if (cmd.onResult) {
        cmd.onResult(err);
      } else {
        this.emit('error', err);
      }
    }
  }, {
    key: "_handleFatalError",
    value: function _handleFatalError(err) {
      var _this2 = this;

      err.fatal = true; // stop receiving packets

      this.stream.removeAllListeners('data');
      this.addCommand = this._addCommandClosedState;

      this.write = function () {
        _this2.emit('error', new Error("Can't write in closed state"));
      };

      this._notifyError(err);

      this._fatalError = err;
    }
  }, {
    key: "_handleNetworkError",
    value: function _handleNetworkError(err) {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      } // Do not throw an error when a connection ends with a RST,ACK packet


      if (err.code === 'ECONNRESET' && this._closing) {
        return;
      }

      this._handleFatalError(err);
    }
  }, {
    key: "_handleTimeoutError",
    value: function _handleTimeoutError() {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      }

      this.stream.destroy && this.stream.destroy();
      var err = new Error('connect ETIMEDOUT');
      err.errorno = 'ETIMEDOUT';
      err.code = 'ETIMEDOUT';
      err.syscall = 'connect';

      this._handleNetworkError(err);
    } // notify all commands in the queue and bubble error as connection "error"
    // called on stream error or unexpected termination

  }, {
    key: "_notifyError",
    value: function _notifyError(err) {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      } // prevent from emitting 'PROTOCOL_CONNECTION_LOST' after EPIPE or ECONNRESET


      if (this._fatalError) {
        return;
      }

      var command; // if there is no active command, notify connection
      // if there are commands and all of them have callbacks, pass error via callback

      var bubbleErrorToConnection = !this._command;

      if (this._command && this._command.onResult) {
        this._command.onResult(err);

        this._command = null; // connection handshake is special because we allow it to be implicit
        // if error happened during handshake, but there are others commands in queue
        // then bubble error to other commands and not to connection
      } else if (!(this._command && this._command.constructor === Commands.ClientHandshake && this._commands.length > 0)) {
        bubbleErrorToConnection = true;
      }

      while (command = this._commands.shift()) {
        if (command.onResult) {
          command.onResult(err);
        } else {
          bubbleErrorToConnection = true;
        }
      } // notify connection if some comands in the queue did not have callbacks
      // or if this is pool connection ( so it can be removed from pool )


      if (bubbleErrorToConnection || this._pool) {
        this.emit('error', err);
      } // close connection after emitting the event in case of a fatal error


      if (err.fatal) {
        this.close();
      }
    }
  }, {
    key: "write",
    value: function write(buffer) {
      var _this3 = this;

      var result = this.stream.write(buffer, function (err) {
        if (err) {
          _this3._handleNetworkError(err);
        }
      });

      if (!result) {
        this.stream.emit('pause');
      }
    } // http://dev.mysql.com/doc/internals/en/sequence-id.html
    //
    // The sequence-id is incremented with each packet and may wrap around.
    // It starts at 0 and is reset to 0 when a new command
    // begins in the Command Phase.
    // http://dev.mysql.com/doc/internals/en/example-several-mysql-packets.html

  }, {
    key: "_resetSequenceId",
    value: function _resetSequenceId() {
      this.sequenceId = 0;
      this.compressedSequenceId = 0;
    }
  }, {
    key: "_bumpCompressedSequenceId",
    value: function _bumpCompressedSequenceId(numPackets) {
      this.compressedSequenceId += numPackets;
      this.compressedSequenceId %= 256;
    }
  }, {
    key: "_bumpSequenceId",
    value: function _bumpSequenceId(numPackets) {
      this.sequenceId += numPackets;
      this.sequenceId %= 256;
    }
  }, {
    key: "writePacket",
    value: function writePacket(packet) {
      var MAX_PACKET_LENGTH = 16777215;
      var length = packet.length();
      var chunk, offset, header;

      if (length < MAX_PACKET_LENGTH) {
        packet.writeHeader(this.sequenceId);

        if (this.config.debug) {
          // eslint-disable-next-line no-console
          console.log("".concat(this._internalId, " ").concat(this.connectionId, " <== ").concat(this._command._commandName, "#").concat(this._command.stateName(), "(").concat([this.sequenceId, packet._name, packet.length()].join(','), ")")); // eslint-disable-next-line no-console

          console.log("".concat(this._internalId, " ").concat(this.connectionId, " <== ").concat(packet.buffer.toString('hex')));
        }

        this._bumpSequenceId(1);

        this.write(packet.buffer);
      } else {
        if (this.config.debug) {
          // eslint-disable-next-line no-console
          console.log("".concat(this._internalId, " ").concat(this.connectionId, " <== Writing large packet, raw content not written:")); // eslint-disable-next-line no-console

          console.log("".concat(this._internalId, " ").concat(this.connectionId, " <== ").concat(this._command._commandName, "#").concat(this._command.stateName(), "(").concat([this.sequenceId, packet._name, packet.length()].join(','), ")"));
        }

        for (offset = 4; offset < 4 + length; offset += MAX_PACKET_LENGTH) {
          chunk = packet.buffer.slice(offset, offset + MAX_PACKET_LENGTH);

          if (chunk.length === MAX_PACKET_LENGTH) {
            header = Buffer.from([0xff, 0xff, 0xff, this.sequenceId]);
          } else {
            header = Buffer.from([chunk.length & 0xff, chunk.length >> 8 & 0xff, chunk.length >> 16 & 0xff, this.sequenceId]);
          }

          this._bumpSequenceId(1);

          this.write(header);
          this.write(chunk);
        }
      }
    } // 0.11+ environment

  }, {
    key: "startTLS",
    value: function startTLS(onSecure) {
      var _this4 = this;

      if (this.config.debug) {
        // eslint-disable-next-line no-console
        console.log('Upgrading connection to TLS');
      }

      var secureContext = Tls.createSecureContext({
        ca: this.config.ssl.ca,
        cert: this.config.ssl.cert,
        ciphers: this.config.ssl.ciphers,
        key: this.config.ssl.key,
        passphrase: this.config.ssl.passphrase,
        minVersion: this.config.ssl.minVersion,
        maxVersion: this.config.ssl.maxVersion
      });
      var rejectUnauthorized = this.config.ssl.rejectUnauthorized;
      var verifyIdentity = this.config.ssl.verifyIdentity;
      var servername = this.config.host;
      var secureEstablished = false;
      this.stream.removeAllListeners('data');
      var secureSocket = Tls.connect({
        rejectUnauthorized: rejectUnauthorized,
        requestCert: rejectUnauthorized,
        checkServerIdentity: verifyIdentity ? Tls.checkServerIdentity : function () {
          return undefined;
        },
        secureContext: secureContext,
        isServer: false,
        socket: this.stream,
        servername: servername
      }, function () {
        secureEstablished = true;

        if (rejectUnauthorized) {
          if (typeof servername === 'string' && verifyIdentity) {
            var cert = secureSocket.getPeerCertificate(true);
            var serverIdentityCheckError = Tls.checkServerIdentity(servername, cert);

            if (serverIdentityCheckError) {
              onSecure(serverIdentityCheckError);
              return;
            }
          }
        }

        onSecure();
      }); // error handler for secure socket

      secureSocket.on('error', function (err) {
        if (secureEstablished) {
          _this4._handleNetworkError(err);
        } else {
          onSecure(err);
        }
      });
      secureSocket.on('data', function (data) {
        _this4.packetParser.execute(data);
      });

      this.write = function (buffer) {
        return secureSocket.write(buffer);
      };
    }
  }, {
    key: "protocolError",
    value: function protocolError(message, code) {
      // Starting with MySQL 8.0.24, if the client closes the connection
      // unexpectedly, the server will send a last ERR Packet, which we can
      // safely ignore.
      // https://dev.mysql.com/worklog/task/?id=12999
      if (this._closing) {
        return;
      }

      var err = new Error(message);
      err.fatal = true;
      err.code = code || 'PROTOCOL_ERROR';
      this.emit('error', err);
    }
  }, {
    key: "handlePacket",
    value: function handlePacket(packet) {
      if (this._paused) {
        this._paused_packets.push(packet);

        return;
      }

      if (this.config.debug) {
        if (packet) {
          // eslint-disable-next-line no-console
          console.log(" raw: ".concat(packet.buffer.slice(packet.offset, packet.offset + packet.length()).toString('hex'))); // eslint-disable-next-line no-console

          console.trace();
          var commandName = this._command ? this._command._commandName : '(no command)';
          var stateName = this._command ? this._command.stateName() : '(no command)'; // eslint-disable-next-line no-console

          console.log("".concat(this._internalId, " ").concat(this.connectionId, " ==> ").concat(commandName, "#").concat(stateName, "(").concat([packet.sequenceId, packet.type(), packet.length()].join(','), ")"));
        }
      }

      if (!this._command) {
        var marker = packet.peekByte(); // If it's an Err Packet, we should use it.

        if (marker === 0xff) {
          var error = Packets.Error.fromPacket(packet);
          this.protocolError(error.message, error.code);
        } else {
          // Otherwise, it means it's some other unexpected packet.
          this.protocolError('Unexpected packet while no commands in the queue', 'PROTOCOL_UNEXPECTED_PACKET');
        }

        this.close();
        return;
      }

      if (packet) {
        // Note: when server closes connection due to inactivity, Err packet ER_CLIENT_INTERACTION_TIMEOUT from MySQL 8.0.24, sequenceId will be 0
        if (this.sequenceId !== packet.sequenceId) {
          var err = new Error("Warning: got packets out of order. Expected ".concat(this.sequenceId, " but received ").concat(packet.sequenceId));
          err.expected = this.sequenceId;
          err.received = packet.sequenceId;
          this.emit('warn', err); // REVIEW
          // eslint-disable-next-line no-console

          console.error(err.message);
        }

        this._bumpSequenceId(packet.numPackets);
      }

      try {
        if (this._fatalError) {
          // skip remaining packets after client is in the error state
          return;
        }

        var done = this._command.execute(packet, this);

        if (done) {
          this._command = this._commands.shift();

          if (this._command) {
            this.sequenceId = 0;
            this.compressedSequenceId = 0;
            this.handlePacket();
          }
        }
      } catch (err) {
        this._handleFatalError(err);

        this.stream.destroy();
      }
    }
  }, {
    key: "addCommand",
    value: function addCommand(cmd) {
      // this.compressedSequenceId = 0;
      // this.sequenceId = 0;
      if (this.config.debug) {
        var commandName = cmd.constructor.name; // eslint-disable-next-line no-console

        console.log("Add command: ".concat(commandName));
        cmd._commandName = commandName;
      }

      if (!this._command) {
        this._command = cmd;
        this.handlePacket();
      } else {
        this._commands.push(cmd);
      }

      return cmd;
    }
  }, {
    key: "format",
    value: function format(sql, values) {
      if (typeof this.config.queryFormat === 'function') {
        return this.config.queryFormat.call(this, sql, values, this.config.timezone);
      }

      var opts = {
        sql: sql,
        values: values
      };

      this._resolveNamedPlaceholders(opts);

      return SqlString.format(opts.sql, opts.values, this.config.stringifyObjects, this.config.timezone);
    }
  }, {
    key: "escape",
    value: function escape(value) {
      return SqlString.escape(value, false, this.config.timezone);
    }
  }, {
    key: "escapeId",
    value: function escapeId(value) {
      return SqlString.escapeId(value, false);
    }
  }, {
    key: "raw",
    value: function raw(sql) {
      return SqlString.raw(sql);
    }
  }, {
    key: "_resolveNamedPlaceholders",
    value: function _resolveNamedPlaceholders(options) {
      var unnamed;

      if (this.config.namedPlaceholders || options.namedPlaceholders) {
        if (Array.isArray(options.values)) {
          // if an array is provided as the values, assume the conversion is not necessary.
          // this allows the usage of unnamed placeholders even if the namedPlaceholders flag is enabled.
          return;
        }

        if (convertNamedPlaceholders === null) {
          convertNamedPlaceholders = require('named-placeholders')();
        }

        unnamed = convertNamedPlaceholders(options.sql, options.values);
        options.sql = unnamed[0];
        options.values = unnamed[1];
      }
    }
  }, {
    key: "query",
    value: function query(sql, values, cb) {
      var cmdQuery;

      if (sql.constructor === Commands.Query) {
        cmdQuery = sql;
      } else {
        cmdQuery = Connection.createQuery(sql, values, cb, this.config);
      }

      this._resolveNamedPlaceholders(cmdQuery);

      var rawSql = this.format(cmdQuery.sql, cmdQuery.values !== undefined ? cmdQuery.values : []);
      cmdQuery.sql = rawSql;
      return this.addCommand(cmdQuery);
    }
  }, {
    key: "pause",
    value: function pause() {
      this._paused = true;
      this.stream.pause();
    }
  }, {
    key: "resume",
    value: function resume() {
      var packet;
      this._paused = false;

      while (packet = this._paused_packets.shift()) {
        this.handlePacket(packet); // don't resume if packet handler paused connection

        if (this._paused) {
          return;
        }
      }

      this.stream.resume();
    } // TODO: named placeholders support

  }, {
    key: "prepare",
    value: function prepare(options, cb) {
      if (typeof options === 'string') {
        options = {
          sql: options
        };
      }

      return this.addCommand(new Commands.Prepare(options, cb));
    }
  }, {
    key: "unprepare",
    value: function unprepare(sql) {
      var options = {};

      if (_typeof(sql) === 'object') {
        options = sql;
      } else {
        options.sql = sql;
      }

      var key = Connection.statementKey(options);

      var stmt = this._statements.get(key);

      if (stmt) {
        this._statements["delete"](key);

        stmt.close();
      }

      return stmt;
    }
  }, {
    key: "execute",
    value: function execute(sql, values, cb) {
      var options = {
        infileStreamFactory: this.config.infileStreamFactory
      };

      if (_typeof(sql) === 'object') {
        // execute(options, cb)
        options = _objectSpread({}, options, {}, sql, {
          sql: sql.sql,
          values: sql.values
        });

        if (typeof values === 'function') {
          cb = values;
        } else {
          options.values = options.values || values;
        }
      } else if (typeof values === 'function') {
        // execute(sql, cb)
        cb = values;
        options.sql = sql;
        options.values = undefined;
      } else {
        // execute(sql, values, cb)
        options.sql = sql;
        options.values = values;
      }

      this._resolveNamedPlaceholders(options); // check for values containing undefined


      if (options.values) {
        //If namedPlaceholder is not enabled and object is passed as bind parameters
        if (!Array.isArray(options.values)) {
          throw new TypeError('Bind parameters must be array if namedPlaceholders parameter is not enabled');
        }

        options.values.forEach(function (val) {
          //If namedPlaceholder is not enabled and object is passed as bind parameters
          if (!Array.isArray(options.values)) {
            throw new TypeError('Bind parameters must be array if namedPlaceholders parameter is not enabled');
          }

          if (val === undefined) {
            throw new TypeError('Bind parameters must not contain undefined. To pass SQL NULL specify JS null');
          }

          if (typeof val === 'function') {
            throw new TypeError('Bind parameters must not contain function(s). To pass the body of a function as a string call .toString() first');
          }
        });
      }

      var executeCommand = new Commands.Execute(options, cb);
      var prepareCommand = new Commands.Prepare(options, function (err, stmt) {
        if (err) {
          // skip execute command if prepare failed, we have main
          // combined callback here
          executeCommand.start = function () {
            return null;
          };

          if (cb) {
            cb(err);
          } else {
            executeCommand.emit('error', err);
          }

          executeCommand.emit('end');
          return;
        }

        executeCommand.statement = stmt;
      });
      this.addCommand(prepareCommand);
      this.addCommand(executeCommand);
      return executeCommand;
    }
  }, {
    key: "changeUser",
    value: function changeUser(options, callback) {
      if (!callback && typeof options === 'function') {
        callback = options;
        options = {};
      }

      var charsetNumber = options.charset ? ConnectionConfig.getCharsetNumber(options.charset) : this.config.charsetNumber;
      return this.addCommand(new Commands.ChangeUser({
        user: options.user || this.config.user,
        // for the purpose of multi-factor authentication, or not, the main
        // password (used for the 1st authentication factor) can also be
        // provided via the "password1" option
        password: options.password || options.password1 || this.config.password || this.config.password1,
        password2: options.password2 || this.config.password2,
        password3: options.password3 || this.config.password3,
        passwordSha1: options.passwordSha1 || this.config.passwordSha1,
        database: options.database || this.config.database,
        timeout: options.timeout,
        charsetNumber: charsetNumber,
        currentConfig: this.config
      }, function (err) {
        if (err) {
          err.fatal = true;
        }

        if (callback) {
          callback(err);
        }
      }));
    } // transaction helpers

  }, {
    key: "beginTransaction",
    value: function beginTransaction(cb) {
      return this.query('START TRANSACTION', cb);
    }
  }, {
    key: "commit",
    value: function commit(cb) {
      return this.query('COMMIT', cb);
    }
  }, {
    key: "rollback",
    value: function rollback(cb) {
      return this.query('ROLLBACK', cb);
    }
  }, {
    key: "ping",
    value: function ping(cb) {
      return this.addCommand(new Commands.Ping(cb));
    }
  }, {
    key: "_registerSlave",
    value: function _registerSlave(opts, cb) {
      return this.addCommand(new Commands.RegisterSlave(opts, cb));
    }
  }, {
    key: "_binlogDump",
    value: function _binlogDump(opts, cb) {
      return this.addCommand(new Commands.BinlogDump(opts, cb));
    } // currently just alias to close

  }, {
    key: "destroy",
    value: function destroy() {
      this.close();
    }
  }, {
    key: "close",
    value: function close() {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      }

      this._closing = true;
      this.stream.end();
      this.addCommand = this._addCommandClosedState;
    }
  }, {
    key: "createBinlogStream",
    value: function createBinlogStream(opts) {
      var _this5 = this;

      // TODO: create proper stream class
      // TODO: use through2
      var test = 1;
      var stream = new Readable({
        objectMode: true
      });

      stream._read = function () {
        return {
          data: test++
        };
      };

      this._registerSlave(opts, function () {
        var dumpCmd = _this5._binlogDump(opts);

        dumpCmd.on('event', function (ev) {
          stream.push(ev);
        });
        dumpCmd.on('eof', function () {
          stream.push(null); // if non-blocking, then close stream to prevent errors

          if (opts.flags && opts.flags & 0x01) {
            _this5.close();
          }
        }); // TODO: pipe errors as well
      });

      return stream;
    }
  }, {
    key: "connect",
    value: function connect(cb) {
      if (!cb) {
        return;
      }

      if (this._fatalError || this._protocolError) {
        return cb(this._fatalError || this._protocolError);
      }

      if (this._handshakePacket) {
        return cb(null, this);
      }

      var connectCalled = 0;

      function callbackOnce(isErrorHandler) {
        return function (param) {
          if (!connectCalled) {
            if (isErrorHandler) {
              cb(param);
            } else {
              cb(null, param);
            }
          }

          connectCalled = 1;
        };
      }

      this.once('error', callbackOnce(true));
      this.once('connect', callbackOnce(false));
    } // ===================================
    // outgoing server connection methods
    // ===================================

  }, {
    key: "writeColumns",
    value: function writeColumns(columns) {
      var _this6 = this;

      this.writePacket(Packets.ResultSetHeader.toPacket(columns.length));
      columns.forEach(function (column) {
        _this6.writePacket(Packets.ColumnDefinition.toPacket(column, _this6.serverConfig.encoding));
      });
      this.writeEof();
    } // row is array of columns, not hash

  }, {
    key: "writeTextRow",
    value: function writeTextRow(column) {
      this.writePacket(Packets.TextRow.toPacket(column, this.serverConfig.encoding));
    }
  }, {
    key: "writeBinaryRow",
    value: function writeBinaryRow(column) {
      this.writePacket(Packets.BinaryRow.toPacket(column, this.serverConfig.encoding));
    }
  }, {
    key: "writeTextResult",
    value: function writeTextResult(rows, columns) {
      var _this7 = this;

      var binary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      this.writeColumns(columns);
      rows.forEach(function (row) {
        var arrayRow = new Array(columns.length);
        columns.forEach(function (column) {
          arrayRow.push(row[column.name]);
        });

        if (binary) {
          _this7.writeBinaryRow(arrayRow);
        } else _this7.writeTextRow(arrayRow);
      });
      this.writeEof();
    }
  }, {
    key: "writeEof",
    value: function writeEof(warnings, statusFlags) {
      this.writePacket(Packets.EOF.toPacket(warnings, statusFlags));
    }
  }, {
    key: "writeOk",
    value: function writeOk(args) {
      if (!args) {
        args = {
          affectedRows: 0
        };
      }

      this.writePacket(Packets.OK.toPacket(args, this.serverConfig.encoding));
    }
  }, {
    key: "writeError",
    value: function writeError(args) {
      // if we want to send error before initial hello was sent, use default encoding
      var encoding = this.serverConfig ? this.serverConfig.encoding : 'cesu8';
      this.writePacket(Packets.Error.toPacket(args, encoding));
    }
  }, {
    key: "serverHandshake",
    value: function serverHandshake(args) {
      this.serverConfig = args;
      this.serverConfig.encoding = CharsetToEncoding[this.serverConfig.characterSet];
      return this.addCommand(new Commands.ServerHandshake(args));
    } // ===============================================================

  }, {
    key: "end",
    value: function end(callback) {
      var _this8 = this;

      if (this.config.isServer) {
        this._closing = true;

        var _quitCmd = new EventEmitter();

        setImmediate(function () {
          _this8.stream.end();

          _quitCmd.emit('end');
        });
        return _quitCmd;
      } // trigger error if more commands enqueued after end command


      var quitCmd = this.addCommand(new Commands.Quit(callback));
      this.addCommand = this._addCommandClosedState;
      return quitCmd;
    }
  }, {
    key: "fatalError",
    get: function get() {
      return this._fatalError;
    }
  }], [{
    key: "createQuery",
    value: function createQuery(sql, values, cb, config) {
      var options = {
        rowsAsArray: config.rowsAsArray,
        infileStreamFactory: config.infileStreamFactory
      };

      if (_typeof(sql) === 'object') {
        // query(options, cb)
        options = _objectSpread({}, options, {}, sql, {
          sql: sql.sql,
          values: sql.values
        });

        if (typeof values === 'function') {
          cb = values;
        } else if (values !== undefined) {
          options.values = values;
        }
      } else if (typeof values === 'function') {
        // query(sql, cb)
        cb = values;
        options.sql = sql;
        options.values = undefined;
      } else {
        // query(sql, values, cb)
        options.sql = sql;
        options.values = values;
      }

      return new Commands.Query(options, cb);
    }
  }, {
    key: "statementKey",
    value: function statementKey(options) {
      return "".concat(_typeof(options.nestTables), "/").concat(options.nestTables, "/").concat(options.rowsAsArray).concat(options.sql);
    }
  }]);

  return Connection;
}(EventEmitter);

module.exports = Connection;