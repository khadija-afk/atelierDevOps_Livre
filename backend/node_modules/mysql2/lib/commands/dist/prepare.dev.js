'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Packets = require('../packets/index.js');

var Command = require('./command.js');

var CloseStatement = require('./close_statement.js');

var Execute = require('./execute.js');

var PreparedStatementInfo =
/*#__PURE__*/
function () {
  function PreparedStatementInfo(query, id, columns, parameters, connection) {
    _classCallCheck(this, PreparedStatementInfo);

    this.query = query;
    this.id = id;
    this.columns = columns;
    this.parameters = parameters;
    this.rowParser = null;
    this._connection = connection;
  }

  _createClass(PreparedStatementInfo, [{
    key: "close",
    value: function close() {
      return this._connection.addCommand(new CloseStatement(this.id));
    }
  }, {
    key: "execute",
    value: function execute(parameters, callback) {
      if (typeof parameters === 'function') {
        callback = parameters;
        parameters = [];
      }

      return this._connection.addCommand(new Execute({
        statement: this,
        values: parameters
      }, callback));
    }
  }]);

  return PreparedStatementInfo;
}();

var Prepare =
/*#__PURE__*/
function (_Command) {
  _inherits(Prepare, _Command);

  function Prepare(options, callback) {
    var _this;

    _classCallCheck(this, Prepare);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Prepare).call(this));
    _this.query = options.sql;
    _this.onResult = callback;
    _this.id = 0;
    _this.fieldCount = 0;
    _this.parameterCount = 0;
    _this.fields = [];
    _this.parameterDefinitions = [];
    _this.options = options;
    return _this;
  }

  _createClass(Prepare, [{
    key: "start",
    value: function start(packet, connection) {
      var Connection = connection.constructor;
      this.key = Connection.statementKey(this.options);

      var statement = connection._statements.get(this.key);

      if (statement) {
        if (this.onResult) {
          this.onResult(null, statement);
        }

        return null;
      }

      var cmdPacket = new Packets.PrepareStatement(this.query, connection.config.charsetNumber, this.options.values);
      connection.writePacket(cmdPacket.toPacket(1));
      return Prepare.prototype.prepareHeader;
    }
  }, {
    key: "prepareHeader",
    value: function prepareHeader(packet, connection) {
      var header = new Packets.PreparedStatementHeader(packet);
      this.id = header.id;
      this.fieldCount = header.fieldCount;
      this.parameterCount = header.parameterCount;

      if (this.parameterCount > 0) {
        return Prepare.prototype.readParameter;
      }

      if (this.fieldCount > 0) {
        return Prepare.prototype.readField;
      }

      return this.prepareDone(connection);
    }
  }, {
    key: "readParameter",
    value: function readParameter(packet, connection) {
      // there might be scenarios when mysql server reports more parameters than
      // are actually present in the array of parameter definitions.
      // if EOF packet is received we switch to "read fields" state if there are
      // any fields reported by the server, otherwise we finish the command.
      if (packet.isEOF()) {
        if (this.fieldCount > 0) {
          return Prepare.prototype.readField;
        }

        return this.prepareDone(connection);
      }

      var def = new Packets.ColumnDefinition(packet, connection.clientEncoding);
      this.parameterDefinitions.push(def);

      if (this.parameterDefinitions.length === this.parameterCount) {
        return Prepare.prototype.parametersEOF;
      }

      return this.readParameter;
    }
  }, {
    key: "readField",
    value: function readField(packet, connection) {
      if (packet.isEOF()) {
        return this.prepareDone(connection);
      }

      var def = new Packets.ColumnDefinition(packet, connection.clientEncoding);
      this.fields.push(def);

      if (this.fields.length === this.fieldCount) {
        return Prepare.prototype.fieldsEOF;
      }

      return Prepare.prototype.readField;
    }
  }, {
    key: "parametersEOF",
    value: function parametersEOF(packet, connection) {
      if (!packet.isEOF()) {
        return connection.protocolError('Expected EOF packet after parameters');
      }

      if (this.fieldCount > 0) {
        return Prepare.prototype.readField;
      }

      return this.prepareDone(connection);
    }
  }, {
    key: "fieldsEOF",
    value: function fieldsEOF(packet, connection) {
      if (!packet.isEOF()) {
        return connection.protocolError('Expected EOF packet after fields');
      }

      return this.prepareDone(connection);
    }
  }, {
    key: "prepareDone",
    value: function prepareDone(connection) {
      var statement = new PreparedStatementInfo(this.query, this.id, this.fields, this.parameterDefinitions, connection);

      connection._statements.set(this.key, statement);

      if (this.onResult) {
        this.onResult(null, statement);
      }

      return null;
    }
  }]);

  return Prepare;
}(Command);

module.exports = Prepare;