"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return a;
};

var Utils = require("../../utils");

var util = require("util");

var DataTypes = require("../../data-types");

var AbstractQueryGenerator = require("../abstract/query-generator");

var semver = require("semver");

var _ = require("lodash");

var POSTGRES_RESERVED_WORDS = "all,analyse,analyze,and,any,array,as,asc,asymmetric,authorization,binary,both,case,cast,check,collate,collation,column,concurrently,constraint,create,cross,current_catalog,current_date,current_role,current_schema,current_time,current_timestamp,current_user,default,deferrable,desc,distinct,do,else,end,except,false,fetch,for,foreign,freeze,from,full,grant,group,having,ilike,in,initially,inner,intersect,into,is,isnull,join,lateral,leading,left,like,limit,localtime,localtimestamp,natural,not,notnull,null,offset,on,only,or,order,outer,overlaps,placing,primary,references,returning,right,select,session_user,similar,some,symmetric,table,tablesample,then,to,trailing,true,union,unique,user,using,variadic,verbose,when,where,window,with".split(",");

var PostgresQueryGenerator =
/*#__PURE__*/
function (_AbstractQueryGenerat) {
  _inherits(PostgresQueryGenerator, _AbstractQueryGenerat);

  function PostgresQueryGenerator() {
    _classCallCheck(this, PostgresQueryGenerator);

    return _possibleConstructorReturn(this, _getPrototypeOf(PostgresQueryGenerator).apply(this, arguments));
  }

  _createClass(PostgresQueryGenerator, [{
    key: "setSearchPath",
    value: function setSearchPath(searchPath) {
      return "SET search_path to ".concat(searchPath, ";");
    }
  }, {
    key: "createDatabaseQuery",
    value: function createDatabaseQuery(databaseName, options) {
      options = __spreadValues({
        encoding: null,
        collate: null
      }, options);
      var values = {
        database: this.quoteTable(databaseName),
        encoding: options.encoding ? " ENCODING = ".concat(this.escape(options.encoding)) : "",
        collation: options.collate ? " LC_COLLATE = ".concat(this.escape(options.collate)) : "",
        ctype: options.ctype ? " LC_CTYPE = ".concat(this.escape(options.ctype)) : "",
        template: options.template ? " TEMPLATE = ".concat(this.escape(options.template)) : ""
      };
      return "CREATE DATABASE ".concat(values.database).concat(values.encoding).concat(values.collation).concat(values.ctype).concat(values.template, ";");
    }
  }, {
    key: "dropDatabaseQuery",
    value: function dropDatabaseQuery(databaseName) {
      return "DROP DATABASE IF EXISTS ".concat(this.quoteTable(databaseName), ";");
    }
  }, {
    key: "createSchema",
    value: function createSchema(schema) {
      var databaseVersion = _.get(this, "sequelize.options.databaseVersion", 0);

      if (databaseVersion && semver.gte(databaseVersion, "9.2.0")) {
        return "CREATE SCHEMA IF NOT EXISTS ".concat(this.quoteIdentifier(schema), ";");
      }

      return "CREATE SCHEMA ".concat(this.quoteIdentifier(schema), ";");
    }
  }, {
    key: "dropSchema",
    value: function dropSchema(schema) {
      return "DROP SCHEMA IF EXISTS ".concat(this.quoteIdentifier(schema), " CASCADE;");
    }
  }, {
    key: "showSchemasQuery",
    value: function showSchemasQuery() {
      return "SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';";
    }
  }, {
    key: "versionQuery",
    value: function versionQuery() {
      return "SHOW SERVER_VERSION";
    }
  }, {
    key: "createTableQuery",
    value: function createTableQuery(tableName, attributes, options) {
      var _this = this;

      options = __spreadValues({}, options);

      var databaseVersion = _.get(this, "sequelize.options.databaseVersion", 0);

      var attrStr = [];
      var comments = "";
      var columnComments = "";
      var quotedTable = this.quoteTable(tableName);

      if (options.comment && typeof options.comment === "string") {
        comments += "; COMMENT ON TABLE ".concat(quotedTable, " IS ").concat(this.escape(options.comment));
      }

      for (var attr in attributes) {
        var quotedAttr = this.quoteIdentifier(attr);
        var i = attributes[attr].indexOf("COMMENT ");

        if (i !== -1) {
          var escapedCommentText = this.escape(attributes[attr].substring(i + 8));
          columnComments += "; COMMENT ON COLUMN ".concat(quotedTable, ".").concat(quotedAttr, " IS ").concat(escapedCommentText);
          attributes[attr] = attributes[attr].substring(0, i);
        }

        var dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);
        attrStr.push("".concat(quotedAttr, " ").concat(dataType));
      }

      var attributesClause = attrStr.join(", ");

      if (options.uniqueKeys) {
        _.each(options.uniqueKeys, function (columns) {
          if (columns.customIndex) {
            attributesClause += ", UNIQUE (".concat(columns.fields.map(function (field) {
              return _this.quoteIdentifier(field);
            }).join(", "), ")");
          }
        });
      }

      var pks = _.reduce(attributes, function (acc, attribute, key) {
        if (attribute.includes("PRIMARY KEY")) {
          acc.push(_this.quoteIdentifier(key));
        }

        return acc;
      }, []).join(",");

      if (pks.length > 0) {
        attributesClause += ", PRIMARY KEY (".concat(pks, ")");
      }

      return "CREATE TABLE ".concat(databaseVersion === 0 || semver.gte(databaseVersion, "9.1.0") ? "IF NOT EXISTS " : "").concat(quotedTable, " (").concat(attributesClause, ")").concat(comments).concat(columnComments, ";");
    }
  }, {
    key: "dropTableQuery",
    value: function dropTableQuery(tableName, options) {
      options = options || {};
      return "DROP TABLE IF EXISTS ".concat(this.quoteTable(tableName)).concat(options.cascade ? " CASCADE" : "", ";");
    }
  }, {
    key: "showTablesQuery",
    value: function showTablesQuery() {
      var schema = this.options.schema || "public";
      return "SELECT table_name FROM information_schema.tables WHERE table_schema = ".concat(this.escape(schema), " AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';");
    }
  }, {
    key: "tableExistsQuery",
    value: function tableExistsQuery(tableName) {
      var table = tableName.tableName || tableName;
      var schema = tableName.schema || "public";
      return "SELECT table_name FROM information_schema.tables WHERE table_schema = ".concat(this.escape(schema), " AND table_name = ").concat(this.escape(table));
    }
  }, {
    key: "describeTableQuery",
    value: function describeTableQuery(tableName, schema) {
      schema = schema || this.options.schema || "public";
      return "SELECT pk.constraint_type as \"Constraint\",c.column_name as \"Field\", c.column_default as \"Default\",c.is_nullable as \"Null\", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as \"Type\", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS \"special\", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS \"Comment\" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = ".concat(this.escape(tableName), " AND c.table_schema = ").concat(this.escape(schema));
    }
  }, {
    key: "_checkValidJsonStatement",
    value: function _checkValidJsonStatement(stmt) {
      if (typeof stmt !== "string") {
        return false;
      }

      var jsonFunctionRegex = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
      var jsonOperatorRegex = /^\s*(->>?|#>>?|@>|<@|\?[|&]?|\|{2}|#-)/i;
      var tokenCaptureRegex = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;
      var currentIndex = 0;
      var openingBrackets = 0;
      var closingBrackets = 0;
      var hasJsonFunction = false;
      var hasInvalidToken = false;

      while (currentIndex < stmt.length) {
        var string = stmt.substr(currentIndex);
        var functionMatches = jsonFunctionRegex.exec(string);

        if (functionMatches) {
          currentIndex += functionMatches[0].indexOf("(");
          hasJsonFunction = true;
          continue;
        }

        var operatorMatches = jsonOperatorRegex.exec(string);

        if (operatorMatches) {
          currentIndex += operatorMatches[0].length;
          hasJsonFunction = true;
          continue;
        }

        var tokenMatches = tokenCaptureRegex.exec(string);

        if (tokenMatches) {
          var capturedToken = tokenMatches[1];

          if (capturedToken === "(") {
            openingBrackets++;
          } else if (capturedToken === ")") {
            closingBrackets++;
          } else if (capturedToken === ";") {
            hasInvalidToken = true;
            break;
          }

          currentIndex += tokenMatches[0].length;
          continue;
        }

        break;
      }

      hasInvalidToken |= openingBrackets !== closingBrackets;

      if (hasJsonFunction && hasInvalidToken) {
        throw new Error("Invalid json statement: ".concat(stmt));
      }

      return hasJsonFunction;
    }
  }, {
    key: "handleSequelizeMethod",
    value: function handleSequelizeMethod(smth, tableName, factory, options, prepend) {
      var _this2 = this;

      if (smth instanceof Utils.Json) {
        if (smth.conditions) {
          var conditions = this.parseConditionObject(smth.conditions).map(function (condition) {
            return "".concat(_this2.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path)), " = '").concat(condition.value, "'");
          });
          return conditions.join(" AND ");
        }

        if (smth.path) {
          var str;

          if (this._checkValidJsonStatement(smth.path)) {
            str = smth.path;
          } else {
            var paths = _.toPath(smth.path);

            var column = paths.shift();
            str = this.jsonPathExtractionQuery(column, paths);
          }

          if (smth.value) {
            str += util.format(" = %s", this.escape(smth.value));
          }

          return str;
        }
      }

      return _get(_getPrototypeOf(PostgresQueryGenerator.prototype), "handleSequelizeMethod", this).call(this, smth, tableName, factory, options, prepend);
    }
  }, {
    key: "addColumnQuery",
    value: function addColumnQuery(table, key, attribute) {
      var dbDataType = this.attributeToSQL(attribute, {
        context: "addColumn",
        table: table,
        key: key
      });
      var dataType = attribute.type || attribute;
      var definition = this.dataTypeMapping(table, key, dbDataType);
      var quotedKey = this.quoteIdentifier(key);
      var quotedTable = this.quoteTable(this.extractTableDetails(table));
      var query = "ALTER TABLE ".concat(quotedTable, " ADD COLUMN ").concat(quotedKey, " ").concat(definition, ";");

      if (dataType instanceof DataTypes.ENUM) {
        query = this.pgEnum(table, key, dataType) + query;
      } else if (dataType.type && dataType.type instanceof DataTypes.ENUM) {
        query = this.pgEnum(table, key, dataType.type) + query;
      }

      return query;
    }
  }, {
    key: "removeColumnQuery",
    value: function removeColumnQuery(tableName, attributeName) {
      var quotedTableName = this.quoteTable(this.extractTableDetails(tableName));
      var quotedAttributeName = this.quoteIdentifier(attributeName);
      return "ALTER TABLE ".concat(quotedTableName, " DROP COLUMN ").concat(quotedAttributeName, ";");
    }
  }, {
    key: "changeColumnQuery",
    value: function changeColumnQuery(tableName, attributes) {
      var _this3 = this;

      var query = function query(subQuery) {
        return "ALTER TABLE ".concat(_this3.quoteTable(tableName), " ALTER COLUMN ").concat(subQuery, ";");
      };

      var sql = [];

      for (var attributeName in attributes) {
        var definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);
        var attrSql = "";

        if (definition.includes("NOT NULL")) {
          attrSql += query("".concat(this.quoteIdentifier(attributeName), " SET NOT NULL"));
          definition = definition.replace("NOT NULL", "").trim();
        } else if (!definition.includes("REFERENCES")) {
          attrSql += query("".concat(this.quoteIdentifier(attributeName), " DROP NOT NULL"));
        }

        if (definition.includes("DEFAULT")) {
          attrSql += query("".concat(this.quoteIdentifier(attributeName), " SET DEFAULT ").concat(definition.match(/DEFAULT ([^;]+)/)[1]));
          definition = definition.replace(/(DEFAULT[^;]+)/, "").trim();
        } else if (!definition.includes("REFERENCES")) {
          attrSql += query("".concat(this.quoteIdentifier(attributeName), " DROP DEFAULT"));
        }

        if (attributes[attributeName].startsWith("ENUM(")) {
          attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);
          definition = definition.replace(/^ENUM\(.+\)/, this.pgEnumName(tableName, attributeName, {
            schema: false
          }));
          definition += " USING (".concat(this.quoteIdentifier(attributeName), "::").concat(this.pgEnumName(tableName, attributeName), ")");
        }

        if (definition.match(/UNIQUE;*$/)) {
          definition = definition.replace(/UNIQUE;*$/, "");
          attrSql += query("ADD UNIQUE (".concat(this.quoteIdentifier(attributeName), ")")).replace("ALTER COLUMN", "");
        }

        if (definition.includes("REFERENCES")) {
          definition = definition.replace(/.+?(?=REFERENCES)/, "");
          attrSql += query("ADD FOREIGN KEY (".concat(this.quoteIdentifier(attributeName), ") ").concat(definition)).replace("ALTER COLUMN", "");
        } else {
          attrSql += query("".concat(this.quoteIdentifier(attributeName), " TYPE ").concat(definition));
        }

        sql.push(attrSql);
      }

      return sql.join("");
    }
  }, {
    key: "renameColumnQuery",
    value: function renameColumnQuery(tableName, attrBefore, attributes) {
      var attrString = [];

      for (var attributeName in attributes) {
        attrString.push("".concat(this.quoteIdentifier(attrBefore), " TO ").concat(this.quoteIdentifier(attributeName)));
      }

      return "ALTER TABLE ".concat(this.quoteTable(tableName), " RENAME COLUMN ").concat(attrString.join(", "), ";");
    }
  }, {
    key: "fn",
    value: function fn(fnName, tableName, parameters, body, returns, language) {
      fnName = fnName || "testfunc";
      language = language || "plpgsql";
      returns = returns ? "RETURNS ".concat(returns) : "";
      parameters = parameters || "";
      return "CREATE OR REPLACE FUNCTION pg_temp.".concat(fnName, "(").concat(parameters, ") ").concat(returns, " AS $func$ BEGIN ").concat(body, " END; $func$ LANGUAGE ").concat(language, "; SELECT * FROM pg_temp.").concat(fnName, "();");
    }
  }, {
    key: "truncateTableQuery",
    value: function truncateTableQuery(tableName) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return ["TRUNCATE ".concat(this.quoteTable(tableName)), options.restartIdentity ? " RESTART IDENTITY" : "", options.cascade ? " CASCADE" : ""].join("");
    }
  }, {
    key: "deleteQuery",
    value: function deleteQuery(tableName, where) {
      var _this4 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var model = arguments.length > 3 ? arguments[3] : undefined;
      var table = this.quoteTable(tableName);
      var whereClause = this.getWhereConditions(where, null, model, options);
      var limit = options.limit ? " LIMIT ".concat(this.escape(options.limit)) : "";
      var primaryKeys = "";
      var primaryKeysSelection = "";

      if (whereClause) {
        whereClause = " WHERE ".concat(whereClause);
      }

      if (options.limit) {
        if (!model) {
          throw new Error("Cannot LIMIT delete without a model.");
        }

        var pks = Object.values(model.primaryKeys).map(function (pk) {
          return _this4.quoteIdentifier(pk.field);
        }).join(",");
        primaryKeys = model.primaryKeyAttributes.length > 1 ? "(".concat(pks, ")") : pks;
        primaryKeysSelection = pks;
        return "DELETE FROM ".concat(table, " WHERE ").concat(primaryKeys, " IN (SELECT ").concat(primaryKeysSelection, " FROM ").concat(table).concat(whereClause).concat(limit, ")");
      }

      return "DELETE FROM ".concat(table).concat(whereClause);
    }
  }, {
    key: "showIndexesQuery",
    value: function showIndexesQuery(tableName) {
      var schemaJoin = "";
      var schemaWhere = "";

      if (typeof tableName !== "string") {
        schemaJoin = ", pg_namespace s";
        schemaWhere = " AND s.oid = t.relnamespace AND s.nspname = '".concat(tableName.schema, "'");
        tableName = tableName.tableName;
      }

      return "SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a".concat(schemaJoin, " WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = '").concat(tableName, "'").concat(schemaWhere, " GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;");
    }
  }, {
    key: "showConstraintsQuery",
    value: function showConstraintsQuery(tableName) {
      return ['SELECT constraint_catalog AS "constraintCatalog",', 'constraint_schema AS "constraintSchema",', 'constraint_name AS "constraintName",', 'table_catalog AS "tableCatalog",', 'table_schema AS "tableSchema",', 'table_name AS "tableName",', 'constraint_type AS "constraintType",', 'is_deferrable AS "isDeferrable",', 'initially_deferred AS "initiallyDeferred"', "from INFORMATION_SCHEMA.table_constraints", "WHERE table_name='".concat(tableName, "';")].join(" ");
    }
  }, {
    key: "removeIndexQuery",
    value: function removeIndexQuery(tableName, indexNameOrAttributes, options) {
      var indexName = indexNameOrAttributes;

      if (typeof indexName !== "string") {
        indexName = Utils.underscore("".concat(tableName, "_").concat(indexNameOrAttributes.join("_")));
      }

      return ["DROP INDEX", options && options.concurrently && "CONCURRENTLY", "IF EXISTS ".concat(this.quoteIdentifiers(indexName))].filter(Boolean).join(" ");
    }
  }, {
    key: "addLimitAndOffset",
    value: function addLimitAndOffset(options) {
      var fragment = "";

      if (options.limit != null) {
        fragment += " LIMIT " + this.escape(options.limit);
      }

      if (options.offset != null) {
        fragment += " OFFSET " + this.escape(options.offset);
      }

      return fragment;
    }
  }, {
    key: "attributeToSQL",
    value: function attributeToSQL(attribute, options) {
      var _this5 = this;

      if (!_.isPlainObject(attribute)) {
        attribute = {
          type: attribute
        };
      }

      var type;

      if (attribute.type instanceof DataTypes.ENUM || attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM) {
        var enumType = attribute.type.type || attribute.type;
        var values = attribute.values;

        if (enumType.values && !attribute.values) {
          values = enumType.values;
        }

        if (Array.isArray(values) && values.length > 0) {
          type = "ENUM(".concat(values.map(function (value) {
            return _this5.escape(value);
          }).join(", "), ")");

          if (attribute.type instanceof DataTypes.ARRAY) {
            type += "[]";
          }
        } else {
          throw new Error("Values for ENUM haven't been defined.");
        }
      }

      if (!type) {
        type = attribute.type;
      }

      var sql = type.toString();

      if (Object.prototype.hasOwnProperty.call(attribute, "allowNull") && !attribute.allowNull) {
        sql += " NOT NULL";
      }

      if (attribute.autoIncrement) {
        if (attribute.autoIncrementIdentity) {
          sql += " GENERATED BY DEFAULT AS IDENTITY";
        } else {
          sql += " SERIAL";
        }
      }

      if (Utils.defaultValueSchemable(attribute.defaultValue)) {
        sql += " DEFAULT ".concat(this.escape(attribute.defaultValue, attribute));
      }

      if (attribute.unique === true) {
        sql += " UNIQUE";
      }

      if (attribute.primaryKey) {
        sql += " PRIMARY KEY";
      }

      if (attribute.references) {
        var referencesTable = this.quoteTable(attribute.references.model);
        var schema;

        if (options.schema) {
          schema = options.schema;
        } else if ((!attribute.references.model || typeof attribute.references.model == "string") && options.table && options.table.schema) {
          schema = options.table.schema;
        }

        if (schema) {
          referencesTable = this.quoteTable(this.addSchema({
            tableName: referencesTable,
            _schema: schema
          }));
        }

        var referencesKey;

        if (!options.withoutForeignKeyConstraints) {
          if (attribute.references.key) {
            referencesKey = this.quoteIdentifiers(attribute.references.key);
          } else {
            referencesKey = this.quoteIdentifier("id");
          }

          sql += " REFERENCES ".concat(referencesTable, " (").concat(referencesKey, ")");

          if (attribute.onDelete) {
            sql += " ON DELETE ".concat(attribute.onDelete.toUpperCase());
          }

          if (attribute.onUpdate) {
            sql += " ON UPDATE ".concat(attribute.onUpdate.toUpperCase());
          }

          if (attribute.references.deferrable) {
            sql += " ".concat(attribute.references.deferrable.toString(this));
          }
        }
      }

      if (attribute.comment && typeof attribute.comment === "string") {
        if (options && ["addColumn", "changeColumn"].includes(options.context)) {
          var quotedAttr = this.quoteIdentifier(options.key);
          var escapedCommentText = this.escape(attribute.comment);
          sql += "; COMMENT ON COLUMN ".concat(this.quoteTable(options.table), ".").concat(quotedAttr, " IS ").concat(escapedCommentText);
        } else {
          sql += " COMMENT ".concat(attribute.comment);
        }
      }

      return sql;
    }
  }, {
    key: "deferConstraintsQuery",
    value: function deferConstraintsQuery(options) {
      return options.deferrable.toString(this);
    }
  }, {
    key: "setConstraintQuery",
    value: function setConstraintQuery(columns, type) {
      var _this6 = this;

      var columnFragment = "ALL";

      if (columns) {
        columnFragment = columns.map(function (column) {
          return _this6.quoteIdentifier(column);
        }).join(", ");
      }

      return "SET CONSTRAINTS ".concat(columnFragment, " ").concat(type);
    }
  }, {
    key: "setDeferredQuery",
    value: function setDeferredQuery(columns) {
      return this.setConstraintQuery(columns, "DEFERRED");
    }
  }, {
    key: "setImmediateQuery",
    value: function setImmediateQuery(columns) {
      return this.setConstraintQuery(columns, "IMMEDIATE");
    }
  }, {
    key: "attributesToSQL",
    value: function attributesToSQL(attributes, options) {
      var result = {};

      for (var key in attributes) {
        var attribute = attributes[key];
        result[attribute.field || key] = this.attributeToSQL(attribute, __spreadValues({
          key: key
        }, options));
      }

      return result;
    }
  }, {
    key: "createTrigger",
    value: function createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {
      var decodedEventType = this.decodeTriggerEventType(eventType);
      var eventSpec = this.expandTriggerEventSpec(fireOnSpec);
      var expandedOptions = this.expandOptions(optionsArray);

      var paramList = this._expandFunctionParamList(functionParams);

      return "CREATE ".concat(this.triggerEventTypeIsConstraint(eventType), "TRIGGER ").concat(this.quoteIdentifier(triggerName), " ").concat(decodedEventType, " ").concat(eventSpec, " ON ").concat(this.quoteTable(tableName)).concat(expandedOptions ? " ".concat(expandedOptions) : "", " EXECUTE PROCEDURE ").concat(functionName, "(").concat(paramList, ");");
    }
  }, {
    key: "dropTrigger",
    value: function dropTrigger(tableName, triggerName) {
      return "DROP TRIGGER ".concat(this.quoteIdentifier(triggerName), " ON ").concat(this.quoteTable(tableName), " RESTRICT;");
    }
  }, {
    key: "renameTrigger",
    value: function renameTrigger(tableName, oldTriggerName, newTriggerName) {
      return "ALTER TRIGGER ".concat(this.quoteIdentifier(oldTriggerName), " ON ").concat(this.quoteTable(tableName), " RENAME TO ").concat(this.quoteIdentifier(newTriggerName), ";");
    }
  }, {
    key: "createFunction",
    value: function createFunction(functionName, params, returnType, language, body, optionsArray, options) {
      if (!functionName || !returnType || !language || !body) throw new Error("createFunction missing some parameters. Did you pass functionName, returnType, language and body?");

      var paramList = this._expandFunctionParamList(params);

      var variableList = options && options.variables ? this._expandFunctionVariableList(options.variables) : "";
      var expandedOptionsArray = this.expandOptions(optionsArray);
      var statement = options && options.force ? "CREATE OR REPLACE FUNCTION" : "CREATE FUNCTION";
      return "".concat(statement, " ").concat(functionName, "(").concat(paramList, ") RETURNS ").concat(returnType, " AS $func$ ").concat(variableList, " BEGIN ").concat(body, " END; $func$ language '").concat(language, "'").concat(expandedOptionsArray, ";");
    }
  }, {
    key: "dropFunction",
    value: function dropFunction(functionName, params) {
      if (!functionName) throw new Error("requires functionName");

      var paramList = this._expandFunctionParamList(params);

      return "DROP FUNCTION ".concat(functionName, "(").concat(paramList, ") RESTRICT;");
    }
  }, {
    key: "renameFunction",
    value: function renameFunction(oldFunctionName, params, newFunctionName) {
      var paramList = this._expandFunctionParamList(params);

      return "ALTER FUNCTION ".concat(oldFunctionName, "(").concat(paramList, ") RENAME TO ").concat(newFunctionName, ";");
    }
  }, {
    key: "pgEscapeAndQuote",
    value: function pgEscapeAndQuote(val) {
      return this.quoteIdentifier(Utils.removeTicks(this.escape(val), "'"));
    }
  }, {
    key: "_expandFunctionParamList",
    value: function _expandFunctionParamList(params) {
      if (params === void 0 || !Array.isArray(params)) {
        throw new Error("_expandFunctionParamList: function parameters array required, including an empty one for no arguments");
      }

      var paramList = [];
      params.forEach(function (curParam) {
        var paramDef = [];

        if (curParam.type) {
          if (curParam.direction) {
            paramDef.push(curParam.direction);
          }

          if (curParam.name) {
            paramDef.push(curParam.name);
          }

          paramDef.push(curParam.type);
        } else {
          throw new Error("function or trigger used with a parameter without any type");
        }

        var joined = paramDef.join(" ");
        if (joined) paramList.push(joined);
      });
      return paramList.join(", ");
    }
  }, {
    key: "_expandFunctionVariableList",
    value: function _expandFunctionVariableList(variables) {
      if (!Array.isArray(variables)) {
        throw new Error("_expandFunctionVariableList: function variables must be an array");
      }

      var variableDefinitions = [];
      variables.forEach(function (variable) {
        if (!variable.name || !variable.type) {
          throw new Error("function variable must have a name and type");
        }

        var variableDefinition = "DECLARE ".concat(variable.name, " ").concat(variable.type);

        if (variable["default"]) {
          variableDefinition += " := ".concat(variable["default"]);
        }

        variableDefinition += ";";
        variableDefinitions.push(variableDefinition);
      });
      return variableDefinitions.join(" ");
    }
  }, {
    key: "expandOptions",
    value: function expandOptions(options) {
      return options === void 0 || _.isEmpty(options) ? "" : options.join(" ");
    }
  }, {
    key: "decodeTriggerEventType",
    value: function decodeTriggerEventType(eventSpecifier) {
      var EVENT_DECODER = {
        "after": "AFTER",
        "before": "BEFORE",
        "instead_of": "INSTEAD OF",
        "after_constraint": "AFTER"
      };

      if (!EVENT_DECODER[eventSpecifier]) {
        throw new Error("Invalid trigger event specified: ".concat(eventSpecifier));
      }

      return EVENT_DECODER[eventSpecifier];
    }
  }, {
    key: "triggerEventTypeIsConstraint",
    value: function triggerEventTypeIsConstraint(eventSpecifier) {
      return eventSpecifier === "after_constraint" ? "CONSTRAINT " : "";
    }
  }, {
    key: "expandTriggerEventSpec",
    value: function expandTriggerEventSpec(fireOnSpec) {
      if (_.isEmpty(fireOnSpec)) {
        throw new Error("no table change events specified to trigger on");
      }

      return _.map(fireOnSpec, function (fireValue, fireKey) {
        var EVENT_MAP = {
          "insert": "INSERT",
          "update": "UPDATE",
          "delete": "DELETE",
          "truncate": "TRUNCATE"
        };

        if (!EVENT_MAP[fireValue]) {
          throw new Error("parseTriggerEventSpec: undefined trigger event ".concat(fireKey));
        }

        var eventSpec = EVENT_MAP[fireValue];

        if (eventSpec === "UPDATE") {
          if (Array.isArray(fireValue) && fireValue.length > 0) {
            eventSpec += " OF ".concat(fireValue.join(", "));
          }
        }

        return eventSpec;
      }).join(" OR ");
    }
  }, {
    key: "pgEnumName",
    value: function pgEnumName(tableName, attr, options) {
      options = options || {};
      var tableDetails = this.extractTableDetails(tableName, options);
      var enumName = Utils.addTicks(Utils.generateEnumName(tableDetails.tableName, attr), '"');

      if (options.schema !== false && tableDetails.schema) {
        enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;
      }

      return enumName;
    }
  }, {
    key: "pgListEnums",
    value: function pgListEnums(tableName, attrName, options) {
      var enumName = "";
      var tableDetails = this.extractTableDetails(tableName, options);

      if (tableDetails.tableName && attrName) {
        enumName = " AND t.typname=".concat(this.pgEnumName(tableDetails.tableName, attrName, {
          schema: false
        }).replace(/"/g, "'"));
      }

      return "SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = '".concat(tableDetails.schema, "'").concat(enumName, " GROUP BY 1");
    }
  }, {
    key: "pgEnum",
    value: function pgEnum(tableName, attr, dataType, options) {
      var _this7 = this;

      var enumName = this.pgEnumName(tableName, attr, options);
      var values;

      if (dataType.values) {
        values = "ENUM(".concat(dataType.values.map(function (value) {
          return _this7.escape(value);
        }).join(", "), ")");
      } else {
        values = dataType.toString().match(/^ENUM\(.+\)/)[0];
      }

      var sql = "DO ".concat(this.escape("BEGIN CREATE TYPE ".concat(enumName, " AS ").concat(values, "; EXCEPTION WHEN duplicate_object THEN null; END")), ";");

      if (!!options && options.force === true) {
        sql = this.pgEnumDrop(tableName, attr) + sql;
      }

      return sql;
    }
  }, {
    key: "pgEnumAdd",
    value: function pgEnumAdd(tableName, attr, value, options) {
      var enumName = this.pgEnumName(tableName, attr);
      var sql = "ALTER TYPE ".concat(enumName, " ADD VALUE ");

      if (semver.gte(this.sequelize.options.databaseVersion, "9.3.0")) {
        sql += "IF NOT EXISTS ";
      }

      sql += this.escape(value);

      if (options.before) {
        sql += " BEFORE ".concat(this.escape(options.before));
      } else if (options.after) {
        sql += " AFTER ".concat(this.escape(options.after));
      }

      return sql;
    }
  }, {
    key: "pgEnumDrop",
    value: function pgEnumDrop(tableName, attr, enumName) {
      enumName = enumName || this.pgEnumName(tableName, attr);
      return "DROP TYPE IF EXISTS ".concat(enumName, "; ");
    }
  }, {
    key: "fromArray",
    value: function fromArray(text) {
      text = text.replace(/^{/, "").replace(/}$/, "");
      var matches = text.match(/("(?:\\.|[^"\\\\])*"|[^,]*)(?:\s*,\s*|\s*$)/ig);

      if (matches.length < 1) {
        return [];
      }

      matches = matches.map(function (m) {
        return m.replace(/",$/, "").replace(/,$/, "").replace(/(^"|"$)/g, "");
      });
      return matches.slice(0, -1);
    }
  }, {
    key: "dataTypeMapping",
    value: function dataTypeMapping(tableName, attr, dataType) {
      if (dataType.includes("PRIMARY KEY")) {
        dataType = dataType.replace("PRIMARY KEY", "");
      }

      if (dataType.includes("SERIAL")) {
        if (dataType.includes("BIGINT")) {
          dataType = dataType.replace("SERIAL", "BIGSERIAL");
          dataType = dataType.replace("BIGINT", "");
        } else if (dataType.includes("SMALLINT")) {
          dataType = dataType.replace("SERIAL", "SMALLSERIAL");
          dataType = dataType.replace("SMALLINT", "");
        } else {
          dataType = dataType.replace("INTEGER", "");
        }

        dataType = dataType.replace("NOT NULL", "");
      }

      if (dataType.startsWith("ENUM(")) {
        dataType = dataType.replace(/^ENUM\(.+\)/, this.pgEnumName(tableName, attr));
      }

      return dataType;
    }
  }, {
    key: "getForeignKeysQuery",
    value: function getForeignKeysQuery(tableName) {
      return "SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '".concat(tableName, "' LIMIT 1) AND r.contype = 'f' ORDER BY 1;");
    }
  }, {
    key: "_getForeignKeyReferencesQueryPrefix",
    value: function _getForeignKeyReferencesQueryPrefix() {
      return "SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name ";
    }
  }, {
    key: "getForeignKeyReferencesQuery",
    value: function getForeignKeyReferencesQuery(tableName, catalogName, schemaName) {
      return "".concat(this._getForeignKeyReferencesQueryPrefix(), "WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '").concat(tableName, "'").concat(catalogName ? " AND tc.table_catalog = '".concat(catalogName, "'") : "").concat(schemaName ? " AND tc.table_schema = '".concat(schemaName, "'") : "");
    }
  }, {
    key: "getForeignKeyReferenceQuery",
    value: function getForeignKeyReferenceQuery(table, columnName) {
      var tableName = table.tableName || table;
      var schema = table.schema;
      return "".concat(this._getForeignKeyReferencesQueryPrefix(), "WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='").concat(tableName, "' AND  kcu.column_name = '").concat(columnName, "'").concat(schema ? " AND tc.table_schema = '".concat(schema, "'") : "");
    }
  }, {
    key: "dropForeignKeyQuery",
    value: function dropForeignKeyQuery(tableName, foreignKey) {
      return "ALTER TABLE ".concat(this.quoteTable(tableName), " DROP CONSTRAINT ").concat(this.quoteIdentifier(foreignKey), ";");
    }
  }, {
    key: "quoteIdentifier",
    value: function quoteIdentifier(identifier, force) {
      var optForceQuote = force || false;
      var optQuoteIdentifiers = this.options.quoteIdentifiers !== false;
      var rawIdentifier = Utils.removeTicks(identifier, '"');

      if (optForceQuote === true || optQuoteIdentifiers !== false || identifier.includes(".") || identifier.includes("->") || POSTGRES_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())) {
        return Utils.addTicks(rawIdentifier, '"');
      }

      return rawIdentifier;
    }
  }]);

  return PostgresQueryGenerator;
}(AbstractQueryGenerator);

module.exports = PostgresQueryGenerator;