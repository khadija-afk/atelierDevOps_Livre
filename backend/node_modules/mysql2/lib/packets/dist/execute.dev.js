'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var CursorType = require('../constants/cursor');

var CommandCodes = require('../constants/commands');

var Types = require('../constants/types');

var Packet = require('../packets/packet');

var CharsetToEncoding = require('../constants/charset_encodings.js');

function isJSON(value) {
  return Array.isArray(value) || value.constructor === Object || typeof value.toJSON === 'function' && !Buffer.isBuffer(value);
}
/**
 * Converts a value to an object describing type, String/Buffer representation and length
 * @param {*} value
 */


function toParameter(value, encoding, timezone) {
  var type = Types.VAR_STRING;
  var length;

  var writer = function writer(value) {
    // eslint-disable-next-line no-invalid-this
    return Packet.prototype.writeLengthCodedString.call(this, value, encoding);
  };

  if (value !== null) {
    switch (_typeof(value)) {
      case 'undefined':
        throw new TypeError('Bind parameters must not contain undefined');

      case 'number':
        type = Types.DOUBLE;
        length = 8;
        writer = Packet.prototype.writeDouble;
        break;

      case 'boolean':
        value = value | 0;
        type = Types.TINY;
        length = 1;
        writer = Packet.prototype.writeInt8;
        break;

      case 'object':
        if (Object.prototype.toString.call(value) === '[object Date]') {
          type = Types.DATETIME;
          length = 12;

          writer = function writer(value) {
            // eslint-disable-next-line no-invalid-this
            return Packet.prototype.writeDate.call(this, value, timezone);
          };
        } else if (isJSON(value)) {
          value = JSON.stringify(value);
          type = Types.JSON;
        } else if (Buffer.isBuffer(value)) {
          length = Packet.lengthCodedNumberLength(value.length) + value.length;
          writer = Packet.prototype.writeLengthCodedBuffer;
        }

        break;

      default:
        value = value.toString();
    }
  } else {
    value = '';
    type = Types.NULL;
  }

  if (!length) {
    length = Packet.lengthCodedStringLength(value, encoding);
  }

  return {
    value: value,
    type: type,
    length: length,
    writer: writer
  };
}

var Execute =
/*#__PURE__*/
function () {
  function Execute(id, parameters, charsetNumber, timezone) {
    _classCallCheck(this, Execute);

    this.id = id;
    this.parameters = parameters;
    this.encoding = CharsetToEncoding[charsetNumber];
    this.timezone = timezone;
  }

  _createClass(Execute, [{
    key: "toPacket",
    value: function toPacket() {
      var _this = this;

      // TODO: don't try to calculate packet length in advance, allocate some big buffer in advance (header + 256 bytes?)
      // and copy + reallocate if not enough
      // 0 + 4 - length, seqId
      // 4 + 1 - COM_EXECUTE
      // 5 + 4 - stmtId
      // 9 + 1 - flags
      // 10 + 4 - iteration-count (always 1)
      var length = 14;
      var parameters;

      if (this.parameters && this.parameters.length > 0) {
        length += Math.floor((this.parameters.length + 7) / 8);
        length += 1; // new-params-bound-flag

        length += 2 * this.parameters.length; // type byte for each parameter if new-params-bound-flag is set

        parameters = this.parameters.map(function (value) {
          return toParameter(value, _this.encoding, _this.timezone);
        });
        length += parameters.reduce(function (accumulator, parameter) {
          return accumulator + parameter.length;
        }, 0);
      }

      var buffer = Buffer.allocUnsafe(length);
      var packet = new Packet(0, buffer, 0, length);
      packet.offset = 4;
      packet.writeInt8(CommandCodes.STMT_EXECUTE);
      packet.writeInt32(this.id);
      packet.writeInt8(CursorType.NO_CURSOR); // flags

      packet.writeInt32(1); // iteration-count, always 1

      if (parameters) {
        var bitmap = 0;
        var bitValue = 1;
        parameters.forEach(function (parameter) {
          if (parameter.type === Types.NULL) {
            bitmap += bitValue;
          }

          bitValue *= 2;

          if (bitValue === 256) {
            packet.writeInt8(bitmap);
            bitmap = 0;
            bitValue = 1;
          }
        });

        if (bitValue !== 1) {
          packet.writeInt8(bitmap);
        } // TODO: explain meaning of the flag
        // afaik, if set n*2 bytes with type of parameter are sent before parameters
        // if not, previous execution types are used (TODO prooflink)


        packet.writeInt8(1); // new-params-bound-flag
        // Write parameter types

        parameters.forEach(function (parameter) {
          packet.writeInt8(parameter.type); // field type

          packet.writeInt8(0); // parameter flag
        }); // Write parameter values

        parameters.forEach(function (parameter) {
          if (parameter.type !== Types.NULL) {
            parameter.writer.call(packet, parameter.value);
          }
        });
      }

      return packet;
    }
  }], [{
    key: "fromPacket",
    value: function fromPacket(packet, encoding) {
      var stmtId = packet.readInt32();
      var flags = packet.readInt8();
      var iterationCount = packet.readInt32();
      var i = packet.offset;

      while (i < packet.end - 1) {
        if ((packet.buffer[i + 1] === Types.VAR_STRING || packet.buffer[i + 1] === Types.NULL || packet.buffer[i + 1] === Types.DOUBLE || packet.buffer[i + 1] === Types.TINY || packet.buffer[i + 1] === Types.DATETIME || packet.buffer[i + 1] === Types.JSON) && packet.buffer[i] === 1 && packet.buffer[i + 2] === 0) {
          break;
        } else {
          packet.readInt8();
        }

        i++;
      }

      var types = [];

      for (var _i = packet.offset + 1; _i < packet.end - 1; _i++) {
        if ((packet.buffer[_i] === Types.VAR_STRING || packet.buffer[_i] === Types.NULL || packet.buffer[_i] === Types.DOUBLE || packet.buffer[_i] === Types.TINY || packet.buffer[_i] === Types.DATETIME || packet.buffer[_i] === Types.JSON) && packet.buffer[_i + 1] === 0) {
          types.push(packet.buffer[_i]);
          packet.skip(2);
        }
      }

      packet.skip(1);
      var values = [];

      for (var _i2 = 0; _i2 < types.length; _i2++) {
        if (types[_i2] === Types.VAR_STRING) {
          values.push(packet.readLengthCodedString(encoding));
        } else if (types[_i2] === Types.DOUBLE) {
          values.push(packet.readDouble());
        } else if (types[_i2] === Types.TINY) {
          values.push(packet.readInt8());
        } else if (types[_i2] === Types.DATETIME) {
          values.push(packet.readDateTime());
        } else if (types[_i2] === Types.JSON) {
          values.push(JSON.parse(packet.readLengthCodedString(encoding)));
        }

        if (types[_i2] === Types.NULL) {
          values.push(null);
        }
      }

      return {
        stmtId: stmtId,
        flags: flags,
        iterationCount: iterationCount,
        values: values
      };
    }
  }]);

  return Execute;
}();

module.exports = Execute;